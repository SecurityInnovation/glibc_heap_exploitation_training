#include <stdio.h>
#include <stdlib.h>

/*
Goal is for an mmap overlap over two books. 

- Either a buffer overflow or negative index to edit prev_size or size. 
- Munmap a different book via this overflow.
- Reallocate over the top of the previous book: 
	- Use the bad indexing (or format string bug) for a memory leak 
	- Overwrite content ptr for an arbitrary write 
- Overwrite malloc_hook with a one_gadget or system

*/

int largest_book = 0x100000;

struct book {
	char title[40];
	char author[40];
	int book_chars;
	char* content; // All book information is put directly below this pointer.
};

struct book* add_book(){
	char tmp_buf[8];
	fgets(tmp_buf, 8, stdin);

	// Validate that the size is large enough for a large book 

	// Saving a memory allocation by doing this here! :)
	struct book* new_book = malloc(sizeof(struct book) + atol(tmp_buf));

	// Get title and author 
	// Set the book_chars to the size (tmp_buf value) 
	// Set content to the new_book pointer + sizeof(struct book) 
	// Increase largest book once it is 'freed' (helps to emulate only using mmap chunks).
}

/*

write_page(){

	// Get book and page number to write to
*/

/*
Remove book 
*/

/* 
View book and page

*/

int main(){

}
