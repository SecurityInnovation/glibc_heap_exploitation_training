#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> 

/*
Goal is for an mmap overlap over two books. 

- Buffer overflow (off by one on page size) to overwrite mmap chunk size
- Munmap a different book via this overflow.
- Reallocate over the top of the previous book: 
	- Overwrite content ptr for an arbitrary write 
	- Leak: 
		- Overwrite something in the .bss section for leak
		- Format string (with fortify turned on)

- Overwrite malloc_hook or PLT/GOT with a one_gadget or system

*/

int PAGE_SIZE = 0x1000;
int largest_written_book = 128*1024;

struct book {
	char title[0x7e0];
	char author[0x7e0];
	int book_pages;
	char* content; // All book information is put directly below this pointer of an arbitrary size. 
};


struct book* add_book(){
	char tmp_buf[8];
	int pages; 
	
	printf("Pages in the book: ");
	fgets(tmp_buf, 8, stdin);
	
	// Validate that the size is large enough for a large book 
	pages = atol(tmp_buf);	
	if(pages * PAGE_SIZE < largest_written_book){
		printf("Book is too small for this library\n");
		return NULL;
	}
	
	// Saving a memory allocation by doing this here! :)
	struct book* new_book = malloc(sizeof(struct book) + pages * PAGE_SIZE);

	if(new_book == NULL){
		printf("Something went wrong...\n");
		return NULL;
	}

	// Get title of book
	printf("Title: ");
	fgets(new_book->title, 0x7e0, stdin);

	// Get author of book
	printf("Author: ");
	fgets(new_book->author, 0x7e0, stdin);

	// Add the two other fields
	new_book->book_pages = pages;
	new_book->content = (char *) &new_book->content + 8;
	printf("Page ptr: %p\n", new_book);
	return new_book;
}


int write_page(struct book* my_book){
	char tmp_buf[8];
	int page;

	// Get page to write to 	
	printf("Page to write: ");
	fgets(tmp_buf, 8, stdin);
	page = atol(tmp_buf);

	if(page < 0 || page > my_book->book_pages){
		printf("No such page\n");
		return 1;
	}
	
	// Recalculate the location to write to. 
	page = page * PAGE_SIZE;

	// Write to a section of the book.	
	printf("Please write the page: \n");
	read(0, my_book->content + page, PAGE_SIZE);
	return 0; 	
}


void* publish_book(struct book* my_book){
	if(my_book->book_pages * PAGE_SIZE > largest_written_book){
		largest_written_book = my_book->book_pages * PAGE_SIZE;
		printf("New record book!\n");
	}
	free(my_book);
	puts("Published the book!");
}


int view_page(struct book* my_book){
	char tmp_buf[8];
	int page;

	// Get page to write to 	
	printf("Page to write: ");
	fgets(tmp_buf, 8, stdin);
	page = atol(tmp_buf);

	if(page < 0 || page > my_book->book_pages){
		printf("No such page\n");
		return 1;
	}

	// Print the book 
	printf("Page %d of %s:\n", page, my_book->title);
	puts(my_book->content + page * PAGE_SIZE);
}

// Need a banner... 

int main(){
	
	// Main storage of books (only room for 10) 
	struct book* books[10]; 

	char buf[4];
	int option; 
	int index = 0; 

	while(1){
		fgets(buf, 4, stdin);
		option = atoi(buf); 

		// Add a book 
		if(option == 1){
			books[index] = add_book();
			index += 1;
		}
		
		// Write a page 
		else if(option == 2){
			printf("Book No:");			
			fgets(buf, 4, stdin);
			option = atoi(buf);
			if(option < 0 || option - 1 > index || books[option] == NULL){
				puts("Invalid Book");
				continue;
			}
			
			write_page(books[option]);
		}

		// View a page 
		else if(option == 3){

			printf("Book No:");			
			fgets(buf, 4, stdin);
			option = atoi(buf);
			if(option < 0 || option - 1 > index || books[option] == NULL){
				puts("Invalid Book");
				continue;
			}

			view_page(books[option]);
		}

		// Remove a book
		else if(option == 4){

			printf("Book No:");			
			fgets(buf, 4, stdin);
			option = atoi(buf);
			if(option < 0 || option - 1 > index || books[option] == NULL){
				puts("Invalid Book");
				continue;
			}

			// Remove the book
			publish_book(books[option]);
			books[option] = NULL;

		}
		else if(index == 9){
			printf("Out of room!\n");
			break;
		}
	}
}

