## General Thoughts 
This is just a heap grooming problem:  
- The chunk is put into the unsorted bin because it is of size 0x100
- The unsorted bin is FIFO

## Program
- The goal is to get **10** in the second ptr slot.
- There are two main options: 
	- birdie: mallocs a size of 0x100, adds the ptr to the list and increases the last_index by 1. 
	- bogey: Frees the chunk (in the ptr_lst) and increments the front_index.
	- win: Check to see if the 10 is in the second ptr slot.
- At the beginning of the program the birdie option is ran 5 times (0 indexed).

## Solving (without consolidation option) 
- The unsorted bin is FIFO. 
- At the very beginning, 5 chunks are already allocated (0-4).
- Allocate (birdie(1)) 4 times 
	- This will put the chunk count at 8.
- Run bogey (2) **twice**
	- This will put both of the chunks into the unsorted bin.
	- Because the chunks are adjacent in the unsorted bin, they are combined!
- Run birdie(1) once: 
	- This takes the bottom half of the chunk combined chunk(ptr 1). 
- Run birdie(1) once: 
	- The remainder chunk is now just ptr 2! 
	- At this point, it will give back the chunk to ptr2 at spot 10.
- Win(3)
	- Flag!

## Solving (with consolidation option enabled) 
- The unsorted bin is FIFO.
- At the very beginning, 5 chunks are already allocated (0-4).
- Free a single item: 
	- This will be explained in a future step.
- So, we want to fill up this up all the way until 9 (just before 10). 
	- Allocate 5 chunks with the birdie (1) option.
- Because the unsorted bin is a FIFO structure, the **the oldest freed ptr will the first to be used**(that fits). 
- So, we run bogey (2) **once** in order to free slot 1 and slot 2.
	- The bin will now look like the following: 
		- ptr1 
		- The pointer (unsorted bin) is taken out of the front first!
	- The reason we do the 'free' at the very beginning is that if we do the frees adjacently, then part of ptr1 will be eaten up by ptr2.
	
- Run birdie again to put **ptr2** into spot 10.
- Run the win function to get the flag.

