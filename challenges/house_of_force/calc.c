#include <stdlib.h>
#include <stdio.h> 


/*
TODO: 
- Initialization check on A and B
- strlen on get_operand
*/


/*
If the register is 0 (should be), then use the operand_value 
If the register is 1 or 2, then use the register
*/
struct operand{
	int reg; 
	long long value; 
}; 
typedef struct operand operand; 

// A single math operation, specified by the user
struct operation{
	operand* operand1; 
	long long operator; 
	operand* operand2; 
	long long result; 
	char* Notes;
}; 
typedef struct operation operation;

operation* A; 
operation* B; 
operation* op_storage[4]; 
int op_index;

/*

*/
int get_operand(char* calc_code, operand* operand_loc){

	char new_value[9], *stop_string; 
	int index = 0; 

	// Iterate until a space is found
	while((calc_code[0] != ' ' && calc_code[0] != '\n') && index < 8){
		char new_char = calc_code[0]; 

		// First, check for the registers being found. 
		if(new_char == 'a' || new_char == 'A'){
			operand_loc->reg = 1;
			return index + 2; // Account for the space
		} 	
		else if(new_char == 'b' || new_char == 'B'){
			operand_loc->reg = 2;
			return index + 2;  // Account for the space
		} 
		// Second, check for character we want being found. 
		else {
			new_value[index] = new_char; 
		}
	
		index += 1; 
		// Increment the pointer value
		calc_code = calc_code + 1; 
	}
	
	new_value[index+1] = '\0'; // Null terminate the string
	// Set the value on the struct
	operand_loc->value = strtoull(new_value, &stop_string, 10); 

	return index + 1;
}

int get_operator(char* calc_code){
	char new_char = calc_code[0]; 
	int operator = 0;
	if(new_char == '+')
		operator = 1; 
	else if(new_char == '-')
		operator = 2; 
	else if(new_char == '*')
		operator = 3; 
	else if(new_char == '/')
		operator = 4; 
	// Invalid operator
	else {
		return 0; 
	}
	return operator; 	
}

int do_math(operation* my_operation){
	long long operand1;
	long long operand2; 
	// Operand 1 - Get value
	if(my_operation->operand1->reg == 1)
		operand1 = A->result; 
	else if(my_operation->operand1->reg == 2)
		operand1 = B->result; 
	else operand1 = my_operation->operand1->value; 

	// Operand2 - Get value
	if(my_operation->operand2->reg == 1){
		operand1 = A->result; 
	}
	else if(my_operation->operand2->reg == 2){
		operand1 = B->result; 
	}
	else operand2 = my_operation->operand2->value; 
	// Get proper value from loc or register
	

	// Proper math operation 
	if(my_operation->operator == 1) 
		my_operation->result = operand1 + operand2; 
	else if(my_operation->operator == 2)
		my_operation->result =  operand2 - operand1;
	else if(my_operation->operator == 3)
		my_operation->result =  operand2 * operand1;
	else if(my_operation->operator == 4)
		my_operation->result =  operand2 / operand1;
	else
		printf("?\n");

	return 0; 

}

// Interpret the calculator code :) 
operation* interpret_line_calc(char* calculator_line){

	int amount; 
	operand* operand1 = malloc(sizeof(operand)); 
	amount = get_operand(calculator_line, operand1);

	printf("Value: %llu\n Reg: %d\n, Amount: %d\n", operand1->value, operand1->reg, amount);
	calculator_line = calculator_line + amount; 

	// Operator
	int operator = get_operator(calculator_line);
	if(operator == 0){
		// Failed operator gather
		return; 
	}

	calculator_line = calculator_line + 2; 

	// Operand 2
	operand* operand2 = malloc(sizeof(operand)); 
	amount = get_operand(calculator_line, operand2);
	calculator_line = calculator_line + amount; 

	printf("Value: %llu, Reg: %d\n", operand2->value, operand2->reg);

	// Create a new operation to store the data in 
	operation* new_operation = malloc(sizeof(operation)); 		
	//new_operation
	new_operation->operand1 = operand1; 
	new_operation->operand2 = operand2; 
	new_operation->operator = operator; 

	// Get Result
	do_math(new_operation);
	printf("Result: %llu\n", new_operation->result);

	return new_operation;
}

int get_note(char* calc_code, operation* new_operation){
	char new_char = calc_code[0]; 
	int index = 0;
	while(calc_code[index] != '\n' && index < 0x20){
		new_operation->Notes[index] = new_char; 
		index += 1; 
	}

	new_operation->Notes[index] = '\0'; 
	return index; 
}

void set_register(int reg, operation* location){
	if(reg == 1){
		A = location;
	}
	else if(reg == 2){
		B = location; 
	}
}

void add_operator(operation* new_operator){

	// Free the old one
	if(op_storage[op_index] != 0){
		printf("Free!\n");
		free(op_storage[op_index]->operand1); 
		free(op_storage[op_index]->operand2); 
		free(op_storage[op_index]);
	}	

	// Add the new one and increment the index, with a maximum of four
	op_storage[op_index] = new_operator; 
	op_index = (op_index + 1) % 4; 
}

void interpret_line_reg(char* reg_code){

	// Location in the array
	int loc = reg_code[0] - '0'; 
	printf("Loc: %d, reg_code: %c\n", loc, reg_code[0]);
	reg_code += 2; // Eat char and space

	// Register 
	char reg = reg_code[0]; 	
	reg_code += 1; // Eat char 

	
	// Side-Effect to alter the register state
	if(reg == 'A' || reg == 'a'){
		A = op_storage[loc];
	}
	else if(reg == 'B' || reg == 'b'){
		B = op_storage[loc];
	}

	return;	
	
}

void new_menu()
{
}
void interpret(char* calculator_code){

	// Complete the parsing :) 	
	operation* new_operator;
	while(calculator_code[0] != '\x04'){
		int my_choice = calculator_code[0] - '0'; // Convert to integer
		
		while(calculator_code[0] != '\n') // Increment the pointer
			calculator_code = calculator_code + 1; 
		calculator_code += 1; 

		if(my_choice == 1){
			add_operator(interpret_line_calc(calculator_code)); 
		}
		else if(my_choice == 2)
			interpret_line_reg(calculator_code);
		while(calculator_code[0] != '\n') // Increment the pointer
			calculator_code = calculator_code + 1; 
		calculator_code += 1; 
	}

	new_menu(); 
}



int main(){
	char calc_code[200]; 
	int i = 0; 
	char ch;
	while ( (ch = getchar()) != EOF)// user can input until the EOF which he or she enters to mark the end of his/her typing or more appropriately input.
	{
		calc_code[i] = ch;// you can store all the input character by character in a char array 
		i++;
 	}

	interpret(calc_code); 
}

