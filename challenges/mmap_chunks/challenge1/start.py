'''
Mmap chunk Full POC
This POC should work on all versions of libc. But, the LibC specific version for this is 2.31

Breaks: 
- Buffer overflow (vulnerability) 
- Overlapping chunks 
- Leak 
- Arbitrary Write
- Pop shell (this and the one prior could be the same)
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../../libc_versions/2.31/libc-2.31.so'
env = {}

# Binary setup
elf_name = '.book_shop-2.31'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.31/
''')
else: 
	p = remote(domain, port) 


# Create a book
def create_book(name, author, pages): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("book:", str(pages)) 
	p.sendlineafter("Title:", str(name)) 
	p.sendlineafter("Author:", str(author))
	return 

# Write a page
def write_page(book_no, page_no, content): 
	p.sendlineafter(">", "2") 
	p.sendlineafter("No:", str(book_no))
	p.sendlineafter("write:", str(page_no))
	p.sendlineafter("page:", str(content))

# Publish a book (free it) 
def publish(book_no):
	p.sendlineafter(">", "4") 
	p.sendlineafter("No:", str(book_no))

# View a book
def view(book_no, page_no): 
	p.sendlineafter(">", "3") 
	p.sendlineafter("No:", str(book_no))
	p.sendlineafter("view:", str(page_no))

	# Parse out the book and content
	p.recvuntil("of ") 
	book_name = p.recvline()
	content = p.recvuntil("Large")[:-5]
	return book_name, content


''' 
LibC leak with format string
===========================

The content section of a print does not use a format string properly. 
For more information on format string vulnerabilities, please visit 
https://medium.com/swlh/binary-exploitation-format-string-vulnerabilities-70edd501c5be. 
'''
def leak(): 
	pass

'''
Overlapping mmap chunks via buffer overflow
==========================================

Mmap Basics
===============
Extremely large chunks (greater than 128 * 1024 to start) 
are not handled in the normal ways. All of the 'books' are
going to be of very large sizes. 

Very large chunks are allocated via a straight call to 
the syscall mmap. Similarly, munmap is used for freeing. The
second bit (| 0x2) is for marking if a chunk was mmapped.

Size and Prev Size fields are handled slightly differently. 
The size is the same. However, the prev_size field is used 
as the leftover data of a given chunk from mmap (on the 
current chunk). Mmap chunks are NOT handled in bins. 

Mmap chunks grow downards in memory (in terms of WHERE a chunk gets
placed at. 

Vulnerability
===============
The buffer overflows exists because of an off by 1 error in the 
source code for the page to write to. This allows for the size 
and prev_size to be overwritten of an mmap chunk.

Overlapping Chunks
==================
This is pretty similar to before, but with less sanity checks. 
There is only one criteria that must be met on a free: prev_size
+ size is equvalient to multiple of a page. 

'''	
def overlap_chunks():
	pass


# Creates the ability to write to anywhere in memory via ptr overwrite
def arbitrary_write(libc_base):
	pass


def overlap_chunks1():
	pass


def pop_shell(libc_base): 
	pass


print "Starting Mmap Chunk Overlapping...." 
print "===================================="
overlap_chunks()
libc_base = leak()
arbitrary_write(libc_base) 
pop_shell(libc_base)

p.interactive()


