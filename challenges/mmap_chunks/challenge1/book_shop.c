#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> 

/*
Can you write the longest book? Let's see you try! 

Compile: `gcc book_shop.c -o book_shop -g -fPIE -pie -Wl,-z,relro,-z,now -D_FORTIFY_SOURCE=2`
For debugging, removing the '-fPIE -pie' makes life much easier, as debugging symbols in GDB don't work if PIE is turned on.
*/

int PAGE_SIZE = 0x1000;
int largest_written_book = 128*1024;

struct book {
	char title[0x7e0];
	char author[0x7e0];
	int book_pages;
	char* content; // All book information is put directly below this pointer of an arbitrary size. 
};

/*
Add a book 

Returns:
	- A pointer to a book struct
*/
struct book* add_book(){
	char tmp_buf[8];
	int pages; 
	
	printf("Pages in the book: ");
	fgets(tmp_buf, 8, stdin);
	
	// Validate that the size is large enough for a large book 
	pages = atol(tmp_buf);	
	if(pages * PAGE_SIZE < largest_written_book){
		printf("Book is too small for this library\n");
		return NULL;
	}
	
	// Saving a memory allocation by doing this here! :)
	struct book* new_book = malloc(sizeof(struct book) + pages * PAGE_SIZE);

	if(new_book == NULL){
		printf("Something went wrong...\n");
		return NULL;
	}

	// Get title of book
	printf("Title: ");
	fgets(new_book->title, 0x7e0, stdin);

	// Get author of book
	printf("Author: ");
	fgets(new_book->author, 0x7e0, stdin);

	// Add the two other fields
	new_book->book_pages = pages;
	new_book->content = (char *) &new_book->content + 8;
	printf("Page ptr: %p\n", new_book);
	return new_book;
}

/* 
Write to a page in a book 

Parameters: 
	- my_book: A pointer to a book
Returns: 
	- Write success (0 for good, 1 for bad)
*/
int write_page(struct book* my_book){
	char tmp_buf[8];
	int page;

	// Get page to write to 	
	printf("Page to write: ");
	fgets(tmp_buf, 8, stdin);
	page = atol(tmp_buf);

	if(page < 0 || page > my_book->book_pages){
		printf("No such page\n");
		return 1;
	}
	
	// Recalculate the location to write to. 
	page = page * PAGE_SIZE;

	// Write to a section of the book.	
	printf("Please write the page: \n");
	read(0, my_book->content + page, PAGE_SIZE);
	return 0; 	
}

/*
Publishs a book (free) 

Parameters: 
	- my_book: a pointer to a book
*/
void* publish_book(struct book* my_book){

	// Updates the largest finished book
	if(my_book->book_pages * PAGE_SIZE > largest_written_book){
		largest_written_book = my_book->book_pages * PAGE_SIZE;
		printf("New record book!\n");
	}
	free(my_book);
	puts("Published the book!");
}

/* 
Print a books page 

Parameters: 
	- my_book: A pointer to a book struct

Returns: 
	- status of call (0 for success, 1 for bad) 
*/
int view_page(struct book* my_book){
	char tmp_buf[8];
	int page;

	// Get page to write to 	
	printf("Page to view: ");
	fgets(tmp_buf, 8, stdin);
	page = atoll(tmp_buf);

	if(page < 0 || page > my_book->book_pages){
		printf("No such page\n");
		return 1;
	}

	// Print the book 
	printf("Page %d of %s:\n", page, my_book->title);
	printf(my_book->content + page * PAGE_SIZE);
}

void* banner(){
	puts("Large Book Collector");
	puts("=====================");
	puts("1. Add Book");
	puts("2. Write Page");
	puts("3. View Page");
	puts("4. Publish Book");
	puts("5. Exit");
	printf("> ");
}

int main(){

        setvbuf(stdout,0,2,0);
        setvbuf(stdin,0,2,0);
	clearenv();
	
	// Main storage of books (only room for 10) 
	struct book* books[10]; 

	char buf[4];
	int option; 
	int index = 0; 

	while(1){
		banner();
		fgets(buf, 4, stdin);
		option = atoi(buf); 

		// Add a book 
		if(option == 1){
			books[index] = add_book();
			index += 1;
		}
		
		// Write a page 
		else if(option == 2){
			printf("Book No:");			
			fgets(buf, 4, stdin);
			option = atoi(buf);
			if(option < 0 || option - 1 > index || books[option] == NULL){
				puts("Invalid Book");
				continue;
			}
			
			write_page(books[option]);
		}

		// View a page 
		else if(option == 3){

			printf("Book No:");			
			fgets(buf, 4, stdin);
			option = atoi(buf);
			if(option < 0 || option - 1 > index || books[option] == NULL){
				puts("Invalid Book");
				continue;
			}

			view_page(books[option]);
		}

		// Publish (remove) a book
		else if(option == 4){

			printf("Book No:");			
			fgets(buf, 4, stdin);
			option = atoi(buf);
			if(option < 0 || option - 1 > index || books[option] == NULL){
				puts("Invalid Book");
				continue;
			}

			// Remove the book
			publish_book(books[option]);
			books[option] = NULL;

		}
		else if(option == 5){
			printf("Byte byte\n");
			break; 
		}
		else if(index == 9){
			printf("Out of room!\n");
			break;
		}
	}
}

