from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.23/libc-2.23.so'
env = {}

# Binary setup
elf_name = './.fix_chunk'

elf = ELF(elf_name)
if libc_name != '':
        libc = ELF(libc_name)
        env = {"LD_PRELOAD": libc.path}

# Process creation 
if mode == 'DEBUG':
        p = process([elf.path],env=env)
        gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.23/
''')

'''
Below is the heap layout: 
=============================

bottom - 0xa0 (free)
-----------
top    - 0x110 (in use) 
-----------
filler - 0x20 (in use) 
-----------

The previous chunks IS not in use. So, this means that the 
'prev_size' field of the 'top' chunk will be used. 

The 'bottom' chunk is of size 0xa0. So, the prev_size chunk is ALSO 0xa0. 
'''
prev_size = p64(0xa0) 


'''
This ORIGINAL chunk size is 0x110. So, this is the size of it. 

Additionally, the previous chunk is NOT in use. So, 
the 'prev_inuse' bit should NOT be set. So, the metadata
of the chunk (n,m,p) should all be 0. 

'''
size = p64(0x110 | 0x0)

'''
prev_size: 0xa0
size: 0x110 
'''
p.sendline(prev_size + size)

'''
Additional solution
=====================

Even though we are setting the prev_inuse bit of the chunk to be 0, what would
happen if we set this to 1? Well, the 'prev_size' would 
be entirely ignored, and the program will pass. Although this is NOT the goal
of the program, this does work just fine for understanding how chunks work. 
'''
p.interactive()
