#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <time.h> 


/*
The House of IO is a technique for bypasses pointer mangling.
However, other than just using the 'key' parameter for writes!
it can be used for reads!

The idea was that the 'key' parameter (for double free protections) 
is the actual location of the heap. The area is made up of two regions: 
- counts (chars) 
- entries (pointers) 

If we could fill up the counts, we would eventually be able
to read the entries! In practice, the alignment does not allow
for this to happen on 64-bit :( 

In theory though, this COULD work on 32-bit! So, something to try out? 

*/

struct random_collection{
	long long number; // Random number to store 
	char* other_string; 
	void* show;
	// Add filler here 
};



struct random_collection* collection[1000]; 
int collection_amount = 0;

// Random vars
char* num1 = "Fun!"; 
char* num2 = "Not Fun!"; 
char* num3 = "Something between Fun and Not Fun!";
char* rand_list[3];

void banner(){
        puts("Options");
        puts("========");
        puts("1. Add Num");
        puts("2. Edit Num");
        puts("3. Remove Num");
        puts("4. See Num");
        puts("5. Exit");
        printf("> ");

}


void show1(int index){
        if(collection[index] == 0 || index >= collection_amount){
                puts("Bad Index");
        }

	printf("Random String: %s\n", collection[index]->other_string);
}

// TODO 
void show2(int index){}

void add_num(){
	char buf[8];
	
	printf("Filler size: ");
	fgets(buf, 8, stdin);
	int size = atoi(buf);

	// TODO: Sanity check on the filler later
	struct random_collection* my_collection = malloc(sizeof(struct random_collection) + size);	

	// Get users random number
	printf("Random number: "); 
	fgets(buf, 8, stdin);
	my_collection->number = atoll(buf);
	
	// Random string
	my_collection->other_string = rand_list[rand() % 3];	

	// Print function to use	
	if(size < 20){
		my_collection->show = show1;
	}	
	else {
		my_collection->show = show2;
	}

	collection[collection_amount] = my_collection; 
	collection_amount += 1; 
}

void remove_num(int index){
	if(collection[index] != 0 || index >= collection_amount){
		puts("Bad Index");
	}
	
	free(collection[index]);
}

void edit_num(int index){
	char buf[20];
	if(collection[index] == 0 || index >= collection_amount){
		puts("Bad Index");	
	}
	// Get users random number
	printf("Random number: "); 
	fgets(buf, 20, stdin);
	collection[index]->number = atoll(buf);
}


void init(){
	 // Turn off buffering and remove env variables
        setvbuf(stdout,0,2,0);
        setvbuf(stdin,0,2,0);
        clearenv();

	// Set random base
	srand(time(0));

	// Init strings 
	rand_list[0] = num1; 
	rand_list[1] = num2;
	rand_list[2] = num3;	
}

int main(){

        char buf[4];
        int option = 0;
	init();


        while(1){
                banner();
                fgets(buf, 4, stdin);
                option = atoi(buf);

                // Add number
                if(option == 1){
                        add_num();
                }
                // Edit number
                else if(option == 2){
			printf("Index: ");
         		fgets(buf, 4, stdin);
                	option = atoi(buf);

                        edit_num(option);
                }
                // Remove number
                else if(option == 3){
			printf("Index: ");
         		fgets(buf, 4, stdin);
                	option = atoi(buf);
                        remove_num(option);
                }
                // View the contents of the number
                else if(option == 4){
			printf("Index: ");
         		fgets(buf, 4, stdin);
                	option = atoi(buf);
		
			if(collection[option] == NULL || collection_amount < option){
				puts("Bad Index");
				continue;
			}
			
			void (*func_ptr)(int);	
			func_ptr = collection[option]->show; 
			func_ptr(option);
                }
                else if(option == 5){
                        break;
                }
        }

        return 0;

}
