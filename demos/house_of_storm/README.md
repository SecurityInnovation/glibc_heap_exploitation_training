# House of Storm Demo 
- This technique is a proof of concept for the *House of Storm* technique. 
- This technique is used to get a chunk from an arbitrary address! The MOST powerful technique we can hope for :)
- Useful when there is a nice use after free on unsorted bin and large bin chunks.

## Setup
- There are two POCs here: 
	- Prior to TCache (2.23)  and after TCache (2.26).
- Size equality:
    - Otherwise, there is a 1/2 chance that the fourth bit of the size will be set, causing a crash to occur later. 
    - Additionally, there is another 1/4 of chance of a crash. There is dependent on having ONE of the following be true: 
        - mmap bit is set
        - arena of the chunk matches the arena for the bin. In most cases, we simply want this to have a 0 in the non-main arena bit. 

## Structure
- house_of_storm.c: The source code proof of concept for the technique
- house_of_storm: The compiled binary for the challenge
- payload.py: The startup script to view the challenge in a nice ENV. 
- compile.sh: The script to compile this demo program 

## How the Technique Works
- Setup of the chunks: 
    - One in the large bin 
    - One in the unsorted bin
        - The unsorted bin must be of a large bin size and go into the same bin as the 'large bin' above
        - Also, the chunk MUST be smaller than the 'large bin' chunk
        - It MUST be linked with this chunks fd, bk and everything else to make this exploit work. 
- Modifications made to the chunks
	- Modify the unsorted bins 'fd' to be NULL
	- Modify the unsorted bin 'bk to point to the head of the fake chunk (address to return later) 
	- Large bin 'fd' to point to somewhere so that it won't crash
	- Modify large bin 'bk_nextsize' to point to an offset of fake chunk for a fake *size*: 
        - This MUST be at our fake_chunk - 0x18 - an offset: 
        - The offset depends on if PIE is in used or not. 
        - If PIE, the offset is 5. If no-pie, then the offset is 2.
- Call to malloc: 
	- 1st unsorted bin iteration:
		- Unsorted bin head, which has the bk corrupted with a large bin sized chunk 
		- Writes address of unsorted bin to fake chunk location (unsorted bin attack):
			- bck->fd = unsorted_bin (av), where bck = fake chunk
		- Large bin functionality (beginning of the list): 
		- Take large bin fake 'bk_nextsize' pointer and use this as the end of the large bin: 
			- This location is used as the 'size' offset
			- victim->bk_nextsize = fwd->bk_nextsize;
		- Write to the location of 'bk_nextsize' with the current pointer being used: 
			- Use as a FAKE size for later
			- victim->bk_nextsize->fd_nextsize = victim;
		- Write to the location of the fake pointer to 0x10 with the value of the current chunk being freed:
			- bck->fd = victim;
	- 2nd call to malloc: 
		- We want to take the 'exact match' way out of this!
		- So, the size of the malloc request MUST match the size that we are writing
		- If the size matches what we want, this SHOULD work :) 
	- Writes address of heap chunk to the fake chunk (done via fake bk_nextsize on the large bin) 
	- Writes the address of 'fd' largebins to the fake chunk
	- Write a fake size to a size offset of the fake chunk with the largebin address
	- Once this size is realized to be PERFECT on our fake chunk, it will take out our fake chunk via the escape clause!
- The 'exact match' section of the code will make this work
	- This requires either a LEAK (to know how much data to request) or some brute forcing.
	- Or, an unsigned long is ONLY what the size is checked for. So, what if we requested a chunk with the TOP half? 
- NOTE: 
	- I ran into complications when using the tcache versions because of the 'stashing' being done. 
	- So, we MAY need to make the tcache full in order for this to work every time. 
	- Offsets are also different on PIE
	- Because we HAVE to use the top of the chunk, this is slightly complicated to HANDLE!



## Resources 
- https://xz.aliyun.com/t/5265
- https://bbs.pediy.com/thread-257648.htm
