#!/usr/bin/env python3
'''
Unsorted Bin Attack Challenge solution
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../../libc_versions/2.26/libc-2.26.so' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.uninit-2.26'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = gdb.debug(elf.path, env=env, gdbscript='''
dir ../../../libc_versions/2.26/
''') 
else: 
	p = process(elf.path, env=env) 

'''
Creates a secret storage location
'''
def create_secret():
	p.sendlineafter(">", "1") 

'''
View A secret

Parameter:
	- index: The index of the secret to print
Returns: 
	- The output from the print
'''
def view_secret(index): 
	p.sendlineafter(">", "4")
	p.sendlineafter(">", str(index))
	p.recvuntil("Your secret:") # Right before secret output

	# Outputted data
	output = p.recvuntil(b"Welcome").replace(b"Welcome",b"") 
	return output

'''
Delete a secret 

Parameter: 
	- index: The index of the secret to remove
'''	
def delete_secret(index): 
	p.sendlineafter(">", "3")
	p.sendlineafter(">", str(index))
	return 

''' 
Set a secret
Parameters: 
	- index: The index of the secret to set
	- secret: The text to be put into the secret
'''
def set_secret(index, secret):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(index))
	p.sendlineafter(">", secret)
	return 

'''
Solve the exercise
Parameters: 
	- value: The secret value guess
'''
def check_flag(value):
	p.sendlineafter(">", "5") 
	p.sendlineafter("Value:", value)


'''
The struct stores the secret. The actual value is stored in `secret->value`. 
The secret struct has two unused values (filler1 and filler2). The struct is
shown below: 

```
	// The secret struct
	struct secret {
		long long filler1; 
		long long filler2; 
		char value[secrets_size];
	};
```


At the very beginning of the program, a secret is created, set and removed.
The code for this is shown below: 
```
	void* create_top_secret(){
		struct secret* my_secret = create_secret();

		...
		
		// Copying the secret to this manuall
		sprintf(my_secret->value, "%d", flag_value); 

		// Remove the secret and the end the session
		free(my_secret); 
	}

```

Now that you know the bug, exploit this and get the leak :)
'''

p.interactive()


