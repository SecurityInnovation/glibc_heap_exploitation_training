#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <time.h>

/* 
Timmy has built his own secrets class!

The goal of the challenge is to steal another persons
secret. 

HINT: Uninitialized memory. 
HINT: Check out the 'create_top_'secret' function.
*/


// Size of the allowed secret
#define secrets_size 0x90 

// The secret struct
struct secret {
	char value[secrets_size];
};

// Global storage of secrets
struct secret* secrets[200];

// The goal of the exercise to retrieve
long long flag_value; 

struct secret* create_secret(){

	// Ptr to new secrets	
	struct secret* new_secret = malloc(secrets_size);	

	printf("Please enter your secrets\n> ");

	return new_secret;
}

// Free the secrets 
int delete_secret(struct secret* my_secret){
	free(my_secret);
	printf("secrets deleted\n");
	return 0;
}

// Edit a secrets
int* set_secret(struct secret* my_secret){
	printf("Please enter your new secrets content\n>");
	read(0, my_secret->value, secrets_size);	
}

// View a secrets
void* view_secret(struct secret* my_secret){
	printf("Your secret:\n");
	write(1, my_secret->value, secrets_size);
}

void init(){
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stdin, NULL, _IONBF, 0);
	clearenv();
}

void banner(){
	puts("Welcome to Timmy's secrets. This is the CLI to play with:)");
	puts("1. Create New secrets"); 
	puts("2. Set secret"); 
	puts("3. Delete secret"); 
	puts("4. View secret"); 
	puts("5. Check flag"); 
	puts("6. Exit"); 
	printf(">");
}

// Other users previous usage
void* create_top_secret(){
	struct secret* my_secret = create_secret();

	// Get a random number for the secret flag
	srand(time(NULL));
	flag_value = rand(); 

	// Copying the secret to this manuall
	sprintf(my_secret->value, "%lld", flag_value); 

	// Remove the secret and the end the session
	free(my_secret); 
}

int main(){

	init();	
	int option = 0;
	int iter = 0; 
	char tmp_option[20]; 

	// Pretend somebody was previously using this :) 
	create_top_secret();

	while(1){
		banner();
		fgets(tmp_option, 20, stdin);
		option = atoi(tmp_option);

		// Create secret storage location
		if(option == 1){	
			secrets[iter] = create_secret(); 
			printf("New secrets added to index %d\n", iter);
			iter += 1; 
		}

		// Set the secret value
		else if(option == 2){	
			printf("Index >");
			fgets(tmp_option, 20, stdin);
			option = atoi(tmp_option);
			if(option >= 0 && option <= iter -1 && secrets[option] != NULL){
				set_secret(secrets[option]);
			}
			else {
				puts("Improper Index");
			}
		}

		// Delete secrets
		else if(option == 3){
			printf("Index >");
			fgets(tmp_option, 20, stdin);
			option = atoi(tmp_option);
			if(option >= 0 && option <= iter - 1 && secrets[option] != NULL){
				delete_secret(secrets[option]);

				// Prevent use after free vulnerability
				secrets[option] = NULL;
			}
			else {
				puts("Improper Index");
			}

		}
		// View secrets
		else if(option == 4){
			printf("Index >");
			fgets(tmp_option, 20, stdin);
			option = atoi(tmp_option);
			if(option >= 0 && option <= iter - 1 && secrets[option] != NULL){
				view_secret(secrets[option]);
			}
			else {
				puts("Improper Index");
			}
		}
		// Check if the flag is right!
		else if(option == 5){
			printf("Value: ");
			fgets(tmp_option, 20, stdin);	
			option = atoi(tmp_option);
			if(option == flag_value){
				printf("C0ngrats! Challenge solved! :)");
				return 1;			
			}
			else{
				puts("Wrong...");
			}
		}
		// Exit (leave)
		else if(option == 6){
			return 1; 
		}
	}
}


