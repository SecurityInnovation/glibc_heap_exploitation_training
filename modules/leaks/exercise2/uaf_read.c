#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <time.h>

/* 
Timmy has built his own secrets class!

The goal of the challenge is to leak the libc address. 

Do to your hearts desire :) 
*/


// Size of the allowed secret
#define secrets_size 0x90 

// The secret struct
struct secret {
	char value[secrets_size];
};

// Global storage of secrets
struct secret* secrets[200];

long long heap_base = 0x0; 
long long libc_base = 0x0; 

struct secret* create_secret(){

	// Ptr to new secrets	
	struct secret* new_secret = malloc(secrets_size);	

	printf("Please enter your secrets\n> ");

	return new_secret;
}

// Free the secrets 
int delete_secret(struct secret* my_secret){
	free(my_secret);
	printf("secrets deleted\n");
	return 0;
}

// Edit a secrets -- in progress
int* set_secret(struct secret* my_secret){
	// printf("Please enter your new secrets content\n>");
	// read(0, my_secret->value, secrets_size);	
}

// View a secrets
void* view_secret(struct secret* my_secret){
	printf("Your secret:\n");
	write(1, my_secret->value, secrets_size);
}

void init(){
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stdin, NULL, _IONBF, 0);
	clearenv();

	// Setup the KNOWN values -- ignore this...
	heap_base = (long long) sbrk(0); // Heap base
	libc_base = ((long long ) &system) - 0x3f520; // LibC base
}

// Checks the input of the user
void check_value(unsigned long long value){
	if(value == heap_base){
		puts("Heap succeeded :)");
	}else if(value == libc_base){
		puts("LibC succeeded ;)");
	}
	else{
		puts("Base calculation failed");
	}
}

void banner(){
	puts("Welcome to Timmy's secrets. This is the CLI to play with:)");
	puts("1. Create New secrets"); 
	puts("2. Set secret"); 
	puts("3. Delete secret"); 
	puts("4. View secret"); 
	puts("5. Check value"); 
	puts("6. Exit"); 
	printf(">");
}

int main(){

	init();	
	unsigned long long option = 0;
	int iter = 0; 
	char tmp_option[20]; 
	char* end; 

	while(1){
		banner();
		fgets(tmp_option, 20, stdin);
		option = atoi(tmp_option);

		// Create secret storage location
		if(option == 1){	
			secrets[iter] = create_secret(); 
			printf("New secrets added to index %d\n", iter);
			iter += 1; 
		}

		// Set the secret value
		else if(option == 2){	
			puts("Under construction! Try again later");
		}

		// Delete secrets
		else if(option == 3){
			printf("Index >");
			fgets(tmp_option, 20, stdin);
			option = atoi(tmp_option);
			if(option >= 0 && option <= iter - 1){
				delete_secret(secrets[option]);

				// Prevent use after free vulnerability
				// secrets[option] = NULL;
			}
			else {
				puts("Improper Index");
			}

		}
		// View secrets
		else if(option == 4){
			printf("Index >");
			fgets(tmp_option, 20, stdin);
			option = atoi(tmp_option);
			if(option >= 0 && option <= iter - 1){
				view_secret(secrets[option]);
			}
			else {
				puts("Improper Index");
			}
		}
		// Check if the flag is right!
		else if(option == 5){
			printf("Value: ");
			fgets(tmp_option, 20, stdin);	
			option = strtoull(tmp_option, &end, 16);
			check_value(option);
		}
		// Exit (leave)
		else if(option == 6){
			return 1; 
		}
	}
}


