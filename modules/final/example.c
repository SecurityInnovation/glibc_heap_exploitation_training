#include <stdlib.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>

#include "server.h"
#include "utils.h"


/*
Route1 - A simple GET Route

Returns: 
- A pointer to 'struct server_response*' with the data and status
*/
struct server_response* route1_func(){
    struct server_response* my_response = malloc(sizeof(struct server_response)); 
    char* data = malloc(0x40);
    strcpy(data, "My GET Route :)");
    my_response->data = data; 
    my_response->length = strlen(my_response->data);
    my_response->status = 200; 

    return my_response;
}

/*
Route2 - A simple GET Route

Returns: 
- A pointer to 'struct server_response*' with the data and status
*/
struct server_response* route2_func(){
    struct server_response* my_response = malloc(sizeof(struct server_response)); 
    char* data = malloc(0x40);
    strcpy(data, "My POST Route :)");
    my_response->data = data; 
    my_response->length = strlen(my_response->data);
    my_response->status = 200; 

    return my_response;
}

/*
Reflects a header, body or query parameter in the header or body.
Parameters: 
- type: The location to get the data to reflect. header & body & query are valid.
- location: The location to reflect the data. header & body are valid. 
- key: The 'key' to use in the header, query parameter in body or URL.

Returns: 
- A pointer to 'struct server_response*' with the data and status. 
- Reflects the input from the request into the response with the query parameter above. 

Sample request: 
```
GET /echo?type=header&location=body&key=MyHeaderName HTTP/1.1
MyHeaderName:AAAA
```

Sample Response: 
```
HTTP/1.1 200
Content-Length:17

MyHeaderName:AAAA
```
*/
struct server_response* echo_service(){

    int type_index = -1; 
    int loc_index = -1; 
    int key_index = -1; 

    struct server_response* my_response = malloc(sizeof(struct server_response)); 
    char* bad_data = malloc(0x40);
    strcpy(bad_data, "Bad input parameters");
    my_response->data = bad_data; 
    my_response->length = strlen(my_response->data);
    my_response->status = 400; 

    // Find the data points we need for the endpoint
    for(int index = 0; index < begin_request->query_amount; index += 1){
        if(strcmp(begin_request->query_params[index]->name, "type") == 0)
            type_index = index;
        else if(strcmp(begin_request->query_params[index]->name, "location") == 0)
            loc_index = index; 
        else if(strcmp(begin_request->query_params[index]->name, "key") == 0)
            key_index = index; 
    }

    // If one of the parameters was not found
    if(type_index == -1 || loc_index == -1 || key_index == -1){
        return my_response; 
    }

    char* data_pointer; 
    size_t data_size; 

    // Data to use for the INPUT
    if(strcmp(begin_request->query_params[type_index]->value, "header") == 0){

        // Look for the HEADER to use later
        int index = 0; 
        while(req_header_lst[index] != NULL && index < 0x30){
            if(strcmp(req_header_lst[index]->name, begin_request->query_params[key_index]->value) == 0){
                data_size = req_header_lst[index]->name_len + req_header_lst[index]->value_len + 1; 
                data_pointer = malloc(data_size);
                memcpy(data_pointer, req_header_lst[index]->name, req_header_lst[index]->name_len);
                memcpy(data_pointer + req_header_lst[index]->name_len, ":", 1);
                memcpy(data_pointer + req_header_lst[index]->name_len + 1, req_header_lst[index]->value, req_header_lst[index]->value_len);
                goto valid_data; 
            }
            index += 1;
        }

        // If header being asked for does not exist
        return my_response;
    }
    else if(strcmp(begin_request->query_params[type_index]->value, "query") == 0){

        // Look for the query parameter to use later
        for(int index = 0; index < begin_request->query_amount; index += 1){
            if(strcmp(begin_request->query_params[index]->name, begin_request->query_params[key_index]->value) == 0){
                data_size = strlen(begin_request->query_params[index]->name) + strlen(begin_request->query_params[index]->value) + 2; 
                data_pointer = malloc(data_size);
                strcpy(data_pointer, begin_request->query_params[index]->name);
                strcat(data_pointer, "=");
                strcat(data_pointer, begin_request->query_params[index]->value);
                goto valid_data; 
            }
        }
        // If query parameter being asked for does not exist
        return my_response;
    }

    else if(strcmp(begin_request->query_params[type_index]->value, "body") == 0){
        if(body_request->type == PLAIN){
            data_size = body_request->length + 1; 
            data_pointer = malloc(data_size); 
            memcpy(data_pointer, body_request->data_object, body_request->length + 1);
            goto valid_data; 
        }
        else if(body_request->type != FORM){
            return my_response;
        }

        // Form data request
        struct form_body* body = ((struct form_body*)(body_request->data_object));

        // Look for the parameter to use later
        for(int index = 0; index < body->count; index += 1){
            if(strcmp(body->query_params[index]->name, begin_request->query_params[key_index]->value) == 0){
                data_size = body->query_params[index]->name_len + body->query_params[index]->value_len + 1; // Calculate
                data_pointer = malloc(data_size);
                memcpy(data_pointer, body->query_params[index]->name, body->query_params[index]->name_len);
                *(data_pointer + body->query_params[index]->name_len) = '='; 
                memcpy(data_pointer + body->query_params[index]->name_len + 1, body->query_params[index]->value, body->query_params[index]->value_len); 
                goto valid_data; 
            }
        }

        // Prevents uninitialized memory case for mem_pointer
        return my_response;
    }
    else{
        return my_response;
    }


valid_data: ;

    // Prepare the data to be sent back 
    if(strcmp(begin_request->query_params[loc_index]->value, "header") == 0){
        struct header* header_data = malloc(sizeof(struct header)); // Make header data

        // Divide 'key' and 'value' from the header
        // TODO: Memtok
        char* key_line = strtok(data_pointer, ":"); // UAF by doing this... UGH!
        char* value_line = strtok(NULL, ":");

        // Setup the pointers to use
        header_data->name = key_line; // Dangling pointer with 'strtok'!
        header_data->value = value_line;

        int index = 0; 
        while(res_header_lst[index] != NULL && index < 0x20)
            index += 1;

        if(index == 0x20){ // Check if there are too many response headers
            strcpy(bad_data, "Too many headers");
            return my_response;
        }

        // Set the header
        res_header_lst[index] = header_data;
        strcpy(bad_data, "Echoed In Header");
        free(data_pointer);

        // In the header. So, no BODY!
        my_response->length = 0; 
        my_response->status = 200; 
        return my_response;
    }

    else if(strcmp(begin_request->query_params[loc_index]->value, "body") == 0){
        free(bad_data);
        my_response->data = data_pointer;
        my_response->length = data_size;
        my_response->status = 200; 
        return my_response;
    }
    else{
        free(data_pointer);
        my_response->data = data_pointer;
        my_response->length = data_size;
        my_response->status = 200; 
        return my_response;
    }
}

/*
Route #4 - Authenticated user check. 
Returns: 
- 200 response when authenticated
- 403 when not authenticated
*/
struct server_response* handle_auth(){

    struct server_response* my_response = malloc(sizeof(struct server_response)); 
    char* response_text = malloc(0x50);

    if(is_authenticated == 1){
        strcpy(response_text, "Ready to go! Mr. Admin :)"); 
        my_response->status = 200; 
    }else{
        strcpy(response_text, "Oops... not today!");
        my_response->status = 403; 

    }

    my_response->data = response_text; 
    my_response->length = strlen(my_response->data);

    return my_response;
}

/*
Upload a file using a FORM based POST request

Parameters: 
- location: The file name of the file to upload. 
- data: The content of the file to write. 

Returns: 
- 400 response when file cannot be written
- 200 if the file is written

Example request: 
```
POST /upload HTTP/1.1
Content-Length:32
Content-Type:form

location=/TestFile.txt&data=MyFileContents
```
*/
struct server_response* upload(){

    struct server_response* my_response = malloc(sizeof(struct server_response)); 
    char* bad_data = malloc(0x40);
    strcpy(bad_data, "Bad input parameters");
    my_response->data = bad_data; 
    my_response->length = strlen(my_response->data);
    my_response->status = 400; 

    int location_index = -1; 
    int data_index = -1; 

    // Validate the type
    if(body_request->type != FORM){
        return my_response;
    }

    struct form_body* body = ((struct form_body*)(body_request->data_object));

    // Find the indexes for the data to use later
    for(int index = 0; index < body->count; index +=1){
        if(strcasecmp(body->query_params[index]->name, "location") == 0){
            location_index = index; 
        }

        else if(strcasecmp(body->query_params[index]->name, "data") == 0){
            data_index = index; 
        }
    }

    // Parameters NOT found
    if(location_index == -1 || data_index == -1){
        return my_response;
    }

    // Write the file
    char* path_param = body->query_params[location_index]->value; 
    char* data_param = body->query_params[data_index]->value; 
    size_t file_size = body->query_params[location_index]->value_len; 

    int write_err = write_file(path_param, data_param, file_size);
    if(write_err != 0){
        return my_response;
    }
    strcpy(my_response->data, "File written!");
    return my_response;
}

/*
Create the routes for the program to use. 

Returns: 
- A pointer to an array of routes. 
*/
struct route** create_routes(){
    struct route** my_routes = malloc(sizeof(struct route*) * 0x20);
    memset(my_routes, 0, sizeof(struct route*) * 0x20);

    // The first route
    struct route* route1 = malloc(sizeof(struct route));
    strcpy(route1->verb, "GET");
    route1->route = malloc(0x20);
    strcpy(route1->route, "/CallGet"); 
    route1->handle_callback = &route1_func;
    my_routes[0] = route1;

    // The POST route
    struct route* route2 = malloc(sizeof(struct route));
    strcpy(route2->verb, "POST");
    route2->route = malloc(0x20);
    strcpy(route2->route, "/CallPost"); 
    route2->handle_callback = &route2_func;
    my_routes[1] = route2;

    // The third route - echo some data back
    struct route* route3 = malloc(sizeof(struct route));
    strcpy(route3->verb, "ALL"); // Any request verb will work for this endpoint
    route3->route = malloc(0x20);
    strcpy(route3->route, "/echo"); 
    route3->handle_callback = &echo_service;
    my_routes[2] = route3;   

    // The fourth route - auth!
    struct route* route4 = malloc(sizeof(struct route));
    strcpy(route4->verb, "GET"); // Any request verb will work for this endpoint
    route4->route = malloc(0x20);
    strcpy(route4->route, "/auth"); 
    route4->handle_callback = &handle_auth;
    my_routes[3] = route4; 

    // The fifth route - upload data
    struct route* route5 = malloc(sizeof(struct route));
    strcpy(route5->verb, "POST"); // Any request verb will work for this endpoint
    route5->route = malloc(0x20);
    strcpy(route5->route, "/upload"); 
    route5->handle_callback = &upload;
    my_routes[4] = route5; 
    return my_routes;
}

/*
X-Havoc-Header handler that randomly authenticates the user.

Returns: Pointer to the 'value' of the header.
*/
void* custom_header_1_function(char* key, char* value){
    puts("Custom header function!");

    time_t t;
    srand((unsigned) time(&t));
    is_authenticated = rand() % 2; 
    return value; 
}

/*
Create the custom header handlers to be used. 

Returns: 
- struct custom_header**: A pointer to a list of pointers of 'custom headers'.
*/
struct custom_header** create_custom_headers(){
    struct custom_header** my_custom_headers = malloc(sizeof(struct custom_header*) * 0x10);
    memset(my_custom_headers, 0, sizeof(struct custom_header*) * 0x10);

    // The first custom header
    struct custom_header* custom_header_1 = malloc(sizeof(struct custom_header));
    custom_header_1->name = malloc(0x20);
    strcpy(custom_header_1->name, "X-Havoc-Header"); 
    custom_header_1->custom_callback = &custom_header_1_function;
    my_custom_headers[0] = custom_header_1;
}

// Main!
int main(){

    struct route** my_routes = create_routes();
    struct custom_header** my_custom_headers = create_custom_headers();

    // Setup everything to be hit. 
    int sockfd = initialize_server(my_routes, my_custom_headers);

    // Serve the website
    serve(sockfd);
}