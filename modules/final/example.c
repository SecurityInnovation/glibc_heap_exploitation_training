#include <stdlib.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>

#include "server.h"
#include "utils.h"

char* route1_func(){
    char* bad_data = malloc(0x40);
    strcpy(bad_data, "My Get Route :)");
    return bad_data;
}
char* route2_func(){
    char* bad_data = malloc(0x40);
    strcpy(bad_data, "My Post Route :)");
    return bad_data;
}

/*
Reflects a header, body or query parameter in the header or body

/echo?type=header|body|query&location=header|body&key=key_to_use
*/
char* echo_service(){

    int type_index = -1; 
    int loc_index = -1; 
    int key_index = -1; 
    char* bad_data = malloc(0x40);
    strcpy(bad_data, "Bad input parameters");

    // Find the data points we need for the endpoint
    for(int index = 0; index < begin_request->query_amount; index += 1){
        if(strcmp(begin_request->query_params[index]->name, "type") == 0)
            type_index = index;
        else if(strcmp(begin_request->query_params[index]->name, "location") == 0)
            loc_index = index; 
        else if(strcmp(begin_request->query_params[index]->name, "key") == 0)
            key_index = index; 
    }

    // If one of the parameters was not found
    if(type_index == -1 || loc_index == -1 || key_index == -1){
        return bad_data; 
    }

    char* data_pointer; 
    size_t data_size; 

    // Data to use for the INPUT
    if(strcmp(begin_request->query_params[type_index]->value, "header") == 0){

        // Look for the HEADER to use later
        int index = 0; 
        while(req_header_lst[index] != NULL && index < 0x20){
            if(strcmp(req_header_lst[index]->name, begin_request->query_params[key_index]->value) == 0){
                data_size = req_header_lst[index]->name_len + req_header_lst[index]->value_len + 2; 
                data_pointer = malloc(req_header_lst[index]->name_len + req_header_lst[index]->value_len + 2);
                memcpy(data_pointer, req_header_lst[index]->name, req_header_lst[index]->name_len - 1);
                memcpy(data_pointer + req_header_lst[index]->name_len - 1, ":", 1);
                memcpy(data_pointer + req_header_lst[index]->name_len, req_header_lst[index]->value, req_header_lst[index]->value_len);
                goto valid_data; 
            }
            index += 1;
        }

        // If header being asked for does not exist
        return bad_data;
    }
    else if(strcmp(begin_request->query_params[type_index]->value, "query") == 0){

        // Look for the query parameter to use later
        for(int index = 0; index < begin_request->query_amount; index += 1){
            if(strcmp(begin_request->query_params[index]->name, begin_request->query_params[key_index]->value) == 0){
                data_size = strlen(begin_request->query_params[index]->name) + strlen(begin_request->query_params[index]->value) + 2; 
                data_pointer = malloc(data_size);
                strcpy(data_pointer, begin_request->query_params[index]->name);
                strcat(data_pointer, "=");
                strcat(data_pointer, begin_request->query_params[index]->value);
                goto valid_data; 
            }
        }
        // If query parameter being asked for does not exist
        return bad_data;
    }

    else if(strcmp(begin_request->query_params[type_index]->value, "body") == 0){
        if(body_request->type == PLAIN){
            data_size = body_request->length + 1; 
            data_pointer = malloc(data_size); 
            memcpy(data_pointer, body_request->data_object, body_request->length + 1);
            goto valid_data; 
        }
        else if(body_request->type != FORM){
            return bad_data;
        }

        // Form data request
        struct form_body* body = ((struct form_body*)(body_request->data_object));

        // Look for the parameter to use later
        for(int index = 0; index < body->count; index += 1){
            if(strcmp(body->query_params[index]->name, begin_request->query_params[key_index]->value) == 0){
                data_size = body->query_params[index]->name_len + body->query_params[index]->value_len + 1; // Calculate
                data_pointer = malloc(data_size);
                memcpy(data_pointer, body->query_params[index]->name, body->query_params[index]->name_len);
                *(data_pointer + body->query_params[index]->name_len) = '='; 
                memcpy(data_pointer + body->query_params[index]->name_len + 1, body->query_params[index]->value, body->query_params[index]->value_len); 
                goto valid_data; 
            }
        }

        // Prevents uninitialized memory case for mem_pointer
        return bad_data;
    }
    else{
        return bad_data;
    }


valid_data: ;

    // Prepare the data to be sent back 
    if(strcmp(begin_request->query_params[loc_index]->value, "header") == 0){
        struct header* header_data = malloc(sizeof(struct header)); // Make header data

        // Divide 'key' and 'value' from the header
        // TODO: Memtok
        char* key_line = strtok(data_pointer, ":");
        char* value_line = strtok(NULL, ":");

        // Setup the pointers to use
        header_data->name = key_line;
        header_data->value = value_line;

        int index = 0; 
        while(res_header_lst[index] != NULL && index < 0x20)
            index += 1;

            if(index == 0x20){
                strcpy(bad_data, "Too many headers");
            }

            // Set the header
            res_header_lst[index] = header_data;
            strcpy(bad_data, "Echoed In Header");
            free(data_pointer);
            return bad_data;
    }

    else if(strcmp(begin_request->query_params[loc_index]->value, "body") == 0){
        free(bad_data);
        return data_pointer;
    }
    else{
        free(data_pointer);
        return bad_data;
    }
}

// Auth route #4 - authenticated user
char* handle_auth(){
    char* response_text = malloc(0x50);

    if(is_authenticated == 1){
        strcpy(response_text, "Ready to go! Mr. Admin :)"); 
    }else{
        strcpy(response_text, "Oops... not today!"); 
    }
    return response_text;
}

char* upload(){
    int location_index = -1; 
    int data_index = -1; 
    int iterator = 0; 

    char* bad_data = malloc(0x40);
    strcpy(bad_data, "Bad input parameters");

    // Validate the type
    if(body_request->type != FORM){
        return bad_data;
    }

    struct form_body* body = ((struct form_body*)(body_request->data_object));

    // Find the indexes for the data to use later
    for(int index = 0; index < body->count; index +=1){
        if(strcasecmp(body->query_params[index]->name, "location") == 0){
            location_index = index; 
        }

        else if(strcasecmp(body->query_params[index]->name, "data") == 0){
            data_index = index; 
        }
    }

    // Parameters NOT found
    if(location_index == -1 || data_index == -1){
        return bad_data;
    }

    // Write the file
    char* path_param = body->query_params[location_index]->value; 
    char* data_param = body->query_params[data_index]->value; 
    size_t file_size = body->query_params[location_index]->value_len; 

    int write_err = write_file(path_param, data_param, file_size);
    if(write_err != 0){
        return bad_data;
    }
    strcpy(bad_data, "File written!");
    return bad_data;
}


struct route** create_routes(){
    struct route** my_routes = malloc(sizeof(struct route*) * 0x20);
    memset(my_routes, 0, sizeof(struct route*) * 0x20);

    // The first route
    struct route* route1 = malloc(sizeof(struct route));
    strcpy(route1->verb, "GET");
    route1->route = malloc(0x20);
    strcpy(route1->route, "/CallGet"); 
    route1->handle_callback = &route1_func;
    my_routes[0] = route1;

    // The POST route
    struct route* route2 = malloc(sizeof(struct route));
    strcpy(route2->verb, "POST");
    route2->route = malloc(0x20);
    strcpy(route2->route, "/CallPost"); 
    route2->handle_callback = &route2_func;
    my_routes[1] = route2;

    // The third route - echo some data back
    struct route* route3 = malloc(sizeof(struct route));
    strcpy(route3->verb, "ALL"); // Any request verb will work for this endpoint
    route3->route = malloc(0x20);
    strcpy(route3->route, "/echo"); 
    route3->handle_callback = &echo_service;
    my_routes[2] = route3;   

    // The fourth route - auth!
    struct route* route4 = malloc(sizeof(struct route));
    strcpy(route4->verb, "GET"); // Any request verb will work for this endpoint
    route4->route = malloc(0x20);
    strcpy(route4->route, "/auth"); 
    route4->handle_callback = &handle_auth;
    my_routes[3] = route4; 

    // The fifth route - upload data
    struct route* route5 = malloc(sizeof(struct route));
    strcpy(route5->verb, "POST"); // Any request verb will work for this endpoint
    route5->route = malloc(0x20);
    strcpy(route5->route, "/upload"); 
    route5->handle_callback = &upload;
    my_routes[4] = route5; 
    return my_routes;
}

int main(){

    // Setup everything
    int sockfd = initialize_server(create_routes());

    // Serve the website
    serve(sockfd);
}