#include <stdlib.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "utils.h"

/*
Convert URL encoded payload into un-URL encoded payload.
Takes in a string and returns a string.

SecDo: Sudo edit bug here?
*/
char* url_decode(char* string){

    // New string index
    uint new_str_index = 0;
    short size = 0x40; 

    char* decoded_string = malloc(size);

    for(int old_str_index = 0; old_str_index < strlen(string); old_str_index++){
        if(string[old_str_index] == '%'){
            char* tmp_string = malloc(0x10);
            memcpy(tmp_string, &string[old_str_index+1], 2); // TODO: Fix 2 byte OOB here
            int data = strtol(tmp_string, NULL, 16);
            printf("Data: 0x%x\n", data);

            decoded_string[new_str_index++] = (char) data;
            old_str_index += 2; // Get passed BOTH character after the '%'
        }else{ // If not URL decoding is needed
            decoded_string[new_str_index++] = string[old_str_index];
        }

        // If our current buffer comes too small, resize it
        if(new_str_index == size - 2){
            // Increase size, copy over data then try again :) 
            size = size * 2;
            char* tmp_pointer = malloc(size); 
            memset(tmp_pointer, 0, size); // Initializing the data to NULL
            memcpy(tmp_pointer, decoded_string, size/2); // SecDo: Bad memcpy for out of bounds read. Super crashy though...
            free(decoded_string); 
            decoded_string = tmp_pointer;
        }
    }
    return decoded_string;
}

/*
Read data until a '\r\n' is found.
*/
char* read_wrapper(int sockfd){

    // Initialize the data to be read in.
    short size = 0x10;
    char* line = malloc(size);
    memset(line, 0, size); // Initializing the data to NULL
    int cont = 1; 

    // Amount of bytes received in the loop
    int counter = 0; 

    // Read in a BYTE at a time
    while(cont == 1){
        int read_result = read(sockfd, line + counter, 1);
        if(read_result < 0){
            perror("Read failure: ");
            //puts("read failure");
            exit(EXIT_FAILURE);
        }

        // Found the carriage return, new line
        if(strstr(line, "\r\n") != NULL){
            line[counter+1] = '\0';
            printf("Read In:%s\n",line);
            return line;
        }

        // Enlarge the buffer being used to receive -- TODO: Add bug here :) 
        if(counter == size - 2){
            // Increase size, copy over data then try again :) 
            size = size * 2; // Begging for an overflow :) Is this exploitable though?
            char* tmp_pointer = malloc(size); 
            memset(tmp_pointer, 0, size); // Initializing the data to NULL
            memcpy(tmp_pointer, line, size/2); // SecDo: Bad memcpy for out of bounds read. Super crashy though...
            free(line); 
            line = tmp_pointer;
        }
        counter += 1; // Increase byte to read
    }
}

/*
Read the contents of a file.
*/
char* read_file(char* my_file){
    struct stat st;

    // Create path for the file read operation
    char* file_path = malloc(PATH_MAX + 1);
    memset(file_path, 0, 4096);
    getcwd(file_path, 4096);

    strcat(file_path, my_file); // TODO: Fix buffer overflow HERE

    // TODO: Validate the PATH to prevent directory traversal

    // Create buffer for file to be read in.
    stat(file_path, &st);
    uint file_size = st.st_size;  
    char* file_buffer = malloc(file_size + 1);
    memset(file_buffer, 0, file_size + 1);

    int file_fd = open(file_path, O_RDONLY);
    if(file_fd < 0){
        printf("Failed to open file: %d", file_fd);
        free(file_buffer);
        return NULL;
    }

    uint read_size = read(file_fd, file_buffer, file_size);
    if(read_size < 0){
        free(file_buffer);
        return NULL;
    }

    return file_buffer;
}

// https://stackoverflow.com/questions/744766/how-to-compare-ends-of-strings-in-c
int str_ends_with(const char *str, const char *suffix)
{
    if (!str || !suffix)
        return 1;
    size_t lenstr = strlen(str);
    size_t lensuffix = strlen(suffix);
    if (lensuffix >  lenstr)
        return 1;
    return strncmp(str + lenstr - lensuffix, suffix, lensuffix);
}

int str_starts_with(const char *str, const char *pre)
{
    return strncmp(pre, str, strlen(pre)) == 0;
}

/*
Add strings together. 
Does not support nullbytes. 
*/
char* add_string(char* cur_string, short* full_size, char* new_string){
    // Check to see if our string can fit 

    char* tmp_string = cur_string; 

    uint cur_str_size = strlen(cur_string);
    uint new_str_size = strlen(new_string);
    uint bytes_left = *full_size - cur_str_size;

    // Validate that the size fits the string. If not, make a new string
    if(bytes_left <= new_str_size){
        *full_size = (*full_size + new_str_size) * 2;  // SecDo: Overflowable
        tmp_string = malloc(*full_size);
        strcpy(tmp_string, cur_string); // Safe to use since the size is guarenteed to be correct
    }

    // Concatenate the text
    strncat(tmp_string, new_string, *full_size);

    return tmp_string; 
}



