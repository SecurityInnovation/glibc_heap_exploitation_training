#include <stdlib.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "utils.h"

/*
Convert URL encoded payload into un-URL encoded payload.
Takes in a string and returns a string.

SecDo: Sudo edit bug here? - COULD be done by checking for a NULLbyte instead of tracking the size?
- https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt
*/
char* url_decode(char* string, size_t *size){

    char tmp_string[0x20]; // Temporary buffer for random things

    // New string index
    uint new_str_index = 0;
    *size = 0x40; // initial size of the data

    char* decoded_string = malloc(*size);
    memset(decoded_string, 0, *size);
    for(int old_str_index = 0; old_str_index < strlen(string); old_str_index++){
        if(string[old_str_index] == '%'){
            memcpy(tmp_string, &string[old_str_index+1], 2);
            int data = strtol(tmp_string, NULL, 16);

            decoded_string[new_str_index] = (char) data;
            old_str_index += 2; // Get passed BOTH character after the '%'
        }else{ // If not URL decoding is needed
            decoded_string[new_str_index] = string[old_str_index];
        }

        // If our current buffer comes too small, resize it
        if(new_str_index == *size - 2){
            // Increase size, copy over data then try again :) 
            *size = (*size) * 2;
            char* tmp_pointer = malloc(*size); 
            memset(tmp_pointer, 0, *size); // Initializing the data to NULL
            memcpy(tmp_pointer, decoded_string, *size/2); 
            free(decoded_string); 
            decoded_string = tmp_pointer;
        }
        
        new_str_index +=1; 
    }
    return decoded_string;
}

/*
Read until the AMOUNT of data has been read. 
*/
char* read_body_wrapper(int sockfd, size_t amount){
    size_t bytes_written = 0; 
    char* body_string = malloc(amount + 1); // 
    body_string[amount] = '\0'; 

    // Loop until enough bytes have been read
    while(bytes_written < amount){

        // Read in until we get an EOF, 'amount' bytes or a newline.
        int read_result = read(sockfd, body_string + bytes_written, amount - bytes_written);
        if(read_result < 0){
            perror("Read failure: ");
            //puts("read failure");
            exit(EXIT_FAILURE);
        }

        // Change the amount of bytes written
        bytes_written = bytes_written + read_result; 
    }

    return body_string;
}

/*
Read data until a '\r\n' is found. Writes the AMOUNT back to the 'counter' variable.
*/
char* read_wrapper(int sockfd, int *counter){

    // Initialize the data to be read in.
    unsigned int size = 0x10;
    char* line = malloc(size);
    memset(line, 0, size); // Initializing the data to NULL
    int cont = 1; 

    // Read in a BYTE at a time
    while(cont == 1){
        int read_result = read(sockfd, line + *counter, 1);
        if(read_result < 0){
            perror("Read failure: ");
            //puts("read failure");
            exit(EXIT_FAILURE);
        }

        // Found the carriage return, new line
        //if(strstr(line, "\r\n") != NULL){
        if(*counter >= 1 && line[*counter - 1] == '\r' && line[*counter] == '\n'){
            line[*counter+1] = '\0';
            printf("Read In:%s\n",line);
            return line;
        }

        // Enlarge the buffer being used to receive 
        if(*counter == size - 2){
            // Increase size, copy over data then try again :) 
            size = size * 2; // Begging for an overflow :) Is this exploitable though?
            char* tmp_pointer = malloc(size); 
            memset(tmp_pointer, 0, size); // Initializing the data to NULL
            memcpy(tmp_pointer, line, size/2); // SecDo: Bad memcpy for out of bounds read. Super crashy though...
            free(line); 
            line = tmp_pointer;
        }
        *counter += 1; // Increase byte to read
    }
}

/*
Read the contents of a file.
*/
char* read_file(char* my_file){
    struct stat st;

    // Create path for the file read operation
    char* file_path = malloc(PATH_MAX + 1);
    memset(file_path, 0, 4096);
    getcwd(file_path, 4096);

    strncat(file_path, my_file, 4096 - strlen(file_path)); // SecDo: Fix buffer overflow HERE

    // Create buffer for file to be read in.
    stat(file_path, &st);
    uint file_size = st.st_size;  
    char* file_buffer = malloc(file_size + 1);
    memset(file_buffer, 0, file_size + 1);

    int file_fd = open(file_path, O_RDONLY);
    if(file_fd < 0){
        printf("Failed to open file: %d", file_fd);
        free(file_buffer);
        return NULL;
    }
    free(file_path);

    uint read_size = read(file_fd, file_buffer, file_size);
    if(read_size < 0){
        free(file_buffer);
        return NULL;
    }

    return file_buffer;
}

int write_file(char* my_file, char* data, size_t data_size){

    // Create path for the file write operation
    char* file_path = malloc(PATH_MAX + 1);
    memset(file_path, 0, 4096);
    getcwd(file_path, 4096);
    strncat(file_path, my_file, 4096 - strlen(file_path)); // SecDo: Fix buffer overflow HERE

    // Open the file
    int file_fd = open(file_path, O_CREAT|O_RDWR|O_APPEND, S_IRWXU | S_IRWXG);
    free(file_path);

    if(file_fd < 0){
        printf("Failed to open file: %d", file_fd);
        return 1;
    }

    // Write to the file
    int write_size = write(file_fd, data, data_size);
    if(write_size < 0){
        printf("Failed to write to file: %d", file_fd);
        return 1;
    }
    
    int close_err = close(file_fd);
    if(close_err < 0){
        printf("Failed to close the file: %d", file_fd);
        return 1;
    }

    // Succeeded in the file write!
    return 0; 
}

// https://stackoverflow.com/questions/744766/how-to-compare-ends-of-strings-in-c
int str_ends_with(const char *str, const char *suffix)
{
    if (!str || !suffix)
        return 1;
    size_t lenstr = strlen(str);
    size_t lensuffix = strlen(suffix);
    if (lensuffix >  lenstr)
        return 1;
    return strncmp(str + lenstr - lensuffix, suffix, lensuffix);
}

int str_starts_with(const char *str, const char *pre)
{
    return strncmp(pre, str, strlen(pre)) == 0;
}

/*
Add strings together. 
Does not support nullbytes. 
*/
char* add_string(char* cur_string, size_t *cur_str_size, unsigned short* full_size, char* new_string, size_t new_str_size){
    // Check to see if our string can fit 

    char* tmp_string = cur_string; 

    // Calculate the amount of bytes left in the buffer
    int bytes_left = *full_size - *cur_str_size;

    // Validate that the size fits the string. If not, make a new string
    if(bytes_left <= new_str_size){
        *full_size = (*full_size + new_str_size) * 2;  // SecDo: Overflowable
        tmp_string = malloc(*full_size);
        memset(tmp_string, 0, *full_size);
        memcpy(tmp_string, cur_string, *cur_str_size); // Change to a 'memcpy' with OLD size
        free(cur_string);
    }

    // Prevent an overflow - defense-in-depth
    if((int)(*full_size - new_str_size) < 0){
        return tmp_string;
    }

    // Concatenate the text
    memcpy(tmp_string + *cur_str_size, new_string, new_str_size);
    *cur_str_size += new_str_size;

    return tmp_string; 
}


