#include <stdlib.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>

#include "utils.h"

/*
Convert URL encoded payload into un-URL encoded payload.
Takes in a string and returns a string.

SecDo: Sudo edit bug here?
*/
char* url_decode(char* string){

    // New string index
    uint new_str_index = 0;
    short size = 0x40; 

    char* decoded_string = malloc(size);

    for(int old_str_index = 0; old_str_index < strlen(string); old_str_index++){
        if(string[old_str_index] == '%'){
            char* tmp_string = malloc(0x10);
            memcpy(tmp_string, &string[old_str_index+1], 2); // TODO: Fix 2 byte OOB here
            int data = strtol(tmp_string, NULL, 16);
            printf("Data: 0x%x\n", data);

            decoded_string[new_str_index++] = (char) data;
            old_str_index += 2; // Get passed BOTH character after the '%'
        }else{ // If not URL decoding is needed
            decoded_string[new_str_index++] = string[old_str_index];
        }

        // If our current buffer comes too small, resize it
        if(new_str_index == size - 2){
            // Increase size, copy over data then try again :) 
            size = size * 2;
            char* tmp_pointer = malloc(size); 
            memset(tmp_pointer, 0, size); // Initializing the data to NULL
            memcpy(tmp_pointer, decoded_string, size/2); // SecDo: Bad memcpy for out of bounds read. Super crashy though...
            free(decoded_string); 
            decoded_string = tmp_pointer;
        }
    }
    return decoded_string;
}

/*
Read data until a '\r\n' is found.
*/
char* read_wrapper(int sockfd){

    // Initialize the data to be read in.
    short size = 0x10;
    char* line = malloc(size);
    memset(line, 0, size); // Initializing the data to NULL
    int cont = 1; 

    // Amount of bytes received in the loop
    int counter = 0; 

    // Read in a BYTE at a time
    while(cont == 1){
        int read_result = read(sockfd, line + counter, 1);
        if(read_result < 0){
            perror("Read failure: ");
            //puts("read failure");
            exit(EXIT_FAILURE);
        }

        // Found the carriage return, new line
        if(strstr(line, "\r\n") != NULL){
            line[counter+1] = '\0';
            printf("Read In:%s\n",line);
            return line;
        }

        // Enlarge the buffer being used to receive -- TODO: Add bug here :) 
        if(counter == size - 2){
            // Increase size, copy over data then try again :) 
            size = size * 2; // Begging for an overflow :) Is this exploitable though?
            char* tmp_pointer = malloc(size); 
            memset(tmp_pointer, 0, size); // Initializing the data to NULL
            memcpy(tmp_pointer, line, size/2); // SecDo: Bad memcpy for out of bounds read. Super crashy though...
            free(line); 
            line = tmp_pointer;
        }
        counter += 1; // Increase byte to read
    }
}