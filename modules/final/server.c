#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>

#include "server.h" 
#include "utils.h"

/*
Resources
- https://www.geeksforgeeks.org/socket-programming-cc/
*/

/*
Steps for setting up connection: 
- Create socket
- Set socket options
- Bind the socket to an address (localhost) - naming the socket
- Put into a 'listen' mode
- Accept with interactions :) 
*/
int setup_socket(){

    int on = 1; 

    // Create a socket for IPv4 TCP - https://man7.org/linux/man-pages/man2/socket.2.html
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd < 0){
        puts("Socket error - could not create socket");
        exit(EXIT_FAILURE);
    }
    
    // Set socket option to reuse this socket connection
    int set_socket_options_ret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &on, sizeof(on));
    if(set_socket_options_ret < 0){
        puts("Socket error - could set socket options");
        exit(EXIT_FAILURE);
    }

    // Assigning the 'name' to the socket - https://man7.org/linux/man-pages/man2/bind.2.html
    struct sockaddr_in address; // Address information
    address.sin_family = AF_INET;  // IPv4
    address.sin_addr.s_addr = INADDR_ANY; // Accept ALL Ips for the machine.
    address.sin_port = htons(8081); // Port number
    if(bind(sockfd, (struct sockaddr *)&address, sizeof(address)) < 0){
        puts("Socket error - could not bind address to socket");
        exit(EXIT_FAILURE);
    }

    // Set the socket to be a passive listener
    if(listen(sockfd, 100)){
        puts("Socket error - listen failed");
        exit(EXIT_FAILURE);
    }
    return sockfd;
}

void init_memory(){

    // Holders some of the request data - path, query info, verb
    begin_request = (struct request*) malloc(sizeof(struct request));
    body_request =  (struct body*) malloc(sizeof(struct body));
    req_context = (struct context*) malloc(sizeof(struct context));
}

/*
Find the path, query parameters and fragment in the URI
*/
void parse_uri(char* path){
    /*
    Find the query parameter (if it exists) 
    */

    char* ptr = strtok(path, "?");
    char* query_param = strtok(NULL, " ");

    begin_request->path = ptr; // SecDo: Use after free :) 
    begin_request->path_len = strlen(begin_request->path);

    // No query parameters on this request
    if(query_param == NULL){
        return;
    }

    // Initial call 
    ptr = strtok(query_param, "&"); 

    // Finding ALL of the query parameters
    while(ptr != NULL){
         // Create the query parameter data type to store
        struct query* query_data = malloc(sizeof(struct query)); 

        // Copy the parameter to a local copy to play with
        char* local_cpy = malloc(strlen(ptr) + 1);
        strcpy(local_cpy, ptr);

        // Divide 'key' and 'value' with a nullbyte
        char* query_value = strstr(local_cpy, "=");
        if(query_value != NULL && strlen(query_value) > 1){
            query_value[0] = '\0'; // Erase the query string
            query_value += 1; // Increase the pointer passed in
        }

        // URL decode the 'key'
        char* key_decoded = url_decode(local_cpy);
        query_data->name = key_decoded;

        if(query_value != NULL){ // If there is an '=':
            query_data->value = url_decode(query_value); // Decode the value
        }else{ // If NO value after the 'key':
            char* decoded_value = url_decode(local_cpy); // URL decode the key
        }

        free(local_cpy);

        // Maximum amount of query parameters
        if(begin_request->query_amount >= 0x10){
            return;
        }

        // Add query parameters into the 
        begin_request->query_params[begin_request->query_amount] = query_data;
        begin_request->query_amount++; 

        ptr = strtok(NULL, "&");
    }

    return;
}

int parse_single_header(int sockfd, uint* header_count){
    char* one_line = read_wrapper(sockfd); 
    if(strcmp(one_line, "\r\n") == 0){
        return 0;
    }

    struct header* header_data = malloc(sizeof(struct header)); // Make header data

    // Divide 'key' and 'value' from the header
    char* key_line = strtok(one_line, ":");
    char* value_line = strtok(NULL, ":");

    // Initialize and copy data into the 'name' of the header
    header_data->name = malloc(strlen(key_line) + 1); // Create the 'header data' pointer
    strncpy(header_data->name, key_line, strlen(key_line) + 1); // Add in the 'key'

    if(value_line != NULL){ // If there is an '=':
        header_data->value = malloc(strlen(value_line) + 1); // Create the 'header data' pointer
        strncpy(header_data->value, value_line, strlen(value_line)); // Add in the 'value'
        header_data->value[strlen(value_line) - 2] = '\0'; // Remove carriage return and newline
    }else{ // If NO value after the 'key':
        header_data->value = malloc(strlen(key_line) + 1); // Default pointer to 'key' size
        header_data->name[strlen(header_data->name) - 2] = '\0'; // Remove carriage return and newline
    }

    // Save the header information
    req_header_lst[*header_count] = header_data; 
    *header_count += 1;

    //printf("Key: %s, Value: %s\n", header_data->name, header_data->value);
    free(one_line);
    return 1;
}

int parse_headers(int sockfd){
    uint header_count = 0;
    int ret_value = 1;

    // Iterate until BODY or twenty headers
    while(header_count < 0x20 && ret_value == 1){
        ret_value = parse_single_header(sockfd, &header_count);
    }
}

// Under the headers and alter the stuff accordingly
int interpret_header(uint index){
    printf("%s\n", req_header_lst[index]->name);

    // Rewrite the PATH of the request
    if(strcasecmp(req_header_lst[index]->name, "X-Forwarded-Path") == 0){
        strncpy(begin_request->path, req_header_lst[index]->value, begin_request->path_len);
    }

    // Length of the BODY of the request
    else if(strcasecmp(req_header_lst[index]->name, "Content-Length") == 0){
        int length = atoi(req_header_lst[index]->value); // Get length of header
        body_request->length = length; 
    }

    // TYPE of request being used
    else if(strcasecmp(req_header_lst[index]->name, "Content-Type") == 0){
        if(strcasestr(req_header_lst[index]->value, "plain")){
            body_request->type = PLAIN; 
        }
        else if(strcasestr(req_header_lst[index]->value, "form")){
            body_request->type = FORM; 
        }else{
            body_request->type = NONE; 
        }
    }
    // Authorization header parsing
    else if(strcasecmp(req_header_lst[index]->name, "Authorization") == 0){
        int length = atoi(req_header_lst[index]->value); // Get length of header
        body_request->length = length; 
        // TODO: Hook -- deal with the auth
        // Or, handle base64 encode/decode myself :) 
    }
    // Parse the cookies in the request
    else if(strcasecmp(req_header_lst[index]->name, "Cookies") == 0){
        // TODO - if at all...
    }

    // Parse the user agent in the request
    else if(strcasecmp(req_header_lst[index]->name, "User-Agent") == 0){
        req_context->user_agent = malloc(strlen(req_header_lst[index]->value) + 1);
        strcpy(req_context->user_agent, req_header_lst[index]->value);
        printf("User Agent String: %s\n", req_context->user_agent);
    }
    // Parse the Host in the request
    else if(strcasecmp(req_header_lst[index]->name, "Host") == 0){
        req_context->host = malloc(strlen(req_header_lst[index]->value) + 1);
        strcpy(req_context->host, req_header_lst[index]->value);
    }
    // Parse the Origin in the request
    else if(strcasecmp(req_header_lst[index]->name, "Origin") == 0){
        req_context->origin = malloc(strlen(req_header_lst[index]->value) + 1);
        strcpy(req_context->origin, req_header_lst[index]->value);
    }
}

/*
After receiving all of the headers, parse them.
*/
int interpret_headers(){
    uint counter = 0;
    while(req_header_lst[counter] != 0 && counter < 0x20){
        interpret_header(counter);
        counter +=1;
    }
}

int parse_body(int sockfd){
    // Safe requests have NO body.
    if(strcasecmp(begin_request->verb, "GET") == 0 || strcasecmp(begin_request->verb, "HEAD") == 0){
        return 0;
    }

    // Receive data for the BODY of the request
    char* body_buffer = malloc(body_request->length + 1);
    int recv_stat = recv(sockfd, body_buffer, body_request->length, 0); 
    body_buffer[body_request->length] = '\0';
    if(recv_stat < 0){
        puts("Bad recieve");
        exit(EXIT_FAILURE);
    }

    // Parse the different types of requests
    if(body_request->type == PLAIN){ // Easy to do. Make a buffer then go!
        body_request->data_object = malloc(body_request->length + 1);
        memcpy(body_request->data_object, body_buffer, body_request->length);
    }
    else if(body_request->type == FORM){

        // Creating the form body pointer to be used
        struct form_body* form_body_ptr = malloc(sizeof(struct form_body));
        memset(form_body_ptr, 0, sizeof(struct form_body)); // Initialize the data
        body_request->data_object = form_body_ptr; 

        // Find the end of the first key:value pair
        char* ptr = strtok(body_buffer, "&"); 
        
        // Finding ALL of the query parameters
        while(ptr != NULL){

            // Create the query parameter data type to store
            struct query* query_data = malloc(sizeof(struct query)); 

            // Copy the parameter to a local copy to play with
            char* local_cpy = malloc(strlen(ptr) + 1);
            strcpy(local_cpy, ptr);

            // Divide 'key' and 'value' with a nullbyte
            char* query_value = strstr(local_cpy, "=");
            if(query_value != NULL && strlen(query_value) > 1){
                query_value[0] = '\0'; // Erase the query string
                query_value += 1; // Increase the pointer passed in
            }

            // URL decode the 'key'
            char* key_decoded = url_decode(local_cpy);
            query_data->name = key_decoded;

            if(query_value != NULL){ // If there is an '=':
                query_data->value = url_decode(query_value); // Decode the value
            }else{ // If NO value after the 'key':
                char* decoded_value = url_decode(local_cpy); // URL decode the key
            }

            free(local_cpy);

            // Store the data to be used later
            form_body_ptr->query_params[form_body_ptr->count] = query_data;
            form_body_ptr->count++;
            if(form_body_ptr->count >= 0x10){ // Entries are full
                return 0;
            }

            // Find the next parameter. Returns NULL if the at the end.
            ptr = strtok(NULL, "&"); 
        }

    }else {
        body_request->type = NONE;
    }
}

/*
If the path is static (HTML, CSS, etc.), then send this back. 
*/
void serve_file(){

    // Read in the file
    char* data = read_file(begin_request->path); 

    // File couldn't be read or does not exist
    if(data == NULL){
        whole_response->status = 404;  // Status code

        // Callback for custom 404/default page page
        if(whole_response->default_callback != NULL){
            whole_response->response_text = (*whole_response->default_callback)();
            goto setup_type;  
        }

        // Copy the text for the response
        int res_len = snprintf(NULL, 0, "Route %s does not exist\n", begin_request->path);
        whole_response->response_text = malloc(res_len + 1);
        snprintf(whole_response->response_text, res_len, "Route %s does not exist\n", begin_request->path);
        free(data);

    }else{
        whole_response->status = 200;  // Status code
        whole_response->response_text = data; 
    }

setup_type: ;

    // Find an empty header slot
    int index = 0;
    while(res_header_lst[index] != NULL && index < 0x20)
        index += 1; 
    // TODO: Fix over usage HERE

    res_header_lst[index] = malloc(sizeof(struct header));
    res_header_lst[index]->name = malloc(strlen("Content-Type") + 1);
    res_header_lst[index]->value = malloc(0x80); // Seems large enough

    strcpy(res_header_lst[index]->name, "Content-Type");

    // Setup the Content-Type for the response
    if(str_ends_with(begin_request->path, ".html")  == 0)
        strcpy(res_header_lst[index]->value, "text/html");
    else if(str_ends_with(begin_request->path, ".js") == 0)
        strcpy(res_header_lst[index]->value, "text/javascript");  
    else if(str_ends_with(begin_request->path, ".json") == 0)
        strcpy(res_header_lst[index]->value, "application/json");  
    else // Default
        strcpy(res_header_lst[index]->value, "text/plain");      
}

int initialize_server(struct route** my_routes){
    init_memory(); 

    int sockfd = setup_socket();

    routes = my_routes; 
    return sockfd;
}

/*
Sending the response back to the user
*/
void send_response(int sockfd){

    char status_buf[0x20]; 

    // Create the buffer and NULL it out
    short size = 0x100; 
    char* full_response = malloc(size); 
    memset(full_response, 0, size);

    // Add the protocol to the first line
    full_response = add_string(full_response, &size, begin_request->protocol_no);
    full_response = add_string(full_response, &size, " "); // Add the SPACE between the two

    snprintf(status_buf, 0x20, "%d", whole_response->status); // Convert int to string
    full_response = add_string(full_response, &size, status_buf); // Add the SPACE between the two
    full_response = add_string(full_response, &size, "\r\n"); // Add the newline carriage return to end the line

    // While loop to add ALL of the response headers
    unsigned short index = 0; 
    while(res_header_lst[index] != NULL){
        full_response = add_string(full_response, &size, res_header_lst[index]->name); // Key of the header
        full_response = add_string(full_response, &size, ":"); // Add the newline carriage return to end the line
        full_response = add_string(full_response, &size, res_header_lst[index]->value); // Add the newline carriage return to end the line
        full_response = add_string(full_response, &size, "\r\n"); // Add the newline carriage return to end the line
        index += 1; 
    }

    // Add the Content-Length MANUALLY, based upon the BODY of the request length
    full_response = add_string(full_response, &size, "Content-Length:"); 
    snprintf(status_buf, 0x20, "%ld", strlen(whole_response->response_text)); // Convert int to string
    full_response = add_string(full_response, &size, status_buf); // Add the SPACE between the two
    full_response = add_string(full_response, &size, "\r\n\r\n"); // Add the newline carriage return to end the line

    // Add the BODY of the response
    full_response = add_string(full_response, &size, whole_response->response_text); 

    printf("Full Response: %s\n\n", full_response);

    send(sockfd, full_response, strlen(full_response), 0 );
    printf("Hello message sent\n");
}

void serve_api(){
    int index = 0;

    // API handling
    while(routes[index] != NULL ){
        if(strcmp(begin_request->path, routes[index]->route) == 0 && (strcmp(routes[index]->verb, begin_request->verb) == 0) || (strcmp(routes[index]->verb, "ALL") == 0)){

            // Call the routes handler and set the data to send
            whole_response->response_text = (*routes[index]->handle_callback)();
            if(whole_response->status == 0){
                whole_response->status = 200;
            }
            break; 
        }
        index += 1; 
    }

    // If NOTHING is hit - 404
    if(whole_response->status == 0){
        int res_len = snprintf(NULL, 0, "Route %s does not exist\n", begin_request->path);
        whole_response->response_text = malloc(res_len + 1);
        snprintf(whole_response->response_text, res_len, "Route %s does not exist\n", begin_request->path);           
    }
}

int serve(int sockfd){

    // Place to fork at :) 
    // Setting up socket information
    struct sockaddr_in address; // Address information
    address.sin_family = AF_INET;  // IPv4
    address.sin_addr.s_addr = INADDR_ANY; // Accept ALL Ips for the machine.
    address.sin_port = htons(8081); // Port number

    // Accept an incoming connection
    int addrlen = sizeof(address);
    int new_socket_fd = accept(sockfd, (struct sockaddr *)&address, &addrlen);
    if (new_socket_fd < 0)
    {
        puts("socket: accept failure");
        exit(EXIT_FAILURE);
    }

    // Read in the first line of the request
    char* first_line = read_wrapper(new_socket_fd); 
    
    // Reuse the 'first_line' variable to find all of the necessary information
    char* verb = strtok(first_line, " ");
    char* path = strtok(NULL, " ");
    char* protocol = strtok(NULL, " ");

    if(path == NULL || protocol == NULL){
        printf("protocol: Invalid first line");
        exit(EXIT_FAILURE);
    }

    protocol[strlen(protocol) - 2] = '\0'; // Remove the carriage return

    // Improper protocol  
    if(strcmp(protocol, "HTTP/1.1") != 0 ){
        printf("protocol: %s\n is not valid", protocol); 
        free(first_line);
        exit(EXIT_FAILURE);
        // SecDo: Exit or FAKE exit or ASSERT
    }

    parse_uri(path);

    // Move the verb into this struct
    strncpy(begin_request->verb, verb, 0x20); // SecDo: Overflow here...
    strncpy(begin_request->protocol_no, protocol, 0x20); // Copying over the protocol information

    // Done with the first line parsing
    //free(first_line); // Vulnerability - this has a reference somewhere else in the 'path'.

    // Get and intrepret the headers sent
    parse_headers(new_socket_fd); 
    interpret_headers();

    // Get the BODY of the request, depending on the Content-Type header
    parse_body(new_socket_fd);

    whole_response = malloc(sizeof(struct response));
    memset(whole_response, 0, sizeof(struct response));

    // Static files
    if(str_starts_with(begin_request->path, "/files/") == 1){
        serve_file();
    
    // Check to see if an API was hit.
    }else{
        serve_api();
    }

    // Return the response 
    send_response(new_socket_fd); 

}