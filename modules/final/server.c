#include <stdlib.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include "server.h" 
#include "utils.h"

/*
Resources
- https://www.geeksforgeeks.org/socket-programming-cc/
*/

/*
Steps for setting up connection: 
- Create socket
- Set socket options
- Bind the socket to an address (localhost) - naming the socket
- Put into a 'listen' mode
- Accept with interactions :) 
*/
int setup_socket(){

    // Create a socket for IPv4 TCP - https://man7.org/linux/man-pages/man2/socket.2.html
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd < 0){
        puts("Socket error - could not create socket");
        exit(EXIT_FAILURE);
    }
    
    // Set socket option to reuse this socket connection
    int set_socket_options_ret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &on, sizeof(on));
    if(set_socket_options_ret < 0){
        puts("Socket error - could set socket options");
        exit(EXIT_FAILURE);
    }

    // Assigning the 'name' to the socket - https://man7.org/linux/man-pages/man2/bind.2.html
    struct sockaddr_in address; // Address information
    address.sin_family = AF_INET;  // IPv4
    address.sin_addr.s_addr = INADDR_ANY; // Accept ALL Ips for the machine.
    address.sin_port = htons(8081); // Port number
    if(bind(sockfd, (struct sockaddr *)&address, sizeof(address)) < 0){
        puts("Socket error - could not bind address to socket");
        exit(EXIT_FAILURE);
    }

    // Set the socket to be a passive listener
    if(listen(sockfd, 100)){
        puts("Socket error - listen failed");
        exit(EXIT_FAILURE);
    }
    return sockfd;
}

void init_memory(){

    // Holders some of the request data - path, query info, verb
    begin_request = (struct request*) malloc(sizeof(struct request));
    body_request =  (struct body*) malloc(sizeof(struct body));
}

/*
Find the path, query parameters and fragment in the URI
*/
void parse_uri(char* path){
    /*
    Find the query parameter (if it exists) 
    */

    char* ptr = strtok(path, "?");
    char* query_param = strtok(NULL, " ");

    begin_request->path = ptr; // SecDo: Use after free :) 
    begin_request->path_len = strlen(begin_request->path);

    // No query parameters on this request
    if(query_param == NULL){
        return;
    }

    // Initial call 
    ptr = strtok(query_param, "&"); 

    // Finding ALL of the query parameters
    while(ptr != NULL){

        // Add parameters somewhere...
        printf("Params: %s\n", ptr);

        // Create the query parameter data type to store
        struct query* query_data = malloc(sizeof(struct query)); 

        // Divide 'key' and 'value'
        char* query_value = strstr(ptr, "=");

        // TODO: Add bounds checks?
        if(query_value != NULL){ // If there is an '=':
            int offset = query_value - ptr; // Difference from beginning of string to value
            strncpy(query_data->name, ptr, (offset < 0x20) ? offset : 0x20); 
            strncpy(query_data->value, query_value + 1, 0x20); // Add in the 'value'
        }else{ // If NO value after the 'key':
            strncpy(query_data->name, ptr, 0x20); // Set the 'key'
        }

        // Maximum amount of query parameters
        if(begin_request->query_amount >= 0x10){
            return;
        }

        begin_request->query_params[begin_request->query_amount] = query_data;
        begin_request->query_amount++; 

        ptr = strtok(NULL, "&");
    }
}

int parse_single_header(int sockfd, uint* header_count){
    char* one_line = read_wrapper(sockfd); 
    if(strcmp(one_line, "\r\n") == 0){
        return 0;
    }

    struct header* header_data = malloc(sizeof(struct header)); // Make header data

    // Divide 'key' and 'value' from the header
    char* key_line = strtok(one_line, ":");
    char* value_line = strtok(NULL, ":");

    // Initialize and copy data into the 'name' of the header
    header_data->name = malloc(strlen(key_line) + 1); // Create the 'header data' pointer
    strncpy(header_data->name, key_line, strlen(key_line) + 1); // Add in the 'key'

    if(value_line != NULL){ // If there is an '=':
        header_data->value = malloc(strlen(value_line) + 1); // Create the 'header data' pointer
        strncpy(header_data->value, value_line, strlen(value_line)); // Add in the 'value'
        header_data->value[strlen(value_line)] = '\0'; // Remove carriage return and newline
    }else{ // If NO value after the 'key':
        header_data->value = malloc(strlen(key_line) + 1); // Default pointer to 'key' size
        header_data->name[strlen(header_data->name)] = '\0'; // Remove carriage return and newline
    }

    // Save the header information
    header_lst[*header_count] = header_data; 
    *header_count += 1;

    //printf("Key: %s, Value: %s\n", header_data->name, header_data->value);
    free(one_line);
    return 1;
}

int parse_headers(int sockfd){
    uint header_count = 0;
    int ret_value = 1;

    // Iterate until BODY or twenty headers
    while(header_count < 0x20 && ret_value == 1){
        ret_value = parse_single_header(sockfd, &header_count);
    }
}

/*
List of headers we can parse: 
- Host
*/
int interpret_header(uint index){
    printf("%s\n", header_lst[index]->name);

    // Rewrite the PATH of the request
    if(strcasecmp(header_lst[index]->name, "X-Forwarded-Path") == 0){
        strncpy(begin_request->path, header_lst[index]->value, begin_request->path_len);
    }

    else if(strcasecmp(header_lst[index]->name, "X-Forwarded-Host") == 0){
        // ??
    }

    // Length of the BODY of the request
    else if(strcasecmp(header_lst[index]->name, "Content-Length") == 0){
        int length = atoi(header_lst[index]->value); // Get length of header
        body_request->length = length; 
    }

    // TYPE of request being used
    else if(strcasecmp(header_lst[index]->name, "Content-Type") == 0){
        if(strcasestr(header_lst[index]->value, "plain")){
            body_request->type = PLAIN; 
        }
        else if(strcasestr(header_lst[index]->value, "form")){
            body_request->type = FORM; 
        }else{
            body_request->type = NONE; 
        }
    }
}

/*
After receiving all of the headers, parse them.
*/
int interpret_headers(){
    uint counter = 0;
    header_lst[0];
    while(header_lst[counter] != 0){
        interpret_header(counter);
        counter +=1;
    }
}

int parse_body(int sockfd){
    // Safe requests have NO body.
    if(strcasecmp(begin_request->verb, "GET") == 0 || strcasecmp(begin_request->verb, "HEAD") == 0){
        return 0;
    }

    // Receive data for the BODY of the request
    char* body_buffer = malloc(body_request->length + 1);
    int recv_stat = recv(sockfd, body_buffer, body_request->length, 0); 
    body_buffer[body_request->length] = '\0';
    if(recv_stat < 0){
        puts("Bad recieve");
        exit(EXIT_FAILURE);
    }

    // Parse the different types of requests
    if(body_request->type == PLAIN){ // Easy to do. Make a buffer then go!
        body_request->data_object = malloc(body_request->length + 1);
        memcpy(body_request->data_object, body_buffer, body_request->length);
    }
    else if(body_request->type == FORM){

        // Creating the form body pointer to be used
        struct form_body* form_body_ptr = malloc(sizeof(struct form_body));
        memset(form_body_ptr, 0, sizeof(struct form_body)); // Initialize the data
        body_request->data_object = form_body_ptr; 

        // Find the end of the first key:value pair
        char* ptr = strtok(body_buffer, "&"); 
        
        // Finding ALL of the query parameters
        while(ptr != NULL){

            // Create the query parameter data type to store
            struct query* query_data = malloc(sizeof(struct query)); 

            // Divide 'key' and 'value'
            char* query_value = strstr(ptr, "=");

            // TODO: URL Decode the data prior to copying
            // Parse for the key and value pairs
            if(query_value != NULL){ // If there is an '=':
                int offset = query_value - ptr; // Difference from beginning of string to value
                strncpy(query_data->name, ptr, (offset < 0x20) ? offset : 0x20); 
                strncpy(query_data->value, query_value + 1, 0x20); // Add in the 'value'
            }else{ // If NO value after the 'key':
                strncpy(query_data->name, ptr, 0x20); // Set the 'key'
            }

            // Store the data to be used later
            form_body_ptr->query_params[form_body_ptr->count] = query_data;
            form_body_ptr->count++;
            if(form_body_ptr->count >= 0x10){ // Entries are full
                return 0;
            }

            // Find the next parameter. Returns NULL if the at the end.
            ptr = strtok(NULL, "&"); // TODO: Fix ASAN bug here...
        }

    }else {
        // Set to NULL?
        // BODY not necessary? // SECDO - use after free
    }
}

int main(){
    init_memory();
    char buf[1024]; 

    // Setting up socket information
    struct sockaddr_in address; // Address information
    address.sin_family = AF_INET;  // IPv4
    address.sin_addr.s_addr = INADDR_ANY; // Accept ALL Ips for the machine.
    address.sin_port = htons(8081); // Port number
    int sockfd = setup_socket();

    // Accept an incoming connection
    int addrlen = sizeof(address);
    int new_socket_fd = accept(sockfd, (struct sockaddr *)&address, &addrlen);
    if (new_socket_fd < 0)
    {
        puts("socket: accept failure");
        exit(EXIT_FAILURE);
    }

    // Read in the first line of the request
    char* first_line = read_wrapper(new_socket_fd); 
    
    // Reuse the 'first_line' variable to find all of the necessary information
    char* verb = strtok(first_line, " ");
    char* path = strtok(NULL, " ");
    char* protocol = strtok(NULL, " ");

    if(path == NULL || protocol == NULL){
        printf("protocol: Invalid first line");
        exit(EXIT_FAILURE);
    }

    protocol[strlen(protocol) - 2] = '\0'; // Remove the carriage return
    // Improper protocol  
    if(strcmp(protocol, "HTTP/1.1") != 0 ){
        printf("protocol: %s\n is not valid", protocol); 
        free(first_line);
        exit(EXIT_FAILURE);
        // SecDo: Exit or FAKE exit or ASSERT
    }

    parse_uri(path);

    // Move the verb into this struct
    strncpy(begin_request->verb, verb, 0x20); // SecDo: Overflow here...

    // Done with the first line parsing
    free(first_line); // Vulnerability - this has a reference somewhere else in the 'path'.

    // Get and intrepret the headers sent
    parse_headers(new_socket_fd); 
    interpret_headers();

    // Get the BODY of the request, depending on the Content-Type header
    parse_body(new_socket_fd);

    // clean up duplicate headers.

    /* 
    If route registered, use that. 'ECHO server'
    Otherwise, will server HTML files. 
    */

    send(new_socket_fd , header_lst[1]->value, strlen(header_lst[1]->value), 0 );
    printf("Hello message sent\n");

}