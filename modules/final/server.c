#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/wait.h>

#include "server.h" 
#include "utils.h"

/*
Function declariations
*/
int serve_wrapper(int sockfd); 
void cleanup_response();
void server_main(int sockfd);

// Clean up zoombie processes
void sigchld_handler(int s)
{
    // waitpid() might overwrite errno, so we save and restore it:
    int saved_errno = errno;

    while(waitpid(-1, NULL, WNOHANG) > 0);

    errno = saved_errno;
}

/*
Sets up the socket. 

Returns: 
- A file descriptor for the socket. 
*/
int setup_socket(){
    struct sigaction sa; 
    int on = 1; 

    // Create a socket for IPv4 TCP - https://man7.org/linux/man-pages/man2/socket.2.html
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd < 0){
        puts("Socket error - could not create socket");
        exit(EXIT_FAILURE);
    }
    
    // Set socket option to reuse this socket connection
    // SO_REUSEADDR
    int set_socket_options_ret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
    if(set_socket_options_ret < 0){
        perror("setsockopt");
        puts("Socket error - could set socket options");
        exit(EXIT_FAILURE);
    }

    // Assigning the 'name' to the socket - https://man7.org/linux/man-pages/man2/bind.2.html
    struct sockaddr_in address; // Address information
    address.sin_family = AF_INET;  // IPv4
    address.sin_addr.s_addr = INADDR_ANY; // Accept ALL Ips for the machine.
    address.sin_port = htons(8081); // Port number
    if(bind(sockfd, (struct sockaddr *)&address, sizeof(address)) < 0){
        perror("setsockopt");
        puts("Socket error - could not bind address to socket");
        puts("Please kill OTHER program prior to runs this again :)");
        exit(EXIT_FAILURE);
    }

    // Set the socket to be a passive listener
    if(listen(sockfd, 100)){
        puts("Socket error - listen failed");
        exit(EXIT_FAILURE);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    return sockfd;
}

/*
Initializes the global memory of the program.
*/
void init_memory(){
    setvbuf(stdout, NULL, _IONBF, 0);
    
    // Holders some of the request data - path, query info, verb
    begin_request = (struct request*) malloc(sizeof(struct request));
    memset(begin_request, 0, sizeof(struct request));

    body_request =  (struct body*) malloc(sizeof(struct body));
    memset(body_request, 0, sizeof(struct body));

    req_context = (struct context*) malloc(sizeof(struct context));
    memset(req_context, 0, sizeof(struct context));

    whole_response = malloc(sizeof(struct response));
    memset(whole_response, 0, sizeof(struct response));

    memset(req_header_lst, 0, sizeof(req_header_lst));
    memset(res_header_lst, 0, sizeof(res_header_lst));
}

/*
Find the path, query parameters and fragment in the URI.
Parameter: 
- char* path: A pointer to a list of characters with the PATH including query parameters
Returns Nothing
*/
void parse_uri(char* path){

    char* ptr = strtok(path, "?");
    char* query_param = strtok(NULL, " ");

    // Set the 'path' 
    size_t amount = 0; 
    begin_request->path = url_decode(ptr, &amount);
    begin_request->path_len = amount;

    // No query parameters on this request
    if(query_param == NULL){
        return;
    }

    // Initial call 
    ptr = strtok(query_param, "&"); 

    // Finding ALL of the query parameters
    while(ptr != NULL){
         // Create the query parameter data type to store
        struct query* query_data = malloc(sizeof(struct query)); 

        // Copy the parameter to a local copy to play with
        char* local_cpy = malloc(strlen(ptr) + 1);
        strcpy(local_cpy, ptr);

        // Divide 'key' and 'value' with a nullbyte
        char* query_value = strstr(local_cpy, "=");
        if(query_value != NULL && strlen(query_value) > 1){
            query_value[0] = '\0'; // Erase the query string
            query_value += 1; // Increase the pointer passed in
        }

        // URL decode the 'key'
        char* key_decoded = url_decode(local_cpy, &amount);
        query_data->name = key_decoded;
        query_data->name_len = amount;

        if(query_value != NULL){ // If there is an '=':
            query_data->value = url_decode(query_value, &amount); // Decode the value
            query_data->value_len = amount;

        }else{ // If NO value after the 'key':
            query_data->value = malloc(amount); // Create a blank memory for later usage
            query_data->value_len = 0;
        }

        free(local_cpy);

        // Maximum amount of query parameters
        if(begin_request->query_amount >= 0x10){
            return;
        }

        // Add query parameters into the 
        begin_request->query_params[begin_request->query_amount] = query_data;
        begin_request->query_amount++; 

        ptr = strtok(NULL, "&");
    }

    return;
}

/*
Parse a HTTP header into the 'req_headers_lst'.
Parameters: 
- int sockfd: The file descriptor for the socket
- uint* header_count: A pointer to an integer.

Return 
- 0 if ONLY newline. 
- 1 otherwise
*/
int parse_single_header(int sockfd, uint* header_count){
    size_t amount = 0;
    char* one_line = read_wrapper(sockfd, &amount); 
    if(strcmp(one_line, "\r\n") == 0){
        // Body is coming next
        return 0;
    }

    struct header* header_data = malloc(sizeof(struct header)); // Make header data
    memset(header_data, 0, sizeof(struct header));

    // Divide key and value of header
    size_t key_size; 
    size_t value_size; 
    char* key_line = one_line;
    char* value_line = memchr(one_line, ':', amount); 
    
    // Get difference for the copy below
    if(value_line != NULL){
        key_size = value_line - key_line; // The size of the key
        value_line += 1; // Don't want the colon
        value_size = amount - key_size; // The rest of the size is the value
    } // No colon (':') in the header
    else {
        key_size = amount; 
        value_size = 0;
    }

    // Initialize and copy data into the 'name' of the header
    header_data->name = malloc(key_size + 1); // Create the 'header data' pointer
    memcpy(header_data->name, key_line, key_size); // Add in the 'key'
    header_data->name_len = key_size;

    if(value_line != NULL){ // If there is a colon (':')
        header_data->name[key_size] = '\0'; // Finish the string
        header_data->value = malloc(value_size + 1); // Create the 'header data' pointer

        memcpy(header_data->value, value_line, value_size); // Add in the 'value'
        
        header_data->value_len = value_size - 2;
        header_data->value[value_size - 2] = '\0';

    }else{ // If NO value after the 'key':
        header_data->value = malloc(key_size); // Default pointer to 'key' size
        header_data->value_len = key_size;
        header_data->name[key_size - 1] = '\0'; // Remove the 'carriage return' from the key
    }

    int index = 0; 

    // Set the custom callback for the header IF it should have a custom use.
    while(custom_headers[index] != NULL){
        if(strcasecmp(custom_headers[index]->name, header_data->name) == 0){
            header_data->custom_callback = custom_headers[index]->custom_callback;
        }
        index += 1; 
    }

    // Save the header information
    req_header_lst[*header_count] = header_data; 
    *header_count += 1;

    //printf("Key: %s, Value: %s\n", header_data->name, header_data->value);
    free(one_line);
    return 1;
}

/*
Take in each of the headers via a socket and process them individually. 
Parameters: 
- int sockfd: The file descriptor for the socket
*/
void parse_headers(int sockfd){
    uint header_count = 0;
    int should_continue = 1;

    // Iterate until BODY or twenty headers
    while(header_count < 0x30 && should_continue == 1){
        should_continue = parse_single_header(sockfd, &header_count);
    }
}

/*
Interpret a single header with side effects. The following headers are supported: 
- X-Forwarded-Path: Dynamically change the PATH of the request.
- X-Forwarded-Host: Dynamically change the HOST of the request
- Connection: Keep the connection open and drop headers
- Content-Length: Length of the body of the request
- Content-Type: The TYPE of the request of the body. 
- Authorization: Authenticating as a user
- User-Agent: The user information for the request (Chrome, Firefox, etc.)
- Host: The hostname of the request
- Origin: The origin of the request
- X-Request-Id: The request ID used for the response
- Custom: TODO? 
*/
int interpret_header(uint index){

    // Check if there is CUSTOM handling first for the header
    if(req_header_lst[index]->custom_callback != NULL){
        (req_header_lst[index]->custom_callback)(req_header_lst[index]->name, req_header_lst[index]->value);
    }

    // Rewrite the PATH of the request
    else if(strcasecmp(req_header_lst[index]->name, "X-Forwarded-Path") == 0){
        // SecDo: Buffer overflow
        memcpy(begin_request->path, req_header_lst[index]->value, req_header_lst[index]->value_len);
        return 0;
    }

    // Rewrite the HOST of the request
    else if(strcasecmp(req_header_lst[index]->name, "X-Forwarded-Host") == 0){
        if(req_context->host == NULL) // Null pointer deference
            return 1; 
        free(req_context->host); // Free the OLD pointer
        req_context->host = malloc(req_header_lst[index]->value_len + 1); // Create the allocation
        memcpy(req_context->host, req_header_lst[index]->value, req_header_lst[index]->value_len);
        req_context->host_len = req_header_lst[index]->value_len;
        return 0;
    }
    // Connection header and things
    else if(strcasecmp(req_header_lst[index]->name, "Connection") == 0){

        // If CLOSE, then we don't do anything 
        if(strcasecmp(req_header_lst[index]->value, "close") == 0){
            is_active_connection = 0; // Defaults to 0. 
            return 0;
        }
        // Send MORE than 1 request in this connection
        is_active_connection = 1; 

        size_t cur_size = req_header_lst[index]->value_len; // Amount of bytes
        char* connection_values = req_header_lst[index]->value; // Pointer to string
        int chr_index = 0; // Location in the parsing of the string

        char* comma_pointer = memchr(connection_values + chr_index, ',', cur_size - chr_index);
        if(comma_pointer == NULL){
            comma_pointer = connection_values + cur_size; // End of the string
        }

        size_t value_size = 0;
        while(chr_index < cur_size){
            if(comma_pointer != NULL){
                // The LENGTH of our location between the commas
                value_size = comma_pointer - (connection_values + chr_index);
            }else{ // End of the string
                value_size = (connection_values + cur_size) - (connection_values + chr_index); 
            }

            int header_index = 0; 
            while(req_header_lst[header_index] != NULL && header_index < 0x30){
                // SecDo: which VALUE should we use for the 'strncmp?'
                if(strncmp(req_header_lst[header_index]->name, connection_values + chr_index, value_size) == 0){
                    free(req_header_lst[header_index]->name); 
                    free(req_header_lst[header_index]->value); 
                    free(req_header_lst[header_index]);
                    break;
                }
                header_index += 1; 
            }

            // Move the index ABOVE the comma or end the loop
            if(chr_index + value_size >= cur_size){
                chr_index = chr_index + value_size; // End the loop
            }else{
                chr_index = chr_index + value_size + 1; // Move up the index to AFTER the previous string
            }

            comma_pointer = memchr(connection_values + chr_index, ',', cur_size - chr_index);
        }
        return 0;
    }

    // Length of the BODY of the request
    else if(strcasecmp(req_header_lst[index]->name, "Content-Length") == 0){
        int length = atoi(req_header_lst[index]->value); // Get length of header
        body_request->length = length; 
        return 0;
    }

    // TYPE of request being used
    else if(strcasecmp(req_header_lst[index]->name, "Content-Type") == 0){
        if(strcasestr(req_header_lst[index]->value, "plain")){
            body_request->type = PLAIN; 
        }
        else if(strcasestr(req_header_lst[index]->value, "form")){
            body_request->type = FORM; 
        }else{
            body_request->type = NONE; 
        }
        return 0;
    }
    // Authorization header parsing
    else if(strcasecmp(req_header_lst[index]->name, "Authorization") == 0){

        // admin:admin base64 encoded
        if(strncmp("YWRtaW46YWRtaW4=", req_header_lst[index]->value,  req_header_lst[index]->value_len) == 0){
            is_authenticated = 1; 
        }
        return 0;
    }

    // Parse the user agent in the request
    else if(strcasecmp(req_header_lst[index]->name, "User-Agent") == 0){
        req_context->user_agent = malloc(req_header_lst[index]->value_len + 1);
        memcpy(req_context->user_agent, req_header_lst[index]->value, req_header_lst[index]->value_len);
        req_context->user_agent_len = req_header_lst[index]->value_len;
        return 0;
    }
    // Parse the Host in the request
    else if(strcasecmp(req_header_lst[index]->name, "Host") == 0){
        req_context->host = malloc(req_header_lst[index]->value_len + 1);
        memcpy(req_context->host, req_header_lst[index]->value, req_header_lst[index]->value_len);
        req_context->host_len = req_header_lst[index]->value_len;
        return 0;
    }
    // Parse the Origin in the request
    else if(strcasecmp(req_header_lst[index]->name, "Origin") == 0){
        req_context->origin = malloc(req_header_lst[index]->value_len + 1);
        memcpy(req_context->origin, req_header_lst[index]->value, req_header_lst[index]->value_len);
        req_context->origin_len = req_header_lst[index]->value_len;
        return 0;
    }
    // Parse request Id - Put it into the response
    else if(strcasecmp(req_header_lst[index]->name, "X-Request-Id") == 0){
        int res_index = 0; 
        while(res_header_lst[res_index] != NULL && res_index < 0x20) // SecDo - overiteration bug
            res_index += 1; // Place where the header can be built at

        // Create the memory for the raw response headers
        struct header* header_data = malloc(sizeof(struct header)); // Make header data
        header_data->name= malloc(req_header_lst[index]->name_len); 
        header_data->value = malloc(req_header_lst[index]->value_len);

        // Add the information from the request to the response header
        memcpy(header_data->name, req_header_lst[index]->name, req_header_lst[index]->name_len);
        memcpy(header_data->value, req_header_lst[index]->value, req_header_lst[index]->value_len);
        header_data->name_len = req_header_lst[index]->name_len;
        header_data->value_len = req_header_lst[index]->value_len;
        res_header_lst[res_index] = header_data;
        return 0;
    }
    // TODO: Custom headers? 

    return 1; 
}

/*
Interpret each of the headers from the request.
Has side-effects in global variables. 
*/
void interpret_headers(){
    uint counter = 0;
    while(counter < 0x30 && req_header_lst[counter] != NULL){
        interpret_header(counter);
        counter +=1;
    }
}

/*
Parse the body of the request, depending on the type. 
Puts the body information into 'body_request'. 
Parameters: 
- int sockfd: The file descriptor for the socket
*/
void parse_body(int sockfd){
    // Safe requests have NO body.
    if(strcasecmp(begin_request->verb, "GET") == 0 || strcasecmp(begin_request->verb, "HEAD") == 0){
        return;
    }

    // Read that CAN handle newlines
    char* body_buffer = read_body_wrapper(sockfd, body_request->length); 

    // Parse the different types of requests
    // TODO: Just SET 'body_buffer' here instead of reallocating...
    if(body_request->type == PLAIN){ // Easy to do. Make a buffer then go!
        //body_request->data_object = malloc(body_request->length + 1);
        //memcpy(body_request->data_object, body_buffer, body_request->length);
        body_request->data_object = body_buffer;
    }
    else if(body_request->type == FORM){

        // Creating the form body pointer to be used
        struct form_body* form_body_ptr = malloc(sizeof(struct form_body));
        memset(form_body_ptr, 0, sizeof(struct form_body)); // Initialize the data
        body_request->data_object = form_body_ptr; 

        // TODO: Use 'memtok' in order to use NULL bytes
        // Find the end of the first key:value pair
        char* ptr = strtok(body_buffer, "&"); 
        
        size_t amount; 

        // Finding ALL of the query parameters
        while(ptr != NULL){

            // Create the query parameter data type to store
            struct query* query_data = malloc(sizeof(struct query)); 

            // Copy the parameter to a local copy to play with
            char* local_cpy = malloc(strlen(ptr) + 1);
            strcpy(local_cpy, ptr);

            // Divide 'key' and 'value' with a nullbyte
            char* query_value = strstr(local_cpy, "=");
            if(query_value != NULL && strlen(query_value) > 1){
                query_value[0] = '\0'; // Seperate the 'key' and 'value'
                query_value += 1; // Increase the pointer passed in
            }

            // URL decode the 'key'
            char* key_decoded = url_decode(local_cpy, &amount);
            query_data->name = key_decoded;
            query_data->name_len = amount;

            if(query_value != NULL){ // If there is an '=':
                query_data->value = url_decode(query_value, &amount); // Decode the value
                query_data->value_len = amount;

            }else{ // If NO value after the 'key':
                query_data->value = malloc(amount); // Create a blank memory for later usage
                query_data->value_len = 0;
            }

            free(local_cpy);

            // Store the data to be used later
            form_body_ptr->query_params[form_body_ptr->count] = query_data;
            form_body_ptr->count++;
            if(form_body_ptr->count >= 0x10){ // Entries are full
                return;
            }

            // Find the next parameter. Returns NULL if the at the end.
            ptr = strtok(NULL, "&"); 
        }
        free(body_buffer);
    }else {
        body_request->type = NONE;
    }
}

/*
Get statically hosted files. 
Fills the 'whole_response' struct with text, length and status. 
*/
void serve_file(){

    // Read in the file
    char* data = read_file(begin_request->path); 

    // File couldn't be read or does not exist
    if(data == NULL){
        whole_response->status = 404;  // Status code

        // Callback for custom 404/default page page
        if(whole_response->default_callback != NULL){
            whole_response->response_text = (*whole_response->default_callback)();
            goto setup_type;  
        }

        // Copy the text for the response
        int res_len = snprintf(NULL, 0, "Route %s does not exist\n", begin_request->path);
        whole_response->response_text = malloc(res_len + 1);
        snprintf(whole_response->response_text, res_len, "Route %s does not exist\n", begin_request->path);
        whole_response->length = strlen(whole_response->response_text);
        free(data);

    }else{
        whole_response->status = 200;  // Status code
        whole_response->response_text = data;
        whole_response->length = strlen(whole_response->response_text);
    }

setup_type: ;

    // Find an empty header slot
    int index = 0;
    while(res_header_lst[index] != NULL && index < 0x20) // SecDo: Over iteration bug!
        index += 1; 

    res_header_lst[index] = malloc(sizeof(struct header));
    res_header_lst[index]->name = malloc(strlen("Content-Type") + 1);
    res_header_lst[index]->value = malloc(0x80); // Seems large enough

    strcpy(res_header_lst[index]->name, "Content-Type");
    res_header_lst[index]->name_len = strlen("Content-Type"); 

    // Setup the Content-Type for the response
    if(str_ends_with(begin_request->path, ".html")  == 0)
        strcpy(res_header_lst[index]->value, "text/html");
    else if(str_ends_with(begin_request->path, ".js") == 0)
        strcpy(res_header_lst[index]->value, "text/javascript");  
    else if(str_ends_with(begin_request->path, ".json") == 0)
        strcpy(res_header_lst[index]->value, "application/json");  
    else // Default
        strcpy(res_header_lst[index]->value, "text/plain"); 

    res_header_lst[index]->value_len = strlen(res_header_lst[index]->value);    
}

/*
Basic initialization of the server.

Parameter: 
- A pointer to a list of routers with an unlimited size

Return: 
- int sockfd: File descriptor from the setup socket. 
*/
int initialize_server(struct route** my_routes, struct custom_header** my_custom_headers){
    init_memory(); 

    int sockfd = setup_socket();

    routes = my_routes; 
    custom_headers = my_custom_headers;
    return sockfd;
}

/*
Sending the response back to the user
Puts 'whole_response' information and 'res_headers_lst' into a string  

Parameters: 
- int sockfd: File descriptor for the socket
*/
void send_response(int sockfd){

    char status_buf[0x20]; 

    // Create the buffer and NULL it out
    unsigned short size = 0x100; // Size of the buffer
    size_t index = 0; // Current location inside the buffer

    char* full_response = malloc(size); 
    memset(full_response, 0, size);

    // Add the protocol to the first line
    full_response = add_string(full_response, &index, &size, begin_request->protocol_no, strlen(begin_request->protocol_no));

    full_response = add_string(full_response, &index, &size, " ", 1); // Add the SPACE between the two

    snprintf(status_buf, 0x20, "%d", whole_response->status); // Convert int to string
    full_response = add_string(full_response, &index, &size, status_buf, strlen(status_buf)); // Add the SPACE between the two

    full_response = add_string(full_response, &index, &size, "\r\n", 2); // Add the newline carriage return to end the line

    // While loop to add ALL of the response headers
    unsigned short header_index = 0; 
    while(res_header_lst[header_index] != NULL){ // SecDo: Over iterate on the additions here
        full_response = add_string(full_response, &index, &size, res_header_lst[header_index]->name, res_header_lst[header_index]->name_len); // Key of the header
        full_response = add_string(full_response, &index, &size, ":", 1); // Add the newline carriage return to end the line
        full_response = add_string(full_response, &index, &size, res_header_lst[header_index]->value, res_header_lst[header_index]->value_len); // Add the newline carriage return to end the line
        full_response = add_string(full_response, &index, &size, "\r\n", 2); // Add the newline carriage return to end the line
        header_index += 1; 
    }

    // Add the Content-Length MANUALLY, based upon the BODY of the request length
    full_response = add_string(full_response, &index, &size, "Content-Length:", 15); 

    snprintf(status_buf, 0x20, "%ld", whole_response->length); // Convert int to string
    full_response = add_string(full_response, &index, &size, status_buf, strlen(status_buf)); // Add the SPACE between the two

    full_response = add_string(full_response, &index, &size, "\r\n\r\n", 4); // Add the newline carriage return to end the line

    // Add the BODY of the response
    full_response = add_string(full_response, &index, &size, whole_response->response_text, whole_response->length); 

    printf("Full Response: %s\n\n", full_response);

    send(sockfd, full_response, index, 0 );
    printf("Hello message sent\n");

    // Clean it up!
    free(full_response); 
    
    cleanup_response();
}

/*
Based upon the path, call a route supplied function. 
*/
void serve_api(){
    int index = 0;

    // API handling
    while(routes[index] != NULL ){
        if(strcmp(begin_request->path, routes[index]->route) == 0 && ((strcmp(routes[index]->verb, begin_request->verb) == 0) || strcmp(routes[index]->verb, "ALL") == 0)){

            // Call the routes handler and set the data to send
            struct server_response* my_response = (*routes[index]->handle_callback)();

            whole_response->response_text = my_response->data; 
            whole_response->status = my_response->status;
            whole_response->length = my_response->length; 
            if(whole_response->status == 0){
                whole_response->status = 200;
            }
            break; 
        }
        index += 1; 
    }

    // If NOTHING is hit - 404
    if(whole_response->status == 0){
        int res_len = snprintf(NULL, 0, "Route %s does not exist\n", begin_request->path);
        whole_response->response_text = malloc(res_len + 1);
        whole_response->status = 404;
        snprintf(whole_response->response_text, res_len, "Route %s does not exist\n", begin_request->path);           
        whole_response->length = strlen(whole_response->response_text);
    }
}

/*
Free and remove the references for response items
*/
void cleanup_response(){

    // Response headers
    int index = 0;
    while(res_header_lst[index] != NULL){
        free(res_header_lst[index]->name);
        free(res_header_lst[index]->value);
        free(res_header_lst[index]); 
        index += 1; 
    }

    free(begin_request);
}

/*
Free and remove 
*/
void cleanup_request(){
    unsigned short index = 0;

    // Beginning of the request
    while(begin_request->query_params[index] != NULL){
        free(begin_request->query_params[index]->name);
        free(begin_request->query_params[index]->value);
        index += 1;
    }
    free(begin_request->path);
    //free(begin_request); // Was a UAF by accident!

    // Clean up the headers 
    index = 0;  
    while(req_header_lst[index] != NULL){ // Bug here...
        free(req_header_lst[index]->name);
        free(req_header_lst[index]->value);
        free(req_header_lst[index]); // TODO: Free header struct as well
        index += 1;
    }

    // Body 
    index = 0;
    if(body_request->type == FORM && body_request->data_object != NULL){
        struct form_body* body = ((struct form_body*)(body_request->data_object));
        while(index < body->count){
            free(body->query_params[index]->name);
            free(body->query_params[index]->value);
            index += 1; 
        }
    }
    free(body_request->data_object);

    // Clean up the context of the request
    free(req_context->host);
    free(req_context->origin);
    free(req_context->user_agent);
    free(req_context);

    is_authenticated = 0;
}

/*
Main fork loop for handling connections and processing requests.
Calls 'server_main' to handle the main processing of a request. 
Parameters: 
- int sockfd: Socket file descriptor
*/
void serve(int sockfd){

    // Setting up socket information
    struct sockaddr_in address; // Address information
    address.sin_family = AF_INET;  // IPv4
    address.sin_addr.s_addr = INADDR_ANY; // Accept ALL Ips for the machine.
    address.sin_port = htons(8081); // Port number

    while(1){
        // Accept an incoming connection
        int addrlen = sizeof(address);
        int new_socket_fd = accept(sockfd, (struct sockaddr *)&address, &addrlen);
        if (new_socket_fd < 0)
        {
            puts("socket: accept failure");
            exit(EXIT_FAILURE);
        }

        // Hit the connection ONCE! :) 
        is_active_connection = 1; 

        // Fork. Then, use CHILD process to continue with the current request
        if(fork() == 0){
            close(sockfd);

            // While the socket is continued to be written to and used
            while(is_active_connection == 1){
                server_main(new_socket_fd);
            }
            close(new_socket_fd);
            exit(0);
        }

        // If the parent, then look for another connection in the while loop
        close(new_socket_fd);
    }
}


/*
The main code for handling a single HTTP request. 
From request to response. 

Parameters: 
- int sockfd: Socket file descriptor
*/
void server_main(int sockfd){
    
    // Default the value to 0.
    // Can be edited by the 'Connection' header to be turned on.
    is_active_connection = 0; 
    int amount = 0;
    size_t verb_size; 

    // TODO: Abstract this away a little more :) 
    // Read in the first line of the request
    char* first_line = read_wrapper(sockfd, &amount); 
    
    // Reuse the 'first_line' variable to find all of the necessary information
    char* verb = strtok(first_line, " ");
    char* path = strtok(NULL, " ");
    char* protocol = strtok(NULL, " ");

    if(path == NULL || protocol == NULL){
        printf("protocol: Invalid first line");
        exit(EXIT_FAILURE);
    }

    protocol[strlen(protocol) - 2] = '\0'; // Remove the carriage return

    // Improper protocol  
    if(strcmp(protocol, "HTTP/1.1") != 0 ){
        printf("protocol: %s\n is not valid", protocol); 
        free(first_line);
        exit(EXIT_FAILURE);
        // SecDo: Exit or FAKE exit or ASSERT
    }

    parse_uri(path);

    char* verb_decoded = url_decode(verb, &verb_size); 

    // Move the verb into this struct
    strncpy(begin_request->verb, verb_decoded, 0x40); 
    strncpy(begin_request->protocol_no, protocol, 0x40); // Copying over the protocol information

    // Done with the first line parsing
    free(first_line); // Vulnerability - SecDo: potential to cause vulnerability
    free(verb_decoded);

    // Get and intrepret the headers sent
    parse_headers(sockfd); 
    interpret_headers();

    // Get the BODY of the request, depending on the Content-Type header
    parse_body(sockfd);

    // Static files
    if(str_starts_with(begin_request->path, "/files/") == 0){
        serve_file();
    
    // Check to see if an API was hit.
    }else{
        serve_api();
    }

    // Free all of the data from the request
    cleanup_request(); 

    // Return the response 
    send_response(sockfd); 

    // Recreate the important variables, if we need to
    if(is_active_connection){
        init_memory();
    }
}