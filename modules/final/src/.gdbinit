set environment LD_PRELOAD /home/pwn_heap/Desktop/heap_training/libc_versions/2.31/libc-2.31.so
set environment LD_LIBRARY_PATH /usr/lib/x86_64-linux-gnu

set detach-on-fork off
set follow-fork-mode child

# Setup different version of LibC
dir ../../../libc_versions/2.31

# SigChild pass through

# Stop when getting to exit. Then, attach BACK to the original process we forked from.
break exit 
commands
silent
run-internal
echo "Back in the original process\n"
end

# We want the process to work when we go to a new process
break system 
commands
#silent
set detach-on-fork on
set follow-fork-mode child
echo In 'system'. Run 'continue'!
#continue
end 

python
class BetterRun (gdb.Command):
  '''
  Deal with going between forked child and the fork server easily with 'run'. 

  This is done by HOOKING 'run'. When 'run' is called, it will recreate the entire
  process. At this point, we will hook into this and KILL that process.
  Once we have killed that process, we will jump back to our original process for
  the forker server to wait for a new connection. 

  This is not required but makes switching from processes easier. Otherwise, 
  a good understanding of inferior related commands is required in order to debug
  this. 
  '''

  def __init__ (self):
    super (BetterRun, self).__init__ ("run-internal", gdb.COMMAND_USER)

  # Run but attach to process or fork depending on what is going on
  def invoke (self, arg, from_tty):
  
    # To ensure that we will stop the other process and follow fork on the correct one :)
    gdb.execute("set detach-on-fork off")
    gdb.execute("set follow-fork-mode child")

    inferiors = gdb.inferiors()

    counter = 0 # The amount of 'non-dead' inferiors
    lowest_pid = 2 ** 32 # The lowest PID is the PARENT process of the server. FIND this.
    lowest_num = -1 # The 'inferior' number being used
    for inferior in inferiors:
      if(inferior.pid != 0): # Checks to see if the inferior is alive or not
        counter += 1
      if(inferior.pid < lowest_pid and inferior.pid != 0): # Find the parent inferior
        lowest_pid = inferior.pid
        lowest_num = inferior.num
    
    # Shouldn't be possible? If it is, then just hit 'run' again
    if(counter == 0):
        # Do normal 'run' since nothing weird is happening here now. 
        gdb.execute("run")
        return 

    elif(counter == 1): 
        # Just continue as normal! 
        return

    # Attach to the original process & kill the child we are on.
    else:
        for inferior in inferiors:
          if(inferior.num != lowest_num):
            # Kill child process
            gdb.execute("kill inferiors " + str(inferior.num))

        # Move BACK to the parent process and continue like nothing happened. 
        gdb.execute("inferior " + str(lowest_num))
        gdb.execute("c")


# Run our plugin
BetterRun()
BetterRun().dont_repeat()
end

# Code that runs directly AFTER run happens
define hookpost-run 
  run-internal
end

