#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

/*
gcc storage2.c -o storage2

Cause a double free vulnerability that DOES NOT crash the program.
*/

int SIZE;

void handler(){
	puts("Crashed! Passed level 1 :)");
}

// Checks to see if the allocated pointers is in the free list. If so, it zeros out the ptr. 
void* check_for_freed(int** ptr_lst, int* ptr, int front){
	for (int i = 0; i < front; i++){
		if(ptr_lst[i] == ptr){
			ptr_lst[i] = 0x0;
		}
	}
	return ptr_lst;
}

// Checks to see if a pointer has been freed twice :)
int did_double_free(int ** free_lst, int counter){
	
	for (int i = 0; i < counter; i++){
		for (int j = 0; j < counter; j++){
			if(i != j && free_lst[i] == free_lst[j]){
				return 1; 
			}	
		}
	}
	return 0;
}

int main(int argc, char* argv[]){

	// Ignore...The handler for the the crash 	
	signal(SIGABRT, handler);

	int front = 0;
	int option; 
 	int* ptr_lst[20]; 
	int* free_lst[20];
	int free_lst_count = 0;

	// Set the size for the malloc call to use. 
	// Add a parameter in order to change the malloc size. Defaults to 0x30 otherwise.
	if(argc > 1){
		// Unsorted/small bin
		SIZE = 0x100;
	}else{
		// Fastbin
		SIZE = 0x30;
	}

	while(1){
		puts("Options:");
		puts("===========");
		puts("1. Create");
		puts("2. Free");
		printf("> ");
		scanf("%d", &option);		

		if(option == 1){

			// Create a chunk and add it to the list.
			ptr_lst[front] = malloc(SIZE);
		
			// Validate that the ptr here for double free...
			front += 1;
	
			// If a ptr has been freed, then reallocated by malloc we would not consider this a double free (even if the occurence is in the list already. So, the ptr gets zeroed out in the list.
			check_for_freed(free_lst, ptr_lst[front -1], front);
		}
	
		// Free a chunk
		else if(option == 2){
			puts("Enter the index to free");
			scanf("%d", &option);
			if(option >= front) continue;

			// Frees the ptr in the list	
			free(ptr_lst[option]);

			// Add the ptr to my local free list.	
			free_lst[free_lst_count] = ptr_lst[option];
			free_lst_count +=1;
		}

		// If too many pointers have been allocated, then the program exists, in order to prevent an overflow.
		if(front == 19){
			break;
		}	

		// Check to see if a valid double free occurred or not.
		if(did_double_free(free_lst, free_lst_count) == 1){
			puts("Double free success :)");
			break;
		}
	}
}
