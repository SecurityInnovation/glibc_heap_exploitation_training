'''
Challenges for the double free fun :)

2.23 Fastbins
Unsorted Bins <-- possible via allocate, free, REALLOCATE, then free again. But, NOT what we're going after here.
TCache 2.26
TCache 2.29 (tcache double free protections
'''


from pwn import * 
import os
from sys import argv

if(len(sys.argv) == 1):
	print("Options")
	print("================")
	print("0. Make Crash :)")
	print("1. Fastbins - GLibC 2.23")
	print("2. Unsorted Bin - GLibC 2.23") 
	print("3. TCache 1 - GLibC 2.26") 
	print("4. TCache 2 - GLibC 2.29 (0x100)") 
	print("5. TCache 3 - GLibC 2.29 (0x40)") 
	exit(1) 

option = int(argv[1]) 
base_path = "../../../libc_versions/"
libc_name = base_path
ld_name = base_path
source_loc = base_path
if(option == 0):
	print("Using Fastbins on GLibC 2.23")
	print("Just make the program crash via a double free :)")
	libc_name += "/2.23/libc-2.23.so"
	ld_name += "/2.23/ld-2.23.so"
	source_loc += "/2.23/"

elif(option == 1):
	print("Using Fastbins on GLibC 2.23")
	print("Try to AVOID detection") 
	libc_name += "/2.23/libc-2.23.so"
	ld_name += "/2.23/ld-2.23.so"
	source_loc += "/2.23/"
elif(option == 2):
	print("Using Unsorted Bins on GLibC 2.23")
	print("Try to AVOID detection (is this possible?)")
	libc_name += "/2.23/libc-2.23.so"
	ld_name += "/2.23/ld-2.23.so"
	source_loc += "/2.23/"
elif(option == 3):
	print("Using TCache Bins on GLibC 2.26")
	print("Try to AVOID detection")
	libc_name += "/2.26/libc-2.26.so"
	ld_name += "/2.26/ld-2.26.so"
	source_loc += "/2.26/"
elif(option == 4):
	print("Using TCache Bins on GLibC 2.29 (0x100 sized chunks) ")
	print("Try to AVOID detection -- House of Botcake")
	libc_name += "/2.29/libc-2.29.so"
	ld_name += "/2.29/ld-2.29.so"
	source_loc += "/2.29/"
elif(option == 5):
	print("Using TCache Bins on GLibC 2.29 (0x40 sized chunks) ")
	print("Try to AVOID detection -- Fastbin Dup with TCache") 
	libc_name += "/2.29/libc-2.29.so"
	ld_name += "/2.29/ld-2.29.so"
	source_loc += "/2.29/"

env = {}

# Binary setup
elf_name = './storage'

elf = ELF(elf_name)
libc = ELF(libc_name)
env = {"LD_PRELOAD": libc.path}

if(option == 2 or option == 4):
	p = process([ld_name, elf.path, str(1) ] ,env=env)
	gdb.attach(p)

else: 
	p = process([ld_name, elf.path] ,env=env)
	gdb.attach(p)

def malloc():
	p.sendlineafter("2.", "1") 

def free(index):
	p.sendlineafter("2.", "2") 
	p.sendlineafter("free", str(index))

p.interactive()
